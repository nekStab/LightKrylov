var tipuesearch = {"pages":[{"title":" LightKrylov ","text":"LightKrylov Warning This API documentation for the LightKrylov package is built from the source code in the main branch and does not track the current development in dev or any other branches.\n   If you use another branch, please refer to the in-code documentation.\n   Use the navigation bar at the top of the screen to browse modules , procedures , source files , etc. This is the main API documentation landing page generated by FORD . This documentation is released under the CC-BY-SA license while the LightKrylov source code is distribution under the BSD-3 Clause one. Scope The goal of LightKrylov is to provide a lightweight implementation of many standard Krylov techniques using modern Fortran features, including: Linear solvers for cg when is a symmetric (hermitian) positive definite matrix. gmres when is a non-symmetric square linear operator. Krylov-based matrix factorizations arnoldi - Construct an upper Hessenberg matrix and an orthonormal (unitary) basis capturing the dominant eigenspace of a square non-symmetric matrix using the Arnoldi iterative process. lanczos - Construct a symmetric (hermitian) tridiagonal matrix and an orthonormal (unitary) basis capturing the dominant eigenspace of a symmetric (hermitian) linear operator using the Lanczos iterative process. bidiagonalization - Construct a bidiagonal matrix and orthonormal bases and for the dominant column (resp. row) span of a general linear operator using the Lanczos bidiagonalization iterative process. Eigenvalue solvers for eigs to compute the largest eigenvalues and associated eigenvectors of a general square linear operator using the Arnoldi iterative process. eighs to compute the largest eigenvalues and associated eigenvectors of a symmetric (hermitian) linear operator using the Lanczos iterative process. Singular value decomposition svds to compute the leading singular triplets of a general linear operator using the Lanczos bidiagonalization iterative process. Solving a system of nonlinear equations newton to find the solution to using a Newton-Krylov solver with optimal step size found by a simple bisection method. While similar and more feature-complete packages exist (e.g. Arpack , SLEPC or Trilinos ), the use of abstract_type in LightKrylov and its nearly non-existant list of dependencies makes it far easier to incorporate into an existing code base. Preliminary benchmark results moreover show that it is on par with Arpack in terms of accuracy and computational performances. Acknowledgment The development of LightKrylov is part of an on-going research project funded by Agence Nationale pour la Recherche (ANR) under the grant agreement ANR-22-CE46-0008. The project started in January 2023 and will run until December 2026.\nWe are also very grateful to the fortran-lang community and the maintainers of stdlib . Related projects LightKrylov is the base package of our ecosystem. If you like it, you may also be interested in: LightROM : a lightweight Fortran package providing a set of functions for reduced-order modeling, control and estimation of large-scale linear time invariant dynamical systems. neklab : a bifurcation and stability analysis toolbox based on LightKrylov for the massively parallel spectral element solver Nek5000 . Developer Info Jean-Christophe Loiseau, Simon Kern, and Ricardo Frantz","tags":"home","url":"index.html"},{"title":"newton_dp_metadata – LightKrylov ","text":"type, public, extends( abstract_metadata ) :: newton_dp_metadata Metadata for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag integer, public :: eval_counter_record = 0 System response evaluation counter:\nN.B.: For each of these evals the current residual and tolerance are recorded. integer, public :: info = 0 Copy of the information flag for completeness logical, public :: input_is_fixed_point = .false. Flag indicating lucky convergence (Newton is not run and no solution is computed) integer, public :: n_iter = 0 Iteration counter real(kind=dp), public, dimension(:), allocatable :: res Residual history real(kind=dp), public, dimension(:), allocatable :: tol Tolerance history Type-Bound Procedures procedure, public, pass(self) :: print => print_newton_dp private  subroutine print_newton_dp(self, reset_counters, verbose) Arguments Type Intent Optional Attributes Name class( newton_dp_metadata ), intent(inout) :: self logical, intent(in), optional :: reset_counters Reset all counters to zero after printing? logical, intent(in), optional :: verbose Print the residual full residual history? procedure, public, pass(self) :: record => record_data_dp private  subroutine record_data_dp(self, res, tol) Arguments Type Intent Optional Attributes Name class( newton_dp_metadata ), intent(inout) :: self real(kind=dp), intent(in) :: res Residual of the current evaluation real(kind=dp), intent(in) :: tol Tolerance of the current evaluation procedure, public, pass(self) :: reset => reset_newton_dp private  subroutine reset_newton_dp(self) Arguments Type Intent Optional Attributes Name class( newton_dp_metadata ), intent(inout) :: self Source Code type , extends ( abstract_metadata ), public :: newton_dp_metadata !! Metadata for Newton-Krylov fixed-point iteration. integer :: n_iter = 0 !! Iteration counter integer :: eval_counter_record = 0 !! System response evaluation counter: !! N.B.: For each of these evals the current residual and tolerance are recorded. real ( dp ), dimension (:), allocatable :: res !! Residual history real ( dp ), dimension (:), allocatable :: tol !! Tolerance history logical :: converged = . false . !! Convergence flag logical :: input_is_fixed_point = . false . !! Flag indicating lucky convergence (Newton is not run and no solution is computed) integer :: info = 0 !! Copy of the information flag for completeness contains procedure , pass ( self ), public :: print => print_newton_dp procedure , pass ( self ), public :: reset => reset_newton_dp procedure , pass ( self ), public :: record => record_data_dp end type newton_dp_metadata","tags":"","url":"type/newton_dp_metadata.html"},{"title":"newton_dp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: newton_dp_opts Options for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print interation metadata on exit (default = .false.) logical, public :: ifbisect = .false. Bisection toggle to enforce residual reduction (default = .false.) integer, public :: maxiter = 100 Maximum number of Newton iterations (default = 100) integer, public :: maxstep_bisection = 5 Maximum number of bisections (evaluations of F) for step selection (default = 5)\nIgnored if ifbisect = .false. Source Code type , extends ( abstract_opts ), public :: newton_dp_opts !! Options for Newton-Krylov fixed-point iteration. integer :: maxiter = 100 !! Maximum number of Newton iterations (default = 100) logical :: ifbisect = . false . !! Bisection toggle to enforce residual reduction (default = .false.) integer :: maxstep_bisection = 5 !! Maximum number of bisections (evaluations of F) for step selection (default = 5) !! Ignored if ifbisect = .false. logical :: if_print_metadata = . false . !! Print interation metadata on exit (default = .false.) end type newton_dp_opts","tags":"","url":"type/newton_dp_opts.html"},{"title":"newton_sp_metadata – LightKrylov ","text":"type, public, extends( abstract_metadata ) :: newton_sp_metadata Metadata for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag integer, public :: eval_counter_record = 0 System response evaluation counter:\nN.B.: For each of these evals the current residual and tolerance are recorded. integer, public :: info = 0 Copy of the information flag for completeness logical, public :: input_is_fixed_point = .false. Flag indicating lucky convergence (Newton is not run and no solution is computed) integer, public :: n_iter = 0 Iteration counter real(kind=sp), public, dimension(:), allocatable :: res Residual history real(kind=sp), public, dimension(:), allocatable :: tol Tolerance history Type-Bound Procedures procedure, public, pass(self) :: print => print_newton_sp private  subroutine print_newton_sp(self, reset_counters, verbose) Arguments Type Intent Optional Attributes Name class( newton_sp_metadata ), intent(inout) :: self logical, intent(in), optional :: reset_counters Reset all counters to zero after printing? logical, intent(in), optional :: verbose Print the residual full residual history? procedure, public, pass(self) :: record => record_data_sp private  subroutine record_data_sp(self, res, tol) Arguments Type Intent Optional Attributes Name class( newton_sp_metadata ), intent(inout) :: self real(kind=sp), intent(in) :: res Residual of the current evaluation real(kind=sp), intent(in) :: tol Tolerance of the current evaluation procedure, public, pass(self) :: reset => reset_newton_sp private  subroutine reset_newton_sp(self) Arguments Type Intent Optional Attributes Name class( newton_sp_metadata ), intent(inout) :: self Source Code type , extends ( abstract_metadata ), public :: newton_sp_metadata !! Metadata for Newton-Krylov fixed-point iteration. integer :: n_iter = 0 !! Iteration counter integer :: eval_counter_record = 0 !! System response evaluation counter: !! N.B.: For each of these evals the current residual and tolerance are recorded. real ( sp ), dimension (:), allocatable :: res !! Residual history real ( sp ), dimension (:), allocatable :: tol !! Tolerance history logical :: converged = . false . !! Convergence flag logical :: input_is_fixed_point = . false . !! Flag indicating lucky convergence (Newton is not run and no solution is computed) integer :: info = 0 !! Copy of the information flag for completeness contains procedure , pass ( self ), public :: print => print_newton_sp procedure , pass ( self ), public :: reset => reset_newton_sp procedure , pass ( self ), public :: record => record_data_sp end type newton_sp_metadata","tags":"","url":"type/newton_sp_metadata.html"},{"title":"newton_sp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: newton_sp_opts Options for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print interation metadata on exit (default = .false.) logical, public :: ifbisect = .false. Bisection toggle to enforce residual reduction (default = .false.) integer, public :: maxiter = 100 Maximum number of Newton iterations (default = 100) integer, public :: maxstep_bisection = 5 Maximum number of bisections (evaluations of F) for step selection (default = 5)\nIgnored if ifbisect = .false. Source Code type , extends ( abstract_opts ), public :: newton_sp_opts !! Options for Newton-Krylov fixed-point iteration. integer :: maxiter = 100 !! Maximum number of Newton iterations (default = 100) logical :: ifbisect = . false . !! Bisection toggle to enforce residual reduction (default = .false.) integer :: maxstep_bisection = 5 !! Maximum number of bisections (evaluations of F) for step selection (default = 5) !! Ignored if ifbisect = .false. logical :: if_print_metadata = . false . !! Print interation metadata on exit (default = .false.) end type newton_sp_opts","tags":"","url":"type/newton_sp_opts.html"},{"title":"abstract_vector – LightKrylov ","text":"type, public, abstract :: abstract_vector Base abstract type from which all other types of vectors used in LightKrylov are being derived from. Warning Users should not extend this abstract class to define their own types. Source Code type , abstract , public :: abstract_vector !!  Base abstract type from which all other types of vectors used in `LightKrylov` !!  are being derived from. !! !!  @warning !!  Users should not extend this abstract class to define their own types. !!  @endwarning end type abstract_vector","tags":"","url":"type/abstract_vector.html"},{"title":"abstract_vector_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_vector ) :: abstract_vector_cdp Abstract type to define complex(dp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_cdp Adds two abstract_vector , i.e. . private  subroutine add_cdp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_cdp ), intent(in) :: vec Vector to be added. procedure(abstract_axpby_cdp), public, deferred, pass(self) :: axpby In-place computation of . subroutine abstract_axpby_cdp(alpha, vec, beta, self) Prototype Abstract interface to add/scale two vectors in-place. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: alpha class( abstract_vector_cdp ), intent(in) :: vec Vector to be added/subtracted. complex(kind=dp), intent(in) :: beta class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. procedure, public, pass(self) :: chsgn => chsgn_cdp Change the sign of a vector, i.e. . private  subroutine chsgn_cdp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Vector whose entries need to change sign. procedure(abstract_dot_cdp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_cdp . function abstract_dot_cdp(self, vec) result(alpha) Prototype Abstract interface to compute the dot product. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: self Vectors whose dot product will be computed. class( abstract_vector_cdp ), intent(in) :: vec Vectors whose dot product will be computed. Return Value complex(kind=dp) Result of the dot product. procedure(abstract_get_size_cdp), public, deferred, pass(self) :: get_size Return size of specific abstract vector function abstract_get_size_cdp(self) result(N) Prototype Abstract interface to return the size of the specific abstract vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: self Vector for which to return the size. Return Value integer Size of the vector procedure, public, pass(self) :: norm => norm_cdp Computes the norm of the abstract_vector . private  function norm_cdp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=dp) Norm of the vector. procedure(abstract_rand_cdp), public, deferred, pass(self) :: rand Creates a random abstract_vector_cdp . subroutine abstract_rand_cdp(self, ifnorm) Prototype Abstract interface to generate a random (normalized) vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Vector to be initialized. logical, intent(in), optional :: ifnorm procedure(abstract_scal_cdp), public, deferred, pass(self) :: scal Compute the scalar-vector product. subroutine abstract_scal_cdp(self, alpha) Prototype Abstract interface to scale a vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Vector to be scaled. complex(kind=dp), intent(in) :: alpha Scaling factor. procedure, public, pass(self) :: sub => sub_cdp Subtracts two abstract_vector , i.e. . private  subroutine sub_cdp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_cdp ), intent(in) :: vec Vector to be subtracted. procedure(abstract_zero_cdp), public, deferred, pass(self) :: zero Sets an abstract_vector_cdp to zero. subroutine abstract_zero_cdp(self) Prototype Abstract interface to zero-out a vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Vector to be zeroed-out. Source Code type , abstract , extends ( abstract_vector ), public :: abstract_vector_cdp !!  Abstract type to define complex(dp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_cdp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_cdp` to zero. procedure ( abstract_rand_cdp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_cdp`. procedure ( abstract_scal_cdp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_cdp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_cdp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_cdp`. procedure ( abstract_get_size_cdp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_cdp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_cdp !! Adds two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{x} + \\mathbf{y}. procedure , pass ( self ), public :: sub => sub_cdp !! Subtracts two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{y} - \\mathbf{x} . procedure , pass ( self ), public :: chsgn => chsgn_cdp !! Change the sign of a vector, i.e.  \\mathbf{x} \\leftarrow -\\mathbf{x} . end type abstract_vector_cdp","tags":"","url":"type/abstract_vector_cdp.html"},{"title":"abstract_vector_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_vector ) :: abstract_vector_csp Abstract type to define complex(sp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_csp Adds two abstract_vector , i.e. . private  subroutine add_csp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. class( abstract_vector_csp ), intent(in) :: vec Vector to be added. procedure(abstract_axpby_csp), public, deferred, pass(self) :: axpby In-place computation of . subroutine abstract_axpby_csp(alpha, vec, beta, self) Prototype Abstract interface to add/scale two vectors in-place. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: alpha class( abstract_vector_csp ), intent(in) :: vec Vector to be added/subtracted. complex(kind=sp), intent(in) :: beta class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. procedure, public, pass(self) :: chsgn => chsgn_csp Change the sign of a vector, i.e. . private  subroutine chsgn_csp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Vector whose entries need to change sign. procedure(abstract_dot_csp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_csp . function abstract_dot_csp(self, vec) result(alpha) Prototype Abstract interface to compute the dot product. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: self Vectors whose dot product will be computed. class( abstract_vector_csp ), intent(in) :: vec Vectors whose dot product will be computed. Return Value complex(kind=sp) Result of the dot product. procedure(abstract_get_size_csp), public, deferred, pass(self) :: get_size Return size of specific abstract vector function abstract_get_size_csp(self) result(N) Prototype Abstract interface to return the size of the specific abstract vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: self Vector for which to return the size. Return Value integer Size of the vector procedure, public, pass(self) :: norm => norm_csp Computes the norm of the abstract_vector . private  function norm_csp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=sp) Norm of the vector. procedure(abstract_rand_csp), public, deferred, pass(self) :: rand Creates a random abstract_vector_csp . subroutine abstract_rand_csp(self, ifnorm) Prototype Abstract interface to generate a random (normalized) vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Vector to be initialized. logical, intent(in), optional :: ifnorm procedure(abstract_scal_csp), public, deferred, pass(self) :: scal Compute the scalar-vector product. subroutine abstract_scal_csp(self, alpha) Prototype Abstract interface to scale a vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Vector to be scaled. complex(kind=sp), intent(in) :: alpha Scaling factor. procedure, public, pass(self) :: sub => sub_csp Subtracts two abstract_vector , i.e. . private  subroutine sub_csp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. class( abstract_vector_csp ), intent(in) :: vec Vector to be subtracted. procedure(abstract_zero_csp), public, deferred, pass(self) :: zero Sets an abstract_vector_csp to zero. subroutine abstract_zero_csp(self) Prototype Abstract interface to zero-out a vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Vector to be zeroed-out. Source Code type , abstract , extends ( abstract_vector ), public :: abstract_vector_csp !!  Abstract type to define complex(sp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_csp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_csp` to zero. procedure ( abstract_rand_csp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_csp`. procedure ( abstract_scal_csp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_csp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_csp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_csp`. procedure ( abstract_get_size_csp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_csp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_csp !! Adds two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{x} + \\mathbf{y}. procedure , pass ( self ), public :: sub => sub_csp !! Subtracts two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{y} - \\mathbf{x} . procedure , pass ( self ), public :: chsgn => chsgn_csp !! Change the sign of a vector, i.e.  \\mathbf{x} \\leftarrow -\\mathbf{x} . end type abstract_vector_csp","tags":"","url":"type/abstract_vector_csp.html"},{"title":"abstract_vector_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_vector ) :: abstract_vector_rdp Abstract type to define real(dp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_rdp Adds two abstract_vector , i.e. . private  subroutine add_rdp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rdp ), intent(in) :: vec Vector to be added. procedure(abstract_axpby_rdp), public, deferred, pass(self) :: axpby In-place computation of . subroutine abstract_axpby_rdp(alpha, vec, beta, self) Prototype Abstract interface to add/scale two vectors in-place. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha class( abstract_vector_rdp ), intent(in) :: vec Vector to be added/subtracted. real(kind=dp), intent(in) :: beta class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. procedure, public, pass(self) :: chsgn => chsgn_rdp Change the sign of a vector, i.e. . private  subroutine chsgn_rdp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Vector whose entries need to change sign. procedure(abstract_dot_rdp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_rdp . function abstract_dot_rdp(self, vec) result(alpha) Prototype Abstract interface to compute the dot product. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: self Vectors whose dot product will be computed. class( abstract_vector_rdp ), intent(in) :: vec Vectors whose dot product will be computed. Return Value real(kind=dp) Result of the dot product. procedure(abstract_get_size_rdp), public, deferred, pass(self) :: get_size Return size of specific abstract vector function abstract_get_size_rdp(self) result(N) Prototype Abstract interface to return the size of the specific abstract vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: self Vector for which to return the size. Return Value integer Size of the vector procedure, public, pass(self) :: norm => norm_rdp Computes the norm of the abstract_vector . private  function norm_rdp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=dp) Norm of the vector. procedure(abstract_rand_rdp), public, deferred, pass(self) :: rand Creates a random abstract_vector_rdp . subroutine abstract_rand_rdp(self, ifnorm) Prototype Abstract interface to generate a random (normalized) vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Vector to be initialized. logical, intent(in), optional :: ifnorm procedure(abstract_scal_rdp), public, deferred, pass(self) :: scal Compute the scalar-vector product. subroutine abstract_scal_rdp(self, alpha) Prototype Abstract interface to scale a vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Vector to be scaled. real(kind=dp), intent(in) :: alpha Scaling factor. procedure, public, pass(self) :: sub => sub_rdp Subtracts two abstract_vector , i.e. . private  subroutine sub_rdp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rdp ), intent(in) :: vec Vector to be subtracted. procedure(abstract_zero_rdp), public, deferred, pass(self) :: zero Sets an abstract_vector_rdp to zero. subroutine abstract_zero_rdp(self) Prototype Abstract interface to zero-out a vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Vector to be zeroed-out. Source Code type , abstract , extends ( abstract_vector ), public :: abstract_vector_rdp !!  Abstract type to define real(dp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_rdp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_rdp` to zero. procedure ( abstract_rand_rdp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_rdp`. procedure ( abstract_scal_rdp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_rdp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_rdp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_rdp`. procedure ( abstract_get_size_rdp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_rdp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_rdp !! Adds two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{x} + \\mathbf{y}. procedure , pass ( self ), public :: sub => sub_rdp !! Subtracts two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{y} - \\mathbf{x} . procedure , pass ( self ), public :: chsgn => chsgn_rdp !! Change the sign of a vector, i.e.  \\mathbf{x} \\leftarrow -\\mathbf{x} . end type abstract_vector_rdp","tags":"","url":"type/abstract_vector_rdp.html"},{"title":"abstract_vector_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_vector ) :: abstract_vector_rsp Abstract type to define real(sp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_rsp Adds two abstract_vector , i.e. . private  subroutine add_rsp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rsp ), intent(in) :: vec Vector to be added. procedure(abstract_axpby_rsp), public, deferred, pass(self) :: axpby In-place computation of . subroutine abstract_axpby_rsp(alpha, vec, beta, self) Prototype Abstract interface to add/scale two vectors in-place. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: alpha class( abstract_vector_rsp ), intent(in) :: vec Vector to be added/subtracted. real(kind=sp), intent(in) :: beta class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. procedure, public, pass(self) :: chsgn => chsgn_rsp Change the sign of a vector, i.e. . private  subroutine chsgn_rsp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Vector whose entries need to change sign. procedure(abstract_dot_rsp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_rsp . function abstract_dot_rsp(self, vec) result(alpha) Prototype Abstract interface to compute the dot product. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: self Vectors whose dot product will be computed. class( abstract_vector_rsp ), intent(in) :: vec Vectors whose dot product will be computed. Return Value real(kind=sp) Result of the dot product. procedure(abstract_get_size_rsp), public, deferred, pass(self) :: get_size Return size of specific abstract vector function abstract_get_size_rsp(self) result(N) Prototype Abstract interface to return the size of the specific abstract vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: self Vector for which to return the size. Return Value integer Size of the vector procedure, public, pass(self) :: norm => norm_rsp Computes the norm of the abstract_vector . private  function norm_rsp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=sp) Norm of the vector. procedure(abstract_rand_rsp), public, deferred, pass(self) :: rand Creates a random abstract_vector_rsp . subroutine abstract_rand_rsp(self, ifnorm) Prototype Abstract interface to generate a random (normalized) vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Vector to be initialized. logical, intent(in), optional :: ifnorm procedure(abstract_scal_rsp), public, deferred, pass(self) :: scal Compute the scalar-vector product. subroutine abstract_scal_rsp(self, alpha) Prototype Abstract interface to scale a vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Vector to be scaled. real(kind=sp), intent(in) :: alpha Scaling factor. procedure, public, pass(self) :: sub => sub_rsp Subtracts two abstract_vector , i.e. . private  subroutine sub_rsp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rsp ), intent(in) :: vec Vector to be subtracted. procedure(abstract_zero_rsp), public, deferred, pass(self) :: zero Sets an abstract_vector_rsp to zero. subroutine abstract_zero_rsp(self) Prototype Abstract interface to zero-out a vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Vector to be zeroed-out. Source Code type , abstract , extends ( abstract_vector ), public :: abstract_vector_rsp !!  Abstract type to define real(sp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_rsp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_rsp` to zero. procedure ( abstract_rand_rsp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_rsp`. procedure ( abstract_scal_rsp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_rsp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_rsp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_rsp`. procedure ( abstract_get_size_rsp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_rsp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_rsp !! Adds two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{x} + \\mathbf{y}. procedure , pass ( self ), public :: sub => sub_rsp !! Subtracts two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{y} - \\mathbf{x} . procedure , pass ( self ), public :: chsgn => chsgn_rsp !! Change the sign of a vector, i.e.  \\mathbf{x} \\leftarrow -\\mathbf{x} . end type abstract_vector_rsp","tags":"","url":"type/abstract_vector_rsp.html"},{"title":"dense_vector_cdp – LightKrylov ","text":"type, public, extends( abstract_vector_cdp ) :: dense_vector_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: data (:) integer, public :: n Type-Bound Procedures procedure, public, pass(self) :: add => add_cdp Adds two abstract_vector , i.e. . private  subroutine add_cdp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_cdp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => dense_axpby_cdp In-place computation of . private  subroutine dense_axpby_cdp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: alpha class( abstract_vector_cdp ), intent(in) :: vec complex(kind=dp), intent(in) :: beta class( dense_vector_cdp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_cdp Change the sign of a vector, i.e. . private  subroutine chsgn_cdp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dense_dot_cdp Computes the dot product between two abstract_vector_cdp . private  function dense_dot_cdp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( dense_vector_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec Return Value complex(kind=dp) procedure, public, pass(self) :: get_size => dense_get_size_cdp Return size of specific abstract vector private  function dense_get_size_cdp(self) result(n) Arguments Type Intent Optional Attributes Name class( dense_vector_cdp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_cdp Computes the norm of the abstract_vector . private  function norm_cdp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=dp) Norm of the vector. procedure, public, pass(self) :: rand => dense_rand_cdp Creates a random abstract_vector_cdp . private  subroutine dense_rand_cdp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( dense_vector_cdp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => dense_scal_cdp Compute the scalar-vector product. private  subroutine dense_scal_cdp(self, alpha) Arguments Type Intent Optional Attributes Name class( dense_vector_cdp ), intent(inout) :: self complex(kind=dp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_cdp Subtracts two abstract_vector , i.e. . private  subroutine sub_cdp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_cdp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => dense_zero_cdp Sets an abstract_vector_cdp to zero. private  subroutine dense_zero_cdp(self) Arguments Type Intent Optional Attributes Name class( dense_vector_cdp ), intent(inout) :: self Source Code type , extends ( abstract_vector_cdp ), public :: dense_vector_cdp integer :: n complex ( dp ), allocatable :: data (:) contains private procedure , pass ( self ), public :: zero => dense_zero_cdp !! Sets an `abstract_vector_cdp` to zero. procedure , pass ( self ), public :: rand => dense_rand_cdp !! Creates a random `abstract_vector_cdp`. procedure , pass ( self ), public :: scal => dense_scal_cdp !! Compute the scalar-vector product. procedure , pass ( self ), public :: axpby => dense_axpby_cdp !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure , pass ( self ), public :: dot => dense_dot_cdp !! Computes the dot product between two `abstract_vector_cdp`. procedure , pass ( self ), public :: get_size => dense_get_size_cdp !! Return size of specific abstract vector end type dense_vector_cdp","tags":"","url":"type/dense_vector_cdp.html"},{"title":"dense_vector_csp – LightKrylov ","text":"type, public, extends( abstract_vector_csp ) :: dense_vector_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public, allocatable :: data (:) integer, public :: n Type-Bound Procedures procedure, public, pass(self) :: add => add_csp Adds two abstract_vector , i.e. . private  subroutine add_csp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. class( abstract_vector_csp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => dense_axpby_csp In-place computation of . private  subroutine dense_axpby_csp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: alpha class( abstract_vector_csp ), intent(in) :: vec complex(kind=sp), intent(in) :: beta class( dense_vector_csp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_csp Change the sign of a vector, i.e. . private  subroutine chsgn_csp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dense_dot_csp Computes the dot product between two abstract_vector_csp . private  function dense_dot_csp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( dense_vector_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec Return Value complex(kind=sp) procedure, public, pass(self) :: get_size => dense_get_size_csp Return size of specific abstract vector private  function dense_get_size_csp(self) result(n) Arguments Type Intent Optional Attributes Name class( dense_vector_csp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_csp Computes the norm of the abstract_vector . private  function norm_csp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=sp) Norm of the vector. procedure, public, pass(self) :: rand => dense_rand_csp Creates a random abstract_vector_csp . private  subroutine dense_rand_csp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( dense_vector_csp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => dense_scal_csp Compute the scalar-vector product. private  subroutine dense_scal_csp(self, alpha) Arguments Type Intent Optional Attributes Name class( dense_vector_csp ), intent(inout) :: self complex(kind=sp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_csp Subtracts two abstract_vector , i.e. . private  subroutine sub_csp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. class( abstract_vector_csp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => dense_zero_csp Sets an abstract_vector_csp to zero. private  subroutine dense_zero_csp(self) Arguments Type Intent Optional Attributes Name class( dense_vector_csp ), intent(inout) :: self Source Code type , extends ( abstract_vector_csp ), public :: dense_vector_csp integer :: n complex ( sp ), allocatable :: data (:) contains private procedure , pass ( self ), public :: zero => dense_zero_csp !! Sets an `abstract_vector_csp` to zero. procedure , pass ( self ), public :: rand => dense_rand_csp !! Creates a random `abstract_vector_csp`. procedure , pass ( self ), public :: scal => dense_scal_csp !! Compute the scalar-vector product. procedure , pass ( self ), public :: axpby => dense_axpby_csp !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure , pass ( self ), public :: dot => dense_dot_csp !! Computes the dot product between two `abstract_vector_csp`. procedure , pass ( self ), public :: get_size => dense_get_size_csp !! Return size of specific abstract vector end type dense_vector_csp","tags":"","url":"type/dense_vector_csp.html"},{"title":"dense_vector_rdp – LightKrylov ","text":"type, public, extends( abstract_vector_rdp ) :: dense_vector_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: data (:) integer, public :: n Type-Bound Procedures procedure, public, pass(self) :: add => add_rdp Adds two abstract_vector , i.e. . private  subroutine add_rdp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rdp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => dense_axpby_rdp In-place computation of . private  subroutine dense_axpby_rdp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha class( abstract_vector_rdp ), intent(in) :: vec real(kind=dp), intent(in) :: beta class( dense_vector_rdp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_rdp Change the sign of a vector, i.e. . private  subroutine chsgn_rdp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dense_dot_rdp Computes the dot product between two abstract_vector_rdp . private  function dense_dot_rdp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( dense_vector_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec Return Value real(kind=dp) procedure, public, pass(self) :: get_size => dense_get_size_rdp Return size of specific abstract vector private  function dense_get_size_rdp(self) result(n) Arguments Type Intent Optional Attributes Name class( dense_vector_rdp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_rdp Computes the norm of the abstract_vector . private  function norm_rdp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=dp) Norm of the vector. procedure, public, pass(self) :: rand => dense_rand_rdp Creates a random abstract_vector_rdp . private  subroutine dense_rand_rdp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( dense_vector_rdp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => dense_scal_rdp Compute the scalar-vector product. private  subroutine dense_scal_rdp(self, alpha) Arguments Type Intent Optional Attributes Name class( dense_vector_rdp ), intent(inout) :: self real(kind=dp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_rdp Subtracts two abstract_vector , i.e. . private  subroutine sub_rdp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rdp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => dense_zero_rdp Sets an abstract_vector_rdp to zero. private  subroutine dense_zero_rdp(self) Arguments Type Intent Optional Attributes Name class( dense_vector_rdp ), intent(inout) :: self Source Code type , extends ( abstract_vector_rdp ), public :: dense_vector_rdp integer :: n real ( dp ), allocatable :: data (:) contains private procedure , pass ( self ), public :: zero => dense_zero_rdp !! Sets an `abstract_vector_rdp` to zero. procedure , pass ( self ), public :: rand => dense_rand_rdp !! Creates a random `abstract_vector_rdp`. procedure , pass ( self ), public :: scal => dense_scal_rdp !! Compute the scalar-vector product. procedure , pass ( self ), public :: axpby => dense_axpby_rdp !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure , pass ( self ), public :: dot => dense_dot_rdp !! Computes the dot product between two `abstract_vector_rdp`. procedure , pass ( self ), public :: get_size => dense_get_size_rdp !! Return size of specific abstract vector end type dense_vector_rdp","tags":"","url":"type/dense_vector_rdp.html"},{"title":"dense_vector_rsp – LightKrylov ","text":"type, public, extends( abstract_vector_rsp ) :: dense_vector_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public, allocatable :: data (:) integer, public :: n Type-Bound Procedures procedure, public, pass(self) :: add => add_rsp Adds two abstract_vector , i.e. . private  subroutine add_rsp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rsp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => dense_axpby_rsp In-place computation of . private  subroutine dense_axpby_rsp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: alpha class( abstract_vector_rsp ), intent(in) :: vec real(kind=sp), intent(in) :: beta class( dense_vector_rsp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_rsp Change the sign of a vector, i.e. . private  subroutine chsgn_rsp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dense_dot_rsp Computes the dot product between two abstract_vector_rsp . private  function dense_dot_rsp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( dense_vector_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec Return Value real(kind=sp) procedure, public, pass(self) :: get_size => dense_get_size_rsp Return size of specific abstract vector private  function dense_get_size_rsp(self) result(n) Arguments Type Intent Optional Attributes Name class( dense_vector_rsp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_rsp Computes the norm of the abstract_vector . private  function norm_rsp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=sp) Norm of the vector. procedure, public, pass(self) :: rand => dense_rand_rsp Creates a random abstract_vector_rsp . private  subroutine dense_rand_rsp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( dense_vector_rsp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => dense_scal_rsp Compute the scalar-vector product. private  subroutine dense_scal_rsp(self, alpha) Arguments Type Intent Optional Attributes Name class( dense_vector_rsp ), intent(inout) :: self real(kind=sp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_rsp Subtracts two abstract_vector , i.e. . private  subroutine sub_rsp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rsp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => dense_zero_rsp Sets an abstract_vector_rsp to zero. private  subroutine dense_zero_rsp(self) Arguments Type Intent Optional Attributes Name class( dense_vector_rsp ), intent(inout) :: self Source Code type , extends ( abstract_vector_rsp ), public :: dense_vector_rsp integer :: n real ( sp ), allocatable :: data (:) contains private procedure , pass ( self ), public :: zero => dense_zero_rsp !! Sets an `abstract_vector_rsp` to zero. procedure , pass ( self ), public :: rand => dense_rand_rsp !! Creates a random `abstract_vector_rsp`. procedure , pass ( self ), public :: scal => dense_scal_rsp !! Compute the scalar-vector product. procedure , pass ( self ), public :: axpby => dense_axpby_rsp !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure , pass ( self ), public :: dot => dense_dot_rsp !! Computes the dot product between two `abstract_vector_rsp`. procedure , pass ( self ), public :: get_size => dense_get_size_rsp !! Return size of specific abstract vector end type dense_vector_rsp","tags":"","url":"type/dense_vector_rsp.html"},{"title":"abstract_watch – LightKrylov ","text":"type, public, abstract :: abstract_watch Base type to define a global timer.\nAll watches within LightKrylov and associated tools are derived from this type. Within LightKrylov, the derived type global_lightkrylov_timer is used to manage all\natomic timers associated with both internal routines (private) as well as user-defined\n(public) timers that can be added and removed as necessary. In order to protect the\nprivate timers, they are defined and set only during the initialisation of the derived\ntype via the deferred procedure set_private_timers_and_name if timing is requested\nand cannot be deleted.\nOnce the global watch is initalized, the user can define and subsequently remove\nuser-defined timers at any point that will be managed by the global watch in the same\nway as private timers.\nUpon finalization, the user-defined timers with the associated timing information is\npresented together with that of the private timers. The type-bound procedures of the abstract_watch type allow individual access to each\nmanaged timer individually using the timer name as reference. Type-Bound Procedures procedure, public, pass(self) :: add_group Add new timer group to the watch. private  subroutine add_group(self, name, istart, iend, count) Type-bound to abstract_watch: Add timer group to watch.\nNote: The new group name must be unique. This is a quick hack and should be done better. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in) :: istart integer, intent(in) :: iend integer, intent(out), optional :: count procedure, public, pass(self) :: add_timer Add new timer to the watch. private  subroutine add_timer(self, name, start, count) Type-bound to abstract_watch: Add timer to watch and optionally start it immediately.\nNote: The new timer name must be unique. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: start integer, intent(out), optional :: count procedure, public, pass(self) :: enumerate Print summary of registered timers and their current status. private  subroutine enumerate(self, only_user) Type-bound to abstract_watch: Summarize registered timers and their status. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(in) :: self logical, intent(in), optional :: only_user Summarize only user defined timers? default: .false. procedure, public, pass(self) :: finalize Gather timing information and print it to screen/logfile. private  subroutine finalize(self, write_to_file) Finalize global watch within LightKrylov and print used timers. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self logical, intent(in), optional :: write_to_file Print timer summary to a dedicated timer logfile as well as the general log file? default: .true. procedure, public, pass(self) :: get_called Get the number and names of timer called (locally or globally) private  subroutine get_called(self, n_called, names, only_user, check_global) Type-bound to abstract_watch: Get number and names of called timers Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self Watch integer, intent(out) :: n_called number of claled times character(len=128), intent(out), allocatable :: names (:) names of called timers logical, intent(in), optional :: only_user Check only for user defined timers? Default: .false. logical, intent(in), optional :: check_global Check for global call? Default: .false. procedure, public, pass(self) :: get_data => get_timer_data_by_name private  subroutine get_timer_data_by_name(self, name, restart, etime, etmin, etmax, etimp, lcount, rcount, gcount) Type-bound to abstract_watch: Getter routine to return the data for timer referenced by name.\nNotes: Wrapper of the corresponding routine from lightkrylov_timer.\n       If it is running, the timer is stopped. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: restart real(kind=dp), intent(out), optional :: etime real(kind=dp), intent(out), optional :: etmin real(kind=dp), intent(out), optional :: etmax real(kind=dp), intent(out), optional :: etimp integer, intent(out), optional :: lcount integer, intent(out), optional :: rcount integer, intent(out), optional :: gcount procedure, public, pass(self) :: get_data_save => get_timer_data_save_by_name private  subroutine get_timer_data_save_by_name(self, name, timed, countd) Type-bound to abstract_watch: Getter routine to return the timer data referenced by name.\nNotes: Wrapper of the corresponding routine from lightkrylov_timer.\n       If it is running, the timer is NOT stopped. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=dp), intent(out), allocatable :: timed (:,:) time information integer, intent(out), allocatable :: countd (:) Count information procedure, public, pass(self) :: get_group_id private  function get_group_id(self, name) result(id) Type-bound to abstract_watch: Getter routine to return the group id based on name. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(in) :: self character(len=*), intent(in) :: name Timer name Return Value integer procedure, public, pass(self) :: get_time => get_timer_etime_by_name private  function get_timer_etime_by_name(self, name, restart) result(etime) Type-bound to abstract_watch: Getter routine to return the current etime for timer referenced by name.\nNotes: Wrapper of the corresponding routine from lightkrylov_timer.\n       If it is running, the timer is stopped. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: restart Return Value real(kind=dp) procedure, public, pass(self) :: get_timer_id private  function get_timer_id(self, name) result(id) Type-bound to abstract_watch: Getter routine to return the timer id based on name. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(in) :: self character(len=*), intent(in) :: name Timer name Return Value integer procedure, public, pass(self) :: initialize Set up private timers, flags and counters. Switch on timing. private  subroutine initialize(self) Initialize global watch within LightKrylov and define private system timers. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self procedure, public, pass(self) :: pause => pause_timer_by_name private  subroutine pause_timer_by_name(self, name) Type-bound to abstract_watch: Pause timer referenced by name.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name procedure, public, pass(self) :: print_info => print_timer_info_by_name private  subroutine print_timer_info_by_name(self, name) Type-bound to abstract_watch: Print timing information for timer referenced by name.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name procedure, public, pass(self) :: remove_timer Remove existing timer from the watch. private  subroutine remove_timer(self, name, count) Type-bound to abstract_watch: Remove timer from watch.\nNote: Timers considered private (defined during initialisation) cannot be removed. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(out), optional :: count procedure, public, pass(self) :: reset => reset_timer_by_name private  subroutine reset_timer_by_name(self, name, soft, clean) Type-bound to abstract_watch: Reset timer referenced by name.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: reset_all Reset all timers in watch. private  subroutine reset_all(self, soft, clean) Type-bound to abstract_watch: Utility function to reset all timers at once.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_set_timers), public, deferred, pass(self) :: set_private_timers_and_name Define private timers that cannot be removed by the user. subroutine abstract_set_timers(self) Prototype Interface for defining timers and groups. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self procedure, public, pass(self) :: set_watch_name private  subroutine set_watch_name(self, name) Type-bound to abstract_watch: Set name of watch Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name Watch name procedure, public, pass(self) :: start => start_timer_by_name private  subroutine start_timer_by_name(self, name) Type-bound to abstract_watch: Start timer referenced by name.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name procedure, public, pass(self) :: stop => stop_timer_by_name private  subroutine stop_timer_by_name(self, name) Type-bound to abstract_watch: Stop timer referenced by name.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name Source Code type , abstract , public :: abstract_watch !! Base type to define a global timer. !! All watches within LightKrylov and associated tools are derived from this type. !! !! Within LightKrylov, the derived type `global_lightkrylov_timer` is used to manage all !! atomic timers associated with both internal routines (private) as well as user-defined !! (public) timers that can be added and removed as necessary. In order to protect the !! private timers, they are defined and set only during the initialisation of the derived !! type via the deferred procedure `set_private_timers_and_name` if timing is requested !! and cannot be deleted. !! Once the global watch is initalized, the user can define and subsequently remove !! user-defined timers at any point that will be managed by the global watch in the same !! way as private timers. !! Upon finalization, the user-defined timers with the associated timing information is !! presented together with that of the private timers. !! !! The type-bound procedures of the abstract_watch type allow individual access to each !! managed timer individually using the timer name as reference. private character ( len = 128 ) :: name = 'default_watch' type ( lightkrylov_timer ), dimension (:), allocatable :: timers !! Array of timers contained in the watch. integer :: timer_count = 0 !! Number of timers managed by watch. type ( lightkrylov_timer_group ), dimension (:), allocatable :: groups !! Array of timer groups contained in the watch. integer :: group_count = 0 !! Number of timer groups managed by watch. integer :: private_count = 0 !! Number of private timers (immutable by user). integer :: user_count = 0 !! Number of user defined timers. logical :: user_mode = . false . !! Number of user defined timers. logical :: is_initialized = . false . contains private procedure , pass ( self ), public :: add_timer !! Add new timer to the watch. procedure , pass ( self ), public :: remove_timer !! Remove existing timer from the watch. procedure , pass ( self ), public :: add_group !! Add new timer group to the watch. ! Getter/Setter and helper routines for watch components. procedure , pass ( self ), public :: get_timer_id procedure , pass ( self ), public :: get_group_id procedure , pass ( self ), public :: set_watch_name ! Wrappers for the basic timing routines/access to timer components. procedure , pass ( self ), public :: start => start_timer_by_name procedure , pass ( self ), public :: stop => stop_timer_by_name procedure , pass ( self ), public :: pause => pause_timer_by_name procedure , pass ( self ), public :: reset => reset_timer_by_name procedure , pass ( self ), public :: get_time => get_timer_etime_by_name procedure , pass ( self ), public :: get_data => get_timer_data_by_name procedure , pass ( self ), public :: get_data_save => get_timer_data_save_by_name procedure , pass ( self ), public :: print_info => print_timer_info_by_name ! Global manipulation routines. procedure , pass ( self ), public :: reset_all !! Reset all timers in watch. procedure , pass ( self ), public :: enumerate !! Print summary of registered timers and their current status. procedure , pass ( self ), public :: get_called !! Get the number and names of timer called (locally or globally) procedure , pass ( self ), public :: initialize !! Set up private timers, flags and counters. Switch on timing. procedure , pass ( self ), public :: finalize !! Gather timing information and print it to screen/logfile. procedure ( abstract_set_timers ), pass ( self ), deferred , public :: set_private_timers_and_name !! Define private timers that cannot be removed by the user. end type abstract_watch","tags":"","url":"type/abstract_watch.html"},{"title":"lightkrylov_timer – LightKrylov ","text":"type, public :: lightkrylov_timer Individual timer.\nAtomic timer that is associated to a particular 'event' by name which may be a\nprocedure or a user-defined string at instantiation. The timing information in gathered for each timer independently. The individual\ntimers are gathered into groups (relevant only for timing output) and managed\nby a central watch that is derived from  the abstract_watch type. The\nindividual timers are rarely used independently but all timing actions are\ntypically performed via procedures in the central timer. A notable exception are the matvec / rmatvec as well as reponse timers\nassociated with the types abstract_linop and abstract_system , respectively,\nwhich are managed via their parent types and the corresponding type-bound\nprocedures only. Components Type Visibility Attributes Name Initial character(len=128), public :: name = 'default_timer' Timer name. Type-Bound Procedures procedure, public, pass(self) :: finalize => finalize_timer Aggregate data and prepare summary. private  subroutine finalize_timer(self, if_silent) Type-bound to lightkrylov_timer: Prepare timer summary. Arguments Type Intent Optional Attributes Name class( lightkrylov_timer ), intent(inout) :: self logical, intent(in), optional :: if_silent No output procedure, public, pass(self) :: get_data => get_timer_data Getter routine to access to all local data: etime, counts, etime_max, etime_min, etime_pause. private  subroutine get_timer_data(self, restart, etime, etmin, etmax, etimp, lcount, rcount, gcount) Type-bound to lightkrylov_timer: Getter routine to return the timer data.\nNote: If it is running, the timer is stopped. Arguments Type Intent Optional Attributes Name class( lightkrylov_timer ), intent(inout) :: self logical, intent(in), optional :: restart real(kind=dp), intent(out), optional :: etime real(kind=dp), intent(out), optional :: etmin real(kind=dp), intent(out), optional :: etmax real(kind=dp), intent(out), optional :: etimp integer, intent(out), optional :: lcount integer, intent(out), optional :: rcount integer, intent(out), optional :: gcount procedure, public, pass(self) :: get_data_save => get_timer_data_save Getter routine to access to global data. private  subroutine get_timer_data_save(self, timed, countd) Type-bound to lightkrylov_timer: Getter routine to return the timer data.\nNote: If it is running, the timer is NOT stopped. Arguments Type Intent Optional Attributes Name class( lightkrylov_timer ), intent(inout) :: self real(kind=dp), intent(out), allocatable :: timed (:,:) time information integer, intent(out), allocatable :: countd (:) Count information procedure, public, pass(self) :: get_time => get_timer_etime Getter routine to access self%etime only. private  function get_timer_etime(self, restart) result(etime) Type-bound to lightkrylov_timer: Getter routine to return the current timer etime.\nNote: If it is running, the timer is stopped. Arguments Type Intent Optional Attributes Name class( lightkrylov_timer ), intent(inout) :: self logical, intent(in), optional :: restart Return Value real(kind=dp) procedure, public, pass(self) :: pause => pause_timer private  subroutine pause_timer(self) Type-bound to lightkrylov_timer: Pause timer. Arguments Type Intent Optional Attributes Name class( lightkrylov_timer ), intent(inout) :: self procedure, public, pass(self) :: print_info => print_timer_info Print timing data. private  subroutine print_timer_info(self) Type-bound to lightkrylov_timer: Compute simple statistics and print timing information to screen. Arguments Type Intent Optional Attributes Name class( lightkrylov_timer ), intent(inout) :: self procedure, public, pass(self) :: reset => reset_timer Reset timing data (soft/hard, clear/save data). private  subroutine reset_timer(self, soft, clean, verbose) Type-bound to lightkrylov_timer: Reset timer. Arguments Type Intent Optional Attributes Name class( lightkrylov_timer ), intent(inout) :: self logical, intent(in), optional :: soft Save timing data and reset only if data was collected (i.e. timer was called), default = .true. logical, intent(in), optional :: clean Flush timing data as well as previously saved timing data, default = .false. logical, intent(in), optional :: verbose Always print information about the reset process. procedure, public, pass(self) :: save_timer_data Transfer timing data to arrays. private  subroutine save_timer_data(self) Type-bound to lightkrylov_timer: Save current timing information.\nNote: This is done irrespective of the call/run status of the timer. Arguments Type Intent Optional Attributes Name class( lightkrylov_timer ), intent(inout) :: self procedure, public, pass(self) :: start => start_timer private  subroutine start_timer(self) Type-bound to lightkrylov_timer: Start timer. Arguments Type Intent Optional Attributes Name class( lightkrylov_timer ), intent(inout) :: self procedure, public, pass(self) :: stop => stop_timer private  subroutine stop_timer(self) Type-bound to lightkrylov_timer: Stop timer. Arguments Type Intent Optional Attributes Name class( lightkrylov_timer ), intent(inout) :: self Source Code type , public :: lightkrylov_timer !! Individual timer. !! Atomic timer that is associated to a particular 'event' by name which may be a !! procedure or a user-defined string at instantiation. !! !! The timing information in gathered for each timer independently. The individual !! timers are gathered into groups (relevant only for timing output) and managed !! by a central watch that is derived from  the `abstract_watch` type. The !! individual timers are rarely used independently but all timing actions are !! typically performed via procedures in the central timer. !! !! A notable exception are the `matvec`/`rmatvec` as well as `reponse` timers !! associated with the types `abstract_linop` and `abstract_system`, respectively, !! which are managed via their parent types and the corresponding type-bound !! procedures only. private character ( len = 128 ), public :: name = 'default_timer' !! Timer name. real ( dp ) :: etime = 0.0_dp !! Elapsed time since reset. real ( dp ) :: etime_pause = 0.0_dp !! Elapsed time up until most recent pause. real ( dp ) :: start_time = 0.0_dp !! Start time for comparison. real ( dp ) :: etime_max = 0.0_dp !! Maximum elapsed time since reset. real ( dp ) :: etime_min = huge ( 1.0_dp ) !! Minimum elapsed time since reset. integer :: local_count = 0 !! Call counter since reset. integer :: reset_count = 0 !! Reset counter. integer :: count = 0 !! Global counter (only reset when data is flushed). logical :: running = . false . !! Protection against repeated starts. logical :: is_finalized = . false . !! Switch for printing. real ( dp ), dimension (:), allocatable :: etime_data real ( dp ), dimension (:), allocatable :: etavg_data real ( dp ), dimension (:), allocatable :: etmin_data real ( dp ), dimension (:), allocatable :: etmax_data integer , dimension (:), allocatable :: count_data contains private procedure , pass ( self ), public :: start => start_timer procedure , pass ( self ), public :: stop => stop_timer procedure , pass ( self ), public :: pause => pause_timer procedure , pass ( self ), public :: reset => reset_timer !! Reset timing data (soft/hard, clear/save data). procedure , pass ( self ), public :: finalize => finalize_timer !! Aggregate data and prepare summary. procedure , pass ( self ), public :: get_time => get_timer_etime !! Getter routine to access self%etime only. procedure , pass ( self ), public :: get_data => get_timer_data !! Getter routine to access to all local data: etime, counts, etime_max, etime_min, etime_pause. procedure , pass ( self ), public :: get_data_save => get_timer_data_save !! Getter routine to access to global data. procedure , pass ( self ), public :: print_info => print_timer_info !! Print timing data. procedure , pass ( self ), public :: save_timer_data !! Transfer timing data to arrays. end type lightkrylov_timer","tags":"","url":"type/lightkrylov_timer.html"},{"title":"lightkrylov_timer_group – LightKrylov ","text":"type, public :: lightkrylov_timer_group Simple type to allow for some structure in the timer output. Components Type Visibility Attributes Name Initial character(len=128), public :: name = 'default_group' group name. Source Code type , public :: lightkrylov_timer_group !! Simple type to allow for some structure in the timer output. private character ( len = 128 ), public :: name = 'default_group' !! group name. integer :: istart = 0 !! global index of first timer in group. integer :: iend = 0 !! global index of last timer in group. end type lightkrylov_timer_group","tags":"","url":"type/lightkrylov_timer_group.html"},{"title":"abstract_precond_cdp – LightKrylov ","text":"type, public, abstract :: abstract_precond_cdp Type-Bound Procedures procedure(abstract_apply_cdp), public, deferred, pass(self) :: apply subroutine abstract_apply_cdp(self, vec, iter, current_residual, target_residual) Prototype Abstract interface to apply a preconditioner in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_precond_cdp ), intent(inout) :: self Preconditioner. class( abstract_vector_cdp ), intent(inout) :: vec Input/Output vector. integer, intent(in), optional :: iter Current iteration number. real(kind=dp), intent(in), optional :: current_residual real(kind=dp), intent(in), optional :: target_residual Source Code type , abstract , public :: abstract_precond_cdp contains private procedure ( abstract_apply_cdp ), pass ( self ), public , deferred :: apply end type abstract_precond_cdp","tags":"","url":"type/abstract_precond_cdp.html"},{"title":"abstract_precond_csp – LightKrylov ","text":"type, public, abstract :: abstract_precond_csp Type-Bound Procedures procedure(abstract_apply_csp), public, deferred, pass(self) :: apply subroutine abstract_apply_csp(self, vec, iter, current_residual, target_residual) Prototype Abstract interface to apply a preconditioner in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_precond_csp ), intent(inout) :: self Preconditioner. class( abstract_vector_csp ), intent(inout) :: vec Input/Output vector. integer, intent(in), optional :: iter Current iteration number. real(kind=sp), intent(in), optional :: current_residual real(kind=sp), intent(in), optional :: target_residual Source Code type , abstract , public :: abstract_precond_csp contains private procedure ( abstract_apply_csp ), pass ( self ), public , deferred :: apply end type abstract_precond_csp","tags":"","url":"type/abstract_precond_csp.html"},{"title":"abstract_precond_rdp – LightKrylov ","text":"type, public, abstract :: abstract_precond_rdp Type-Bound Procedures procedure(abstract_apply_rdp), public, deferred, pass(self) :: apply subroutine abstract_apply_rdp(self, vec, iter, current_residual, target_residual) Prototype Abstract interface to apply a preconditioner in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_precond_rdp ), intent(inout) :: self Preconditioner. class( abstract_vector_rdp ), intent(inout) :: vec Input/Output vector. integer, intent(in), optional :: iter Current iteration number. real(kind=dp), intent(in), optional :: current_residual real(kind=dp), intent(in), optional :: target_residual Source Code type , abstract , public :: abstract_precond_rdp contains private procedure ( abstract_apply_rdp ), pass ( self ), public , deferred :: apply end type abstract_precond_rdp","tags":"","url":"type/abstract_precond_rdp.html"},{"title":"abstract_precond_rsp – LightKrylov ","text":"type, public, abstract :: abstract_precond_rsp Type-Bound Procedures procedure(abstract_apply_rsp), public, deferred, pass(self) :: apply subroutine abstract_apply_rsp(self, vec, iter, current_residual, target_residual) Prototype Abstract interface to apply a preconditioner in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_precond_rsp ), intent(inout) :: self Preconditioner. class( abstract_vector_rsp ), intent(inout) :: vec Input/Output vector. integer, intent(in), optional :: iter Current iteration number. real(kind=sp), intent(in), optional :: current_residual real(kind=sp), intent(in), optional :: target_residual Source Code type , abstract , public :: abstract_precond_rsp contains private procedure ( abstract_apply_rsp ), pass ( self ), public , deferred :: apply end type abstract_precond_rsp","tags":"","url":"type/abstract_precond_rsp.html"},{"title":"cg_dp_metadata – LightKrylov ","text":"type, public, extends( abstract_metadata ) :: cg_dp_metadata Conjugate gradient metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag integer, public :: info = 0 Copy of the information flag for completeness integer, public :: n_iter = 0 Iteration counter real(kind=dp), public, dimension(:), allocatable :: res Residual history Type-Bound Procedures procedure, public, pass(self) :: print => print_cg_dp interface private module subroutine print_cg_dp(self, reset_counters, verbose) Arguments Type Intent Optional Attributes Name class( cg_dp_metadata ), intent(inout) :: self logical, intent(in), optional :: reset_counters Reset all counters to zero after printing? logical, intent(in), optional :: verbose Print the residual full residual history? procedure, public, pass(self) :: reset => reset_cg_dp interface private module subroutine reset_cg_dp(self) Arguments Type Intent Optional Attributes Name class( cg_dp_metadata ), intent(inout) :: self Source Code type , extends ( abstract_metadata ), public :: cg_dp_metadata !! Conjugate gradient metadata. integer :: n_iter = 0 !! Iteration counter real ( dp ), dimension (:), allocatable :: res !! Residual history logical :: converged = . false . !! Convergence flag integer :: info = 0 !! Copy of the information flag for completeness contains procedure , pass ( self ), public :: print => print_cg_dp procedure , pass ( self ), public :: reset => reset_cg_dp end type cg_dp_metadata","tags":"","url":"type/cg_dp_metadata.html"},{"title":"cg_dp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: cg_dp_opts Conjugate gradient options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print interation metadata on exit (default = .false.) integer, public :: maxiter = 100 Maximum number of cg iterations (default: 100). Source Code type , extends ( abstract_opts ), public :: cg_dp_opts !! Conjugate gradient options. integer :: maxiter = 100 !! Maximum number of `cg` iterations (default: 100). logical :: if_print_metadata = . false . !! Print interation metadata on exit (default = .false.) end type cg_dp_opts","tags":"","url":"type/cg_dp_opts.html"},{"title":"cg_sp_metadata – LightKrylov ","text":"type, public, extends( abstract_metadata ) :: cg_sp_metadata Conjugate gradient metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag integer, public :: info = 0 Copy of the information flag for completeness integer, public :: n_iter = 0 Iteration counter real(kind=sp), public, dimension(:), allocatable :: res Residual history Type-Bound Procedures procedure, public, pass(self) :: print => print_cg_sp interface private module subroutine print_cg_sp(self, reset_counters, verbose) Arguments Type Intent Optional Attributes Name class( cg_sp_metadata ), intent(inout) :: self logical, intent(in), optional :: reset_counters Reset all counters to zero after printing? logical, intent(in), optional :: verbose Print the residual full residual history? procedure, public, pass(self) :: reset => reset_cg_sp interface private module subroutine reset_cg_sp(self) Arguments Type Intent Optional Attributes Name class( cg_sp_metadata ), intent(inout) :: self Source Code type , extends ( abstract_metadata ), public :: cg_sp_metadata !! Conjugate gradient metadata. integer :: n_iter = 0 !! Iteration counter real ( sp ), dimension (:), allocatable :: res !! Residual history logical :: converged = . false . !! Convergence flag integer :: info = 0 !! Copy of the information flag for completeness contains procedure , pass ( self ), public :: print => print_cg_sp procedure , pass ( self ), public :: reset => reset_cg_sp end type cg_sp_metadata","tags":"","url":"type/cg_sp_metadata.html"},{"title":"cg_sp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: cg_sp_opts Conjugate gradient options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print interation metadata on exit (default = .false.) integer, public :: maxiter = 100 Maximum number of cg iterations (default: 100). Source Code type , extends ( abstract_opts ), public :: cg_sp_opts !! Conjugate gradient options. integer :: maxiter = 100 !! Maximum number of `cg` iterations (default: 100). logical :: if_print_metadata = . false . !! Print interation metadata on exit (default = .false.) end type cg_sp_opts","tags":"","url":"type/cg_sp_opts.html"},{"title":"fgmres_dp_metadata – LightKrylov ","text":"type, public, extends( abstract_metadata ) :: fgmres_dp_metadata FGMRES metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag. integer, public :: info = 0 Copy of the information flag for completeness. integer, public :: n_inner = 0 Number of inner iterations. integer, public :: n_iter = 0 Total iteration counter. integer, public :: n_outer = 0 Number of outer iterations (i.e. restarts) real(kind=dp), public, dimension(:), allocatable :: res Residual history. Type-Bound Procedures procedure, public, pass(self) :: print => print_fgmres_dp interface private module subroutine print_fgmres_dp(self, reset_counters, verbose) Arguments Type Intent Optional Attributes Name class( fgmres_dp_metadata ), intent(inout) :: self logical, intent(in), optional :: reset_counters Reset all counters to zero after printing? logical, intent(in), optional :: verbose Print the full residual history? procedure, public, pass(self) :: reset => reset_fgmres_dp interface private module subroutine reset_fgmres_dp(self) Arguments Type Intent Optional Attributes Name class( fgmres_dp_metadata ), intent(inout) :: self Source Code type , extends ( abstract_metadata ), public :: fgmres_dp_metadata !! FGMRES metadata. integer :: n_iter = 0 !! Total iteration counter. integer :: n_inner = 0 !! Number of inner iterations. integer :: n_outer = 0 !! Number of outer iterations (i.e. restarts) real ( dp ), dimension (:), allocatable :: res !! Residual history. logical :: converged = . false . !! Convergence flag. integer :: info = 0 !! Copy of the information flag for completeness. contains procedure , pass ( self ), public :: print => print_fgmres_dp procedure , pass ( self ), public :: reset => reset_fgmres_dp end type fgmres_dp_metadata","tags":"","url":"type/fgmres_dp_metadata.html"},{"title":"fgmres_dp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: fgmres_dp_opts FGMRES options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print iteration metadata on exit (default: .false.). integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of fgmres restarts (default: 10). logical, public :: sanity_check = .true. Performs extra matrix-vector product for sanity check. Source Code type , extends ( abstract_opts ), public :: fgmres_dp_opts !! FGMRES options. integer :: kdim = 30 !! Dimension of the Krylov subspace (default: 30). integer :: maxiter = 10 !! Maximum number of `fgmres` restarts (default: 10). logical :: if_print_metadata = . false . !! Print iteration metadata on exit (default: .false.). logical :: sanity_check = . true . !! Performs extra matrix-vector product for sanity check. end type fgmres_dp_opts","tags":"","url":"type/fgmres_dp_opts.html"},{"title":"fgmres_sp_metadata – LightKrylov ","text":"type, public, extends( abstract_metadata ) :: fgmres_sp_metadata FGMRES metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag. integer, public :: info = 0 Copy of the information flag for completeness. integer, public :: n_inner = 0 Number of inner iterations. integer, public :: n_iter = 0 Total iteration counter. integer, public :: n_outer = 0 Number of outer iterations (i.e. restarts) real(kind=sp), public, dimension(:), allocatable :: res Residual history. Type-Bound Procedures procedure, public, pass(self) :: print => print_fgmres_sp interface private module subroutine print_fgmres_sp(self, reset_counters, verbose) Arguments Type Intent Optional Attributes Name class( fgmres_sp_metadata ), intent(inout) :: self logical, intent(in), optional :: reset_counters Reset all counters to zero after printing? logical, intent(in), optional :: verbose Print the full residual history? procedure, public, pass(self) :: reset => reset_fgmres_sp interface private module subroutine reset_fgmres_sp(self) Arguments Type Intent Optional Attributes Name class( fgmres_sp_metadata ), intent(inout) :: self Source Code type , extends ( abstract_metadata ), public :: fgmres_sp_metadata !! FGMRES metadata. integer :: n_iter = 0 !! Total iteration counter. integer :: n_inner = 0 !! Number of inner iterations. integer :: n_outer = 0 !! Number of outer iterations (i.e. restarts) real ( sp ), dimension (:), allocatable :: res !! Residual history. logical :: converged = . false . !! Convergence flag. integer :: info = 0 !! Copy of the information flag for completeness. contains procedure , pass ( self ), public :: print => print_fgmres_sp procedure , pass ( self ), public :: reset => reset_fgmres_sp end type fgmres_sp_metadata","tags":"","url":"type/fgmres_sp_metadata.html"},{"title":"fgmres_sp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: fgmres_sp_opts FGMRES options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print iteration metadata on exit (default: .false.). integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of fgmres restarts (default: 10). logical, public :: sanity_check = .true. Performs extra matrix-vector product for sanity check. Source Code type , extends ( abstract_opts ), public :: fgmres_sp_opts !! FGMRES options. integer :: kdim = 30 !! Dimension of the Krylov subspace (default: 30). integer :: maxiter = 10 !! Maximum number of `fgmres` restarts (default: 10). logical :: if_print_metadata = . false . !! Print iteration metadata on exit (default: .false.). logical :: sanity_check = . true . !! Performs extra matrix-vector product for sanity check. end type fgmres_sp_opts","tags":"","url":"type/fgmres_sp_opts.html"},{"title":"gmres_dp_metadata – LightKrylov ","text":"type, public, extends( abstract_metadata ) :: gmres_dp_metadata GMRES metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag. integer, public :: info = 0 Copy of the information flag for completeness. integer, public :: n_inner = 0 Number of inner iterations. integer, public :: n_iter = 0 Total iteration counter. integer, public :: n_outer = 0 Number of outer iterations (i.e. restarts) real(kind=dp), public, dimension(:), allocatable :: res Residual history. Type-Bound Procedures procedure, public, pass(self) :: print => print_gmres_dp interface private module subroutine print_gmres_dp(self, reset_counters, verbose) Arguments Type Intent Optional Attributes Name class( gmres_dp_metadata ), intent(inout) :: self logical, intent(in), optional :: reset_counters Reset all counters to zero after printing? logical, intent(in), optional :: verbose Print the full residual history? procedure, public, pass(self) :: reset => reset_gmres_dp interface private module subroutine reset_gmres_dp(self) Arguments Type Intent Optional Attributes Name class( gmres_dp_metadata ), intent(inout) :: self Source Code type , extends ( abstract_metadata ), public :: gmres_dp_metadata !! GMRES metadata. integer :: n_iter = 0 !! Total iteration counter. integer :: n_inner = 0 !! Number of inner iterations. integer :: n_outer = 0 !! Number of outer iterations (i.e. restarts) real ( dp ), dimension (:), allocatable :: res !! Residual history. logical :: converged = . false . !! Convergence flag. integer :: info = 0 !! Copy of the information flag for completeness. contains procedure , pass ( self ), public :: print => print_gmres_dp procedure , pass ( self ), public :: reset => reset_gmres_dp end type gmres_dp_metadata","tags":"","url":"type/gmres_dp_metadata.html"},{"title":"gmres_dp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: gmres_dp_opts GMRES options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print iteration metadata on exit (default: .false.). integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of gmres restarts (default: 10). logical, public :: sanity_check = .true. Performs extra matrix-vector product for sanity check. Source Code type , extends ( abstract_opts ), public :: gmres_dp_opts !! GMRES options. integer :: kdim = 30 !! Dimension of the Krylov subspace (default: 30). integer :: maxiter = 10 !! Maximum number of `gmres` restarts (default: 10). logical :: if_print_metadata = . false . !! Print iteration metadata on exit (default: .false.). logical :: sanity_check = . true . !! Performs extra matrix-vector product for sanity check. end type gmres_dp_opts","tags":"","url":"type/gmres_dp_opts.html"},{"title":"gmres_sp_metadata – LightKrylov ","text":"type, public, extends( abstract_metadata ) :: gmres_sp_metadata GMRES metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag. integer, public :: info = 0 Copy of the information flag for completeness. integer, public :: n_inner = 0 Number of inner iterations. integer, public :: n_iter = 0 Total iteration counter. integer, public :: n_outer = 0 Number of outer iterations (i.e. restarts) real(kind=sp), public, dimension(:), allocatable :: res Residual history. Type-Bound Procedures procedure, public, pass(self) :: print => print_gmres_sp interface private module subroutine print_gmres_sp(self, reset_counters, verbose) Arguments Type Intent Optional Attributes Name class( gmres_sp_metadata ), intent(inout) :: self logical, intent(in), optional :: reset_counters Reset all counters to zero after printing? logical, intent(in), optional :: verbose Print the full residual history? procedure, public, pass(self) :: reset => reset_gmres_sp interface private module subroutine reset_gmres_sp(self) Arguments Type Intent Optional Attributes Name class( gmres_sp_metadata ), intent(inout) :: self Source Code type , extends ( abstract_metadata ), public :: gmres_sp_metadata !! GMRES metadata. integer :: n_iter = 0 !! Total iteration counter. integer :: n_inner = 0 !! Number of inner iterations. integer :: n_outer = 0 !! Number of outer iterations (i.e. restarts) real ( sp ), dimension (:), allocatable :: res !! Residual history. logical :: converged = . false . !! Convergence flag. integer :: info = 0 !! Copy of the information flag for completeness. contains procedure , pass ( self ), public :: print => print_gmres_sp procedure , pass ( self ), public :: reset => reset_gmres_sp end type gmres_sp_metadata","tags":"","url":"type/gmres_sp_metadata.html"},{"title":"gmres_sp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: gmres_sp_opts GMRES options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print iteration metadata on exit (default: .false.). integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of gmres restarts (default: 10). logical, public :: sanity_check = .true. Performs extra matrix-vector product for sanity check. Source Code type , extends ( abstract_opts ), public :: gmres_sp_opts !! GMRES options. integer :: kdim = 30 !! Dimension of the Krylov subspace (default: 30). integer :: maxiter = 10 !! Maximum number of `gmres` restarts (default: 10). logical :: if_print_metadata = . false . !! Print iteration metadata on exit (default: .false.). logical :: sanity_check = . true . !! Performs extra matrix-vector product for sanity check. end type gmres_sp_opts","tags":"","url":"type/gmres_sp_opts.html"},{"title":"abstract_jacobian_linop_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_cdp ) :: abstract_jacobian_linop_cdp Abstract type for the local linearization of the system around the state X.\nThis type is intended for use within the abstract_system type. Components Type Visibility Attributes Name Initial class( abstract_vector_cdp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop_cdp ), public :: abstract_jacobian_linop_cdp !! Abstract type for the local linearization of the system around the state X. !! This type is intended for use within the abstract_system type. class ( abstract_vector_cdp ), allocatable :: X !! System state around which the equatons are linearized. contains end type abstract_jacobian_linop_cdp","tags":"","url":"type/abstract_jacobian_linop_cdp.html"},{"title":"abstract_jacobian_linop_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_csp ) :: abstract_jacobian_linop_csp Abstract type for the local linearization of the system around the state X.\nThis type is intended for use within the abstract_system type. Components Type Visibility Attributes Name Initial class( abstract_vector_csp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop_csp ), public :: abstract_jacobian_linop_csp !! Abstract type for the local linearization of the system around the state X. !! This type is intended for use within the abstract_system type. class ( abstract_vector_csp ), allocatable :: X !! System state around which the equatons are linearized. contains end type abstract_jacobian_linop_csp","tags":"","url":"type/abstract_jacobian_linop_csp.html"},{"title":"abstract_jacobian_linop_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_rdp ) :: abstract_jacobian_linop_rdp Abstract type for the local linearization of the system around the state X.\nThis type is intended for use within the abstract_system type. Components Type Visibility Attributes Name Initial class( abstract_vector_rdp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop_rdp ), public :: abstract_jacobian_linop_rdp !! Abstract type for the local linearization of the system around the state X. !! This type is intended for use within the abstract_system type. class ( abstract_vector_rdp ), allocatable :: X !! System state around which the equatons are linearized. contains end type abstract_jacobian_linop_rdp","tags":"","url":"type/abstract_jacobian_linop_rdp.html"},{"title":"abstract_jacobian_linop_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_rsp ) :: abstract_jacobian_linop_rsp Abstract type for the local linearization of the system around the state X.\nThis type is intended for use within the abstract_system type. Components Type Visibility Attributes Name Initial class( abstract_vector_rsp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop_rsp ), public :: abstract_jacobian_linop_rsp !! Abstract type for the local linearization of the system around the state X. !! This type is intended for use within the abstract_system type. class ( abstract_vector_rsp ), allocatable :: X !! System state around which the equatons are linearized. contains end type abstract_jacobian_linop_rsp","tags":"","url":"type/abstract_jacobian_linop_rsp.html"},{"title":"abstract_system – LightKrylov ","text":"type, public, abstract :: abstract_system Base type to define an abstract system. All other system types defined\nin LightKrylov derive from this fundamental one. Warning Users should not extend this abstract class to define their own types. Type-Bound Procedures procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history private  subroutine finalize_eval_timer(self) Finalize the system evaluation timer and print summary.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: get_eval_counter Return eval counter value private pure function get_eval_counter(self) result(count) Getter function for the number of system evaluations. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(in) :: self Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self) Print the current timing data for the system evaluation.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: reset_eval_counter Reset eval counter private  subroutine reset_eval_counter(self, procedure, counter, reset_timer, soft_reset, clean_timer) Setter function to reset the system evaluation counter. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timer logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data private  subroutine reset_eval_timer(self, soft, clean) Setter routine to reset the system evaluation timer.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean Source Code type , abstract , public :: abstract_system !!  Base type to define an abstract system. All other system types defined !!  in `LightKrylov` derive from this fundamental one. !! !!  @warning !!  Users should not extend this abstract class to define their own types. !!  @endwarning private integer :: eval_counter = 0 type ( lightkrylov_timer ) :: eval_timer = lightkrylov_timer ( 'system eval timer' ) contains procedure , pass ( self ), public :: get_eval_counter !! Return eval counter value procedure , pass ( self ), public :: reset_eval_counter !! Reset eval counter procedure , pass ( self ), public :: print_timer_info !! Print current timing data procedure , pass ( self ), public :: reset_timer => reset_eval_timer !! Reset current timing data procedure , pass ( self ), public :: finalize_timer => finalize_eval_timer !! Finalize timer and print complete history end type abstract_system","tags":"","url":"type/abstract_system.html"},{"title":"abstract_system_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_system ) :: abstract_system_cdp Base type to extend in order to define a complex(dp)-valued system for\nNewton fixed-point iteration via the Jacobian. Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_cdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_cdp Wrapper for response including the counter increment private  subroutine eval_cdp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( abstract_system_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out real(kind=dp), intent(in) :: atol procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history private  subroutine finalize_eval_timer(self) Finalize the system evaluation timer and print summary.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: get_eval_counter Return eval counter value private pure function get_eval_counter(self) result(count) Getter function for the number of system evaluations. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(in) :: self Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self) Print the current timing data for the system evaluation.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: reset_eval_counter Reset eval counter private  subroutine reset_eval_counter(self, procedure, counter, reset_timer, soft_reset, clean_timer) Setter function to reset the system evaluation counter. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timer logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data private  subroutine reset_eval_timer(self, soft, clean) Setter routine to reset the system evaluation timer.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_eval_cdp), public, deferred, pass(self) :: response Procedure to evaluate the system response . subroutine abstract_eval_cdp(self, vec_in, vec_out, atol) Prototype Interface for the evaluation of the system response. Arguments Type Intent Optional Attributes Name class( abstract_system_cdp ), intent(inout) :: self System class( abstract_vector_cdp ), intent(in) :: vec_in State class( abstract_vector_cdp ), intent(out) :: vec_out Response real(kind=dp), intent(in) :: atol Solver tolerance Source Code type , abstract , extends ( abstract_system ), public :: abstract_system_cdp !! Base type to extend in order to define a complex(dp)-valued system for !! Newton fixed-point iteration via the Jacobian. class ( abstract_jacobian_linop_cdp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_cdp ), pass ( self ), deferred , public :: response !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . ! Wrapper including counter increment procedure , pass ( self ), public :: eval => eval_cdp !! Wrapper for response including the counter increment end type abstract_system_cdp","tags":"","url":"type/abstract_system_cdp.html"},{"title":"abstract_system_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_system ) :: abstract_system_csp Base type to extend in order to define a complex(sp)-valued system for\nNewton fixed-point iteration via the Jacobian. Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_csp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_csp Wrapper for response including the counter increment private  subroutine eval_csp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( abstract_system_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out real(kind=sp), intent(in) :: atol procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history private  subroutine finalize_eval_timer(self) Finalize the system evaluation timer and print summary.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: get_eval_counter Return eval counter value private pure function get_eval_counter(self) result(count) Getter function for the number of system evaluations. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(in) :: self Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self) Print the current timing data for the system evaluation.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: reset_eval_counter Reset eval counter private  subroutine reset_eval_counter(self, procedure, counter, reset_timer, soft_reset, clean_timer) Setter function to reset the system evaluation counter. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timer logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data private  subroutine reset_eval_timer(self, soft, clean) Setter routine to reset the system evaluation timer.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_eval_csp), public, deferred, pass(self) :: response Procedure to evaluate the system response . subroutine abstract_eval_csp(self, vec_in, vec_out, atol) Prototype Interface for the evaluation of the system response. Arguments Type Intent Optional Attributes Name class( abstract_system_csp ), intent(inout) :: self System class( abstract_vector_csp ), intent(in) :: vec_in State class( abstract_vector_csp ), intent(out) :: vec_out Response real(kind=sp), intent(in) :: atol Solver tolerance Source Code type , abstract , extends ( abstract_system ), public :: abstract_system_csp !! Base type to extend in order to define a complex(sp)-valued system for !! Newton fixed-point iteration via the Jacobian. class ( abstract_jacobian_linop_csp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_csp ), pass ( self ), deferred , public :: response !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . ! Wrapper including counter increment procedure , pass ( self ), public :: eval => eval_csp !! Wrapper for response including the counter increment end type abstract_system_csp","tags":"","url":"type/abstract_system_csp.html"},{"title":"abstract_system_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_system ) :: abstract_system_rdp Base type to extend in order to define a real(dp)-valued system for\nNewton fixed-point iteration via the Jacobian. Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_rdp Wrapper for response including the counter increment private  subroutine eval_rdp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( abstract_system_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out real(kind=dp), intent(in) :: atol procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history private  subroutine finalize_eval_timer(self) Finalize the system evaluation timer and print summary.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: get_eval_counter Return eval counter value private pure function get_eval_counter(self) result(count) Getter function for the number of system evaluations. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(in) :: self Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self) Print the current timing data for the system evaluation.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: reset_eval_counter Reset eval counter private  subroutine reset_eval_counter(self, procedure, counter, reset_timer, soft_reset, clean_timer) Setter function to reset the system evaluation counter. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timer logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data private  subroutine reset_eval_timer(self, soft, clean) Setter routine to reset the system evaluation timer.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_eval_rdp), public, deferred, pass(self) :: response Procedure to evaluate the system response . subroutine abstract_eval_rdp(self, vec_in, vec_out, atol) Prototype Interface for the evaluation of the system response. Arguments Type Intent Optional Attributes Name class( abstract_system_rdp ), intent(inout) :: self System class( abstract_vector_rdp ), intent(in) :: vec_in State class( abstract_vector_rdp ), intent(out) :: vec_out Response real(kind=dp), intent(in) :: atol Solver tolerance Source Code type , abstract , extends ( abstract_system ), public :: abstract_system_rdp !! Base type to extend in order to define a real(dp)-valued system for !! Newton fixed-point iteration via the Jacobian. class ( abstract_jacobian_linop_rdp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_rdp ), pass ( self ), deferred , public :: response !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . ! Wrapper including counter increment procedure , pass ( self ), public :: eval => eval_rdp !! Wrapper for response including the counter increment end type abstract_system_rdp","tags":"","url":"type/abstract_system_rdp.html"},{"title":"abstract_system_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_system ) :: abstract_system_rsp Base type to extend in order to define a real(sp)-valued system for\nNewton fixed-point iteration via the Jacobian. Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rsp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_rsp Wrapper for response including the counter increment private  subroutine eval_rsp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( abstract_system_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out real(kind=sp), intent(in) :: atol procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history private  subroutine finalize_eval_timer(self) Finalize the system evaluation timer and print summary.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: get_eval_counter Return eval counter value private pure function get_eval_counter(self) result(count) Getter function for the number of system evaluations. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(in) :: self Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self) Print the current timing data for the system evaluation.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: reset_eval_counter Reset eval counter private  subroutine reset_eval_counter(self, procedure, counter, reset_timer, soft_reset, clean_timer) Setter function to reset the system evaluation counter. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timer logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data private  subroutine reset_eval_timer(self, soft, clean) Setter routine to reset the system evaluation timer.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_eval_rsp), public, deferred, pass(self) :: response Procedure to evaluate the system response . subroutine abstract_eval_rsp(self, vec_in, vec_out, atol) Prototype Interface for the evaluation of the system response. Arguments Type Intent Optional Attributes Name class( abstract_system_rsp ), intent(inout) :: self System class( abstract_vector_rsp ), intent(in) :: vec_in State class( abstract_vector_rsp ), intent(out) :: vec_out Response real(kind=sp), intent(in) :: atol Solver tolerance Source Code type , abstract , extends ( abstract_system ), public :: abstract_system_rsp !! Base type to extend in order to define a real(sp)-valued system for !! Newton fixed-point iteration via the Jacobian. class ( abstract_jacobian_linop_rsp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_rsp ), pass ( self ), deferred , public :: response !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . ! Wrapper including counter increment procedure , pass ( self ), public :: eval => eval_rsp !! Wrapper for response including the counter increment end type abstract_system_rsp","tags":"","url":"type/abstract_system_rsp.html"},{"title":"Id_cdp – LightKrylov ","text":"type, public, extends( abstract_linop_cdp ) :: Id_cdp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => id_matvec_cdp private  subroutine id_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => id_matvec_cdp private  subroutine id_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_cdp ), public :: Id_cdp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_cdp procedure , pass ( self ), public :: rmatvec => id_matvec_cdp end type Id_cdp","tags":"","url":"type/id_cdp.html"},{"title":"Id_csp – LightKrylov ","text":"type, public, extends( abstract_linop_csp ) :: Id_csp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => id_matvec_csp private  subroutine id_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => id_matvec_csp private  subroutine id_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_csp ), public :: Id_csp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_csp procedure , pass ( self ), public :: rmatvec => id_matvec_csp end type Id_csp","tags":"","url":"type/id_csp.html"},{"title":"Id_rdp – LightKrylov ","text":"type, public, extends( abstract_linop_rdp ) :: Id_rdp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => id_matvec_rdp private  subroutine id_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => id_matvec_rdp private  subroutine id_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rdp ), public :: Id_rdp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_rdp procedure , pass ( self ), public :: rmatvec => id_matvec_rdp end type Id_rdp","tags":"","url":"type/id_rdp.html"},{"title":"Id_rsp – LightKrylov ","text":"type, public, extends( abstract_linop_rsp ) :: Id_rsp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => id_matvec_rsp private  subroutine id_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => id_matvec_rsp private  subroutine id_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rsp ), public :: Id_rsp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_rsp procedure , pass ( self ), public :: rmatvec => id_matvec_rsp end type Id_rsp","tags":"","url":"type/id_rsp.html"},{"title":"abstract_exptA_linop_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_cdp ) :: abstract_exptA_linop_cdp Utility type to define the exponential propagator which is the linear map \ncorresponding to the matrix exponential of the (possibly time-dependent) system Jacobian over a time horizon as: Note that explicit knowledge or definition of the Jacobian is not required. This utility function\nis intended for the use in conjuction with a time-stepper algorithm that computes the integral\ndirectly. @note Warning\n     While it is not necessary to use this utility operator, it is strongly recommended for operators\n     that correspond to exponential propagators to extend from this abstract type to allow for more\n     rigorous type checks in the application. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=dp), public :: tau Time horizon for the temporal integration. This variable must be set when the operator is instantiated. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop_cdp ), public :: abstract_exptA_linop_cdp !! Utility type to define the exponential propagator  \\mathbf{\\Phi}_\\tau  which is the linear map !! corresponding to the matrix exponential of the (possibly time-dependent) system Jacobian !!  \\mathbf{L}(t)  over a time horizon  \\tau  as: !! !!  \\mathbf{\\Phi}_\\tau = \\int_0&#94;\\tau \\mathbf{L}(t) \\: \\text{d}t  !! !! Note that explicit knowledge or definition of the Jacobian is not required. This utility function !! is intended for the use in conjuction with a time-stepper algorithm that computes the integral !! directly. !! !!  @warning !!  While it is not necessary to use this utility operator, it is strongly recommended for operators !!  that correspond to exponential propagators to extend from this abstract type to allow for more !!  rigorous type checks in the application. !!  @endwarning real ( dp ), public :: tau !! Time horizon for the temporal integration. This variable must be set when the operator is instantiated. end type abstract_exptA_linop_cdp","tags":"","url":"type/abstract_expta_linop_cdp.html"},{"title":"abstract_exptA_linop_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_csp ) :: abstract_exptA_linop_csp Utility type to define the exponential propagator which is the linear map \ncorresponding to the matrix exponential of the (possibly time-dependent) system Jacobian over a time horizon as: Note that explicit knowledge or definition of the Jacobian is not required. This utility function\nis intended for the use in conjuction with a time-stepper algorithm that computes the integral\ndirectly. @note Warning\n     While it is not necessary to use this utility operator, it is strongly recommended for operators\n     that correspond to exponential propagators to extend from this abstract type to allow for more\n     rigorous type checks in the application. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=sp), public :: tau Time horizon for the temporal integration. This variable must be set when the operator is instantiated. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop_csp ), public :: abstract_exptA_linop_csp !! Utility type to define the exponential propagator  \\mathbf{\\Phi}_\\tau  which is the linear map !! corresponding to the matrix exponential of the (possibly time-dependent) system Jacobian !!  \\mathbf{L}(t)  over a time horizon  \\tau  as: !! !!  \\mathbf{\\Phi}_\\tau = \\int_0&#94;\\tau \\mathbf{L}(t) \\: \\text{d}t  !! !! Note that explicit knowledge or definition of the Jacobian is not required. This utility function !! is intended for the use in conjuction with a time-stepper algorithm that computes the integral !! directly. !! !!  @warning !!  While it is not necessary to use this utility operator, it is strongly recommended for operators !!  that correspond to exponential propagators to extend from this abstract type to allow for more !!  rigorous type checks in the application. !!  @endwarning real ( sp ), public :: tau !! Time horizon for the temporal integration. This variable must be set when the operator is instantiated. end type abstract_exptA_linop_csp","tags":"","url":"type/abstract_expta_linop_csp.html"},{"title":"abstract_exptA_linop_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_rdp ) :: abstract_exptA_linop_rdp Utility type to define the exponential propagator which is the linear map \ncorresponding to the matrix exponential of the (possibly time-dependent) system Jacobian over a time horizon as: Note that explicit knowledge or definition of the Jacobian is not required. This utility function\nis intended for the use in conjuction with a time-stepper algorithm that computes the integral\ndirectly. @note Warning\n     While it is not necessary to use this utility operator, it is strongly recommended for operators\n     that correspond to exponential propagators to extend from this abstract type to allow for more\n     rigorous type checks in the application. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=dp), public :: tau Time horizon for the temporal integration. This variable must be set when the operator is instantiated. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop_rdp ), public :: abstract_exptA_linop_rdp !! Utility type to define the exponential propagator  \\mathbf{\\Phi}_\\tau  which is the linear map !! corresponding to the matrix exponential of the (possibly time-dependent) system Jacobian !!  \\mathbf{L}(t)  over a time horizon  \\tau  as: !! !!  \\mathbf{\\Phi}_\\tau = \\int_0&#94;\\tau \\mathbf{L}(t) \\: \\text{d}t  !! !! Note that explicit knowledge or definition of the Jacobian is not required. This utility function !! is intended for the use in conjuction with a time-stepper algorithm that computes the integral !! directly. !! !!  @warning !!  While it is not necessary to use this utility operator, it is strongly recommended for operators !!  that correspond to exponential propagators to extend from this abstract type to allow for more !!  rigorous type checks in the application. !!  @endwarning real ( dp ), public :: tau !! Time horizon for the temporal integration. This variable must be set when the operator is instantiated. end type abstract_exptA_linop_rdp","tags":"","url":"type/abstract_expta_linop_rdp.html"},{"title":"abstract_exptA_linop_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_rsp ) :: abstract_exptA_linop_rsp Utility type to define the exponential propagator which is the linear map \ncorresponding to the matrix exponential of the (possibly time-dependent) system Jacobian over a time horizon as: Note that explicit knowledge or definition of the Jacobian is not required. This utility function\nis intended for the use in conjuction with a time-stepper algorithm that computes the integral\ndirectly. @note Warning\n     While it is not necessary to use this utility operator, it is strongly recommended for operators\n     that correspond to exponential propagators to extend from this abstract type to allow for more\n     rigorous type checks in the application. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=sp), public :: tau Time horizon for the temporal integration. This variable must be set when the operator is instantiated. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop_rsp ), public :: abstract_exptA_linop_rsp !! Utility type to define the exponential propagator  \\mathbf{\\Phi}_\\tau  which is the linear map !! corresponding to the matrix exponential of the (possibly time-dependent) system Jacobian !!  \\mathbf{L}(t)  over a time horizon  \\tau  as: !! !!  \\mathbf{\\Phi}_\\tau = \\int_0&#94;\\tau \\mathbf{L}(t) \\: \\text{d}t  !! !! Note that explicit knowledge or definition of the Jacobian is not required. This utility function !! is intended for the use in conjuction with a time-stepper algorithm that computes the integral !! directly. !! !!  @warning !!  While it is not necessary to use this utility operator, it is strongly recommended for operators !!  that correspond to exponential propagators to extend from this abstract type to allow for more !!  rigorous type checks in the application. !!  @endwarning real ( sp ), public :: tau !! Time horizon for the temporal integration. This variable must be set when the operator is instantiated. end type abstract_exptA_linop_rsp","tags":"","url":"type/abstract_expta_linop_rsp.html"},{"title":"abstract_hermitian_linop_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_sym_linop ) :: abstract_hermitian_linop_cdp Abstract representation of an abstract hermitian (complex-valued) linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_herm_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_herm_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_herm_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_herm_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(inout) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean Source Code type , abstract , extends ( abstract_sym_linop ), public :: abstract_hermitian_linop_cdp !! Abstract representation of an abstract hermitian (complex-valued) linear operator. contains ! User defined procedures procedure ( abstract_herm_matvec_cdp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_herm_matvec_cdp !! Wrapper for matvec including the counter increment end type abstract_hermitian_linop_cdp","tags":"","url":"type/abstract_hermitian_linop_cdp.html"},{"title":"abstract_hermitian_linop_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_sym_linop ) :: abstract_hermitian_linop_csp Abstract representation of an abstract hermitian (complex-valued) linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_herm_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_herm_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_herm_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_herm_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(inout) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean Source Code type , abstract , extends ( abstract_sym_linop ), public :: abstract_hermitian_linop_csp !! Abstract representation of an abstract hermitian (complex-valued) linear operator. contains ! User defined procedures procedure ( abstract_herm_matvec_csp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_herm_matvec_csp !! Wrapper for matvec including the counter increment end type abstract_hermitian_linop_csp","tags":"","url":"type/abstract_hermitian_linop_csp.html"},{"title":"abstract_linop – LightKrylov ","text":"type, public, abstract :: abstract_linop Base type to define an abstract linear operator. All other operator types defined\nin LightKrylov derive from this fundamental one. Warning Users should not extend this abstract class to define their own types. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean Source Code type , abstract , public :: abstract_linop !!  Base type to define an abstract linear operator. All other operator types defined !!  in `LightKrylov` derive from this fundamental one. !! !!  @warning !!  Users should not extend this abstract class to define their own types. !!  @endwarning integer , private :: matvec_counter = 0 integer , private :: rmatvec_counter = 0 type ( lightkrylov_timer ) :: matvec_timer = lightkrylov_timer ( 'matvec timer' ) type ( lightkrylov_timer ) :: rmatvec_timer = lightkrylov_timer ( 'rmatvec timer' ) contains procedure , pass ( self ), public :: get_counter !! Return matvec/rmatvec counter value procedure , pass ( self ), public :: reset_counter !! Reset matvec/rmatvec counter procedure , pass ( self ), public :: print_timer_info !! Print current timing data procedure , pass ( self ), public :: reset_timer => reset_linop_timer !! Reset current timing data procedure , pass ( self ), public :: finalize_timer => finalize_linop_timer !! Finalize timers and print complete history_info end type abstract_linop","tags":"","url":"type/abstract_linop.html"},{"title":"abstract_linop_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop ) :: abstract_linop_cdp Base type to extend in order to define a complex(dp)-valued linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop ), public :: abstract_linop_cdp !! Base type to extend in order to define a complex(dp)-valued linear operator. contains private ! User defined procedures procedure ( abstract_matvec_cdp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_cdp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_matvec_cdp !! Wrapper for matvec including the counter increment procedure , pass ( self ), public :: apply_rmatvec => apply_rmatvec_cdp !! Wrapper for rmatvec including the counter increment end type abstract_linop_cdp","tags":"","url":"type/abstract_linop_cdp.html"},{"title":"abstract_linop_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop ) :: abstract_linop_csp Base type to extend in order to define a complex(sp)-valued linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop ), public :: abstract_linop_csp !! Base type to extend in order to define a complex(sp)-valued linear operator. contains private ! User defined procedures procedure ( abstract_matvec_csp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_csp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_matvec_csp !! Wrapper for matvec including the counter increment procedure , pass ( self ), public :: apply_rmatvec => apply_rmatvec_csp !! Wrapper for rmatvec including the counter increment end type abstract_linop_csp","tags":"","url":"type/abstract_linop_csp.html"},{"title":"abstract_linop_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop ) :: abstract_linop_rdp Base type to extend in order to define a real(dp)-valued linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop ), public :: abstract_linop_rdp !! Base type to extend in order to define a real(dp)-valued linear operator. contains private ! User defined procedures procedure ( abstract_matvec_rdp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_rdp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_matvec_rdp !! Wrapper for matvec including the counter increment procedure , pass ( self ), public :: apply_rmatvec => apply_rmatvec_rdp !! Wrapper for rmatvec including the counter increment end type abstract_linop_rdp","tags":"","url":"type/abstract_linop_rdp.html"},{"title":"abstract_linop_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop ) :: abstract_linop_rsp Base type to extend in order to define a real(sp)-valued linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product. Source Code type , abstract , extends ( abstract_linop ), public :: abstract_linop_rsp !! Base type to extend in order to define a real(sp)-valued linear operator. contains private ! User defined procedures procedure ( abstract_matvec_rsp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_rsp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_matvec_rsp !! Wrapper for matvec including the counter increment procedure , pass ( self ), public :: apply_rmatvec => apply_rmatvec_rsp !! Wrapper for rmatvec including the counter increment end type abstract_linop_rsp","tags":"","url":"type/abstract_linop_rsp.html"},{"title":"abstract_sym_linop – LightKrylov ","text":"type, public, abstract, extends( abstract_linop ) :: abstract_sym_linop Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean Source Code type , abstract , extends ( abstract_linop ), public :: abstract_sym_linop end type abstract_sym_linop","tags":"","url":"type/abstract_sym_linop.html"},{"title":"abstract_sym_linop_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_sym_linop ) :: abstract_sym_linop_rdp Abstract representation of an abstract symmetric (real valued) linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_sym_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_sym_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_sym_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_sym_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(inout) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean Source Code type , abstract , extends ( abstract_sym_linop ), public :: abstract_sym_linop_rdp !! Abstract representation of an abstract symmetric (real valued) linear operator. contains private ! User defined procedures procedure ( abstract_sym_matvec_rdp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_sym_matvec_rdp !! Wrapper for matvec including the counter increment end type abstract_sym_linop_rdp","tags":"","url":"type/abstract_sym_linop_rdp.html"},{"title":"abstract_sym_linop_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_sym_linop ) :: abstract_sym_linop_rsp Abstract representation of an abstract symmetric (real valued) linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_sym_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_sym_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure(abstract_sym_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_sym_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(inout) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product. procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean Source Code type , abstract , extends ( abstract_sym_linop ), public :: abstract_sym_linop_rsp !! Abstract representation of an abstract symmetric (real valued) linear operator. contains private ! User defined procedures procedure ( abstract_sym_matvec_rsp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_sym_matvec_rsp !! Wrapper for matvec including the counter increment end type abstract_sym_linop_rsp","tags":"","url":"type/abstract_sym_linop_rsp.html"},{"title":"adjoint_linop_cdp – LightKrylov ","text":"type, public, extends( abstract_linop_cdp ) :: adjoint_linop_cdp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec switched. Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => adjoint_matvec_cdp private  subroutine adjoint_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_cdp private  subroutine adjoint_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_cdp ), public :: adjoint_linop_cdp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` switched. class ( abstract_linop_cdp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_cdp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_cdp end type adjoint_linop_cdp","tags":"","url":"type/adjoint_linop_cdp.html"},{"title":"adjoint_linop_csp – LightKrylov ","text":"type, public, extends( abstract_linop_csp ) :: adjoint_linop_csp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec switched. Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => adjoint_matvec_csp private  subroutine adjoint_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_csp private  subroutine adjoint_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_csp ), public :: adjoint_linop_csp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` switched. class ( abstract_linop_csp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_csp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_csp end type adjoint_linop_csp","tags":"","url":"type/adjoint_linop_csp.html"},{"title":"adjoint_linop_rdp – LightKrylov ","text":"type, public, extends( abstract_linop_rdp ) :: adjoint_linop_rdp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec switched. Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => adjoint_matvec_rdp private  subroutine adjoint_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_rdp private  subroutine adjoint_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rdp ), public :: adjoint_linop_rdp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` switched. class ( abstract_linop_rdp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_rdp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_rdp end type adjoint_linop_rdp","tags":"","url":"type/adjoint_linop_rdp.html"},{"title":"adjoint_linop_rsp – LightKrylov ","text":"type, public, extends( abstract_linop_rsp ) :: adjoint_linop_rsp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec switched. Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => adjoint_matvec_rsp private  subroutine adjoint_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_rsp private  subroutine adjoint_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rsp ), public :: adjoint_linop_rsp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` switched. class ( abstract_linop_rsp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_rsp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_rsp end type adjoint_linop_rsp","tags":"","url":"type/adjoint_linop_rsp.html"},{"title":"axpby_linop_cdp – LightKrylov ","text":"type, public, extends( abstract_linop_cdp ) :: axpby_linop_cdp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to define A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_cdp ), public, allocatable :: B Underlying linear operators. complex(kind=dp), public :: alpha Scaling factors. complex(kind=dp), public :: beta Scaling factors. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => axpby_matvec_cdp private  subroutine axpby_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => axpby_rmatvec_cdp private  subroutine axpby_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_cdp ), public :: axpby_linop_cdp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to define `A` and `B`. class ( abstract_linop_cdp ), allocatable :: A , B !! Underlying linear operators. complex ( dp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_cdp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_cdp end type axpby_linop_cdp","tags":"","url":"type/axpby_linop_cdp.html"},{"title":"axpby_linop_csp – LightKrylov ","text":"type, public, extends( abstract_linop_csp ) :: axpby_linop_csp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to define A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_csp ), public, allocatable :: B Underlying linear operators. complex(kind=sp), public :: alpha Scaling factors. complex(kind=sp), public :: beta Scaling factors. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => axpby_matvec_csp private  subroutine axpby_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => axpby_rmatvec_csp private  subroutine axpby_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_csp ), public :: axpby_linop_csp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to define `A` and `B`. class ( abstract_linop_csp ), allocatable :: A , B !! Underlying linear operators. complex ( sp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_csp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_csp end type axpby_linop_csp","tags":"","url":"type/axpby_linop_csp.html"},{"title":"axpby_linop_rdp – LightKrylov ","text":"type, public, extends( abstract_linop_rdp ) :: axpby_linop_rdp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to define A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_rdp ), public, allocatable :: B Underlying linear operators. real(kind=dp), public :: alpha Scaling factors. real(kind=dp), public :: beta Scaling factors. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => axpby_matvec_rdp private  subroutine axpby_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => axpby_rmatvec_rdp private  subroutine axpby_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rdp ), public :: axpby_linop_rdp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to define `A` and `B`. class ( abstract_linop_rdp ), allocatable :: A , B !! Underlying linear operators. real ( dp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_rdp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_rdp end type axpby_linop_rdp","tags":"","url":"type/axpby_linop_rdp.html"},{"title":"axpby_linop_rsp – LightKrylov ","text":"type, public, extends( abstract_linop_rsp ) :: axpby_linop_rsp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to define A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_rsp ), public, allocatable :: B Underlying linear operators. real(kind=sp), public :: alpha Scaling factors. real(kind=sp), public :: beta Scaling factors. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => axpby_matvec_rsp private  subroutine axpby_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => axpby_rmatvec_rsp private  subroutine axpby_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rsp ), public :: axpby_linop_rsp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to define `A` and `B`. class ( abstract_linop_rsp ), allocatable :: A , B !! Underlying linear operators. real ( sp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_rsp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_rsp end type axpby_linop_rsp","tags":"","url":"type/axpby_linop_rsp.html"},{"title":"dense_linop_cdp – LightKrylov ","text":"type, public, extends( abstract_linop_cdp ) :: dense_linop_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: data (:,:) type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => dense_matvec_cdp private  subroutine dense_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( dense_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => dense_rmatvec_cdp private  subroutine dense_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( dense_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_cdp ), public :: dense_linop_cdp complex ( dp ), allocatable :: data (:, :) contains procedure , pass ( self ), public :: matvec => dense_matvec_cdp procedure , pass ( self ), public :: rmatvec => dense_rmatvec_cdp end type dense_linop_cdp","tags":"","url":"type/dense_linop_cdp.html"},{"title":"dense_linop_csp – LightKrylov ","text":"type, public, extends( abstract_linop_csp ) :: dense_linop_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public, allocatable :: data (:,:) type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => dense_matvec_csp private  subroutine dense_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( dense_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => dense_rmatvec_csp private  subroutine dense_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( dense_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_csp ), public :: dense_linop_csp complex ( sp ), allocatable :: data (:, :) contains procedure , pass ( self ), public :: matvec => dense_matvec_csp procedure , pass ( self ), public :: rmatvec => dense_rmatvec_csp end type dense_linop_csp","tags":"","url":"type/dense_linop_csp.html"},{"title":"dense_linop_rdp – LightKrylov ","text":"type, public, extends( abstract_linop_rdp ) :: dense_linop_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: data (:,:) type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => dense_matvec_rdp private  subroutine dense_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( dense_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => dense_rmatvec_rdp private  subroutine dense_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( dense_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rdp ), public :: dense_linop_rdp real ( dp ), allocatable :: data (:, :) contains procedure , pass ( self ), public :: matvec => dense_matvec_rdp procedure , pass ( self ), public :: rmatvec => dense_rmatvec_rdp end type dense_linop_rdp","tags":"","url":"type/dense_linop_rdp.html"},{"title":"dense_linop_rsp – LightKrylov ","text":"type, public, extends( abstract_linop_rsp ) :: dense_linop_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public, allocatable :: data (:,:) type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => dense_matvec_rsp private  subroutine dense_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( dense_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => dense_rmatvec_rsp private  subroutine dense_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( dense_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rsp ), public :: dense_linop_rsp real ( sp ), allocatable :: data (:, :) contains procedure , pass ( self ), public :: matvec => dense_matvec_rsp procedure , pass ( self ), public :: rmatvec => dense_rmatvec_rsp end type dense_linop_rsp","tags":"","url":"type/dense_linop_rsp.html"},{"title":"scaled_linop_cdp – LightKrylov ","text":"type, public, extends( abstract_linop_cdp ) :: scaled_linop_cdp Defines a scaled linear operator with a complex(dp)-valued operator\nand . Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Base linear operator to be scaled. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') complex(kind=dp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => scaled_matvec_cdp private  subroutine scaled_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => scaled_rmatvec_cdp private  subroutine scaled_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_cdp ), public :: scaled_linop_cdp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a complex(dp)-valued operator !! and  \\sigma \\in \\mathbb{R}\\ ) or  \\mathbb{C} . class ( abstract_linop_cdp ), allocatable :: A !! Base linear operator to be scaled. complex ( dp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_cdp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_cdp end type scaled_linop_cdp","tags":"","url":"type/scaled_linop_cdp.html"},{"title":"scaled_linop_csp – LightKrylov ","text":"type, public, extends( abstract_linop_csp ) :: scaled_linop_csp Defines a scaled linear operator with a complex(sp)-valued operator\nand . Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Base linear operator to be scaled. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') complex(kind=sp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => scaled_matvec_csp private  subroutine scaled_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => scaled_rmatvec_csp private  subroutine scaled_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_csp ), public :: scaled_linop_csp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a complex(sp)-valued operator !! and  \\sigma \\in \\mathbb{R}\\ ) or  \\mathbb{C} . class ( abstract_linop_csp ), allocatable :: A !! Base linear operator to be scaled. complex ( sp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_csp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_csp end type scaled_linop_csp","tags":"","url":"type/scaled_linop_csp.html"},{"title":"scaled_linop_rdp – LightKrylov ","text":"type, public, extends( abstract_linop_rdp ) :: scaled_linop_rdp Defines a scaled linear operator with a real-valued operator and . The definitions of matvec and rmatvec are directly inherited from those used to define A and do not have to be defined by the user. Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Base linear operator to be scaled. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=dp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => scaled_matvec_rdp private  subroutine scaled_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => scaled_rmatvec_rdp private  subroutine scaled_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rdp ), public :: scaled_linop_rdp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a real-valued operator and !!  \\sigma \\in \\mathbb{R} . The definitions of `matvec` and `rmatvec` are directly inherited from those used to define !! `A` and do not have to be defined by the user. class ( abstract_linop_rdp ), allocatable :: A !! Base linear operator to be scaled. real ( dp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_rdp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_rdp end type scaled_linop_rdp","tags":"","url":"type/scaled_linop_rdp.html"},{"title":"scaled_linop_rsp – LightKrylov ","text":"type, public, extends( abstract_linop_rsp ) :: scaled_linop_rsp Defines a scaled linear operator with a real-valued operator and . The definitions of matvec and rmatvec are directly inherited from those used to define A and do not have to be defined by the user. Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Base linear operator to be scaled. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=sp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => scaled_matvec_rsp private  subroutine scaled_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => scaled_rmatvec_rsp private  subroutine scaled_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rsp ), public :: scaled_linop_rsp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a real-valued operator and !!  \\sigma \\in \\mathbb{R} . The definitions of `matvec` and `rmatvec` are directly inherited from those used to define !! `A` and do not have to be defined by the user. class ( abstract_linop_rsp ), allocatable :: A !! Base linear operator to be scaled. real ( sp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_rsp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_rsp end type scaled_linop_rsp","tags":"","url":"type/scaled_linop_rsp.html"},{"title":"abstract_metadata – LightKrylov ","text":"type, public, abstract :: abstract_metadata Abstract type for solver metadata from which all others are extended. Type-Bound Procedures procedure(abstract_print_metadata), public, deferred, pass(self) :: print subroutine abstract_print_metadata(self, reset_counters, verbose) Prototype Arguments Type Intent Optional Attributes Name class( abstract_metadata ), intent(inout) :: self logical, intent(in), optional :: reset_counters logical, intent(in), optional :: verbose procedure(abstract_reset_metadata), public, deferred, pass(self) :: reset subroutine abstract_reset_metadata(self) Prototype Arguments Type Intent Optional Attributes Name class( abstract_metadata ), intent(inout) :: self Source Code type , abstract , public :: abstract_metadata !! Abstract type for solver metadata from which all others are extended. private contains procedure ( abstract_print_metadata ), pass ( self ), deferred , public :: print procedure ( abstract_reset_metadata ), pass ( self ), deferred , public :: reset end type abstract_metadata","tags":"","url":"type/abstract_metadata.html"},{"title":"abstract_opts – LightKrylov ","text":"type, public, abstract :: abstract_opts Abstract type for options from which all others are extended. Source Code type , abstract , public :: abstract_opts !! Abstract type for options from which all others are extended. end type abstract_opts","tags":"","url":"type/abstract_opts.html"},{"title":"hermitian_linop_cdp – LightKrylov ","text":"type, public, extends( abstract_hermitian_linop_cdp ) :: hermitian_linop_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public, dimension(test_size, test_size) :: data = zero_cdp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor public        interface hermitian_linop_cdp private module function construct_hermitian_linop_cdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( hermitian_linop_cdp ) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_herm_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_herm_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => hermitian_matvec_cdp private  subroutine hermitian_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( hermitian_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => hermitian_matvec_cdp private  subroutine hermitian_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( hermitian_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out Source Code type , extends ( abstract_hermitian_linop_cdp ), public :: hermitian_linop_cdp complex ( dp ), dimension ( test_size , test_size ) :: data = zero_cdp contains private procedure , pass ( self ), public :: matvec => hermitian_matvec_cdp procedure , pass ( self ), public :: rmatvec => hermitian_matvec_cdp end type hermitian_linop_cdp","tags":"","url":"type/hermitian_linop_cdp.html"},{"title":"hermitian_linop_csp – LightKrylov ","text":"type, public, extends( abstract_hermitian_linop_csp ) :: hermitian_linop_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public, dimension(test_size, test_size) :: data = zero_csp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor public        interface hermitian_linop_csp private module function construct_hermitian_linop_csp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( hermitian_linop_csp ) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_herm_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_herm_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => hermitian_matvec_csp private  subroutine hermitian_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( hermitian_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => hermitian_matvec_csp private  subroutine hermitian_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( hermitian_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out Source Code type , extends ( abstract_hermitian_linop_csp ), public :: hermitian_linop_csp complex ( sp ), dimension ( test_size , test_size ) :: data = zero_csp contains private procedure , pass ( self ), public :: matvec => hermitian_matvec_csp procedure , pass ( self ), public :: rmatvec => hermitian_matvec_csp end type hermitian_linop_csp","tags":"","url":"type/hermitian_linop_csp.html"},{"title":"jacobian_cdp – LightKrylov ","text":"type, public, extends( abstract_jacobian_linop_cdp ) :: jacobian_cdp Components Type Visibility Attributes Name Initial class( abstract_vector_cdp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => lin_roessler_cdp private  subroutine lin_roessler_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( jacobian_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => adj_lin_roessler_cdp private  subroutine adj_lin_roessler_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( jacobian_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out Source Code type , extends ( abstract_jacobian_linop_cdp ), public :: jacobian_cdp contains private procedure , pass ( self ), public :: matvec => lin_roessler_cdp procedure , pass ( self ), public :: rmatvec => adj_lin_roessler_cdp end type jacobian_cdp","tags":"","url":"type/jacobian_cdp.html"},{"title":"jacobian_csp – LightKrylov ","text":"type, public, extends( abstract_jacobian_linop_csp ) :: jacobian_csp Components Type Visibility Attributes Name Initial class( abstract_vector_csp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => lin_roessler_csp private  subroutine lin_roessler_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( jacobian_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => adj_lin_roessler_csp private  subroutine adj_lin_roessler_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( jacobian_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out Source Code type , extends ( abstract_jacobian_linop_csp ), public :: jacobian_csp contains private procedure , pass ( self ), public :: matvec => lin_roessler_csp procedure , pass ( self ), public :: rmatvec => adj_lin_roessler_csp end type jacobian_csp","tags":"","url":"type/jacobian_csp.html"},{"title":"jacobian_rdp – LightKrylov ","text":"type, public, extends( abstract_jacobian_linop_rdp ) :: jacobian_rdp Components Type Visibility Attributes Name Initial class( abstract_vector_rdp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => lin_roessler_rdp private  subroutine lin_roessler_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( jacobian_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => adj_lin_roessler_rdp private  subroutine adj_lin_roessler_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( jacobian_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out Source Code type , extends ( abstract_jacobian_linop_rdp ), public :: jacobian_rdp contains private procedure , pass ( self ), public :: matvec => lin_roessler_rdp procedure , pass ( self ), public :: rmatvec => adj_lin_roessler_rdp end type jacobian_rdp","tags":"","url":"type/jacobian_rdp.html"},{"title":"jacobian_rsp – LightKrylov ","text":"type, public, extends( abstract_jacobian_linop_rsp ) :: jacobian_rsp Components Type Visibility Attributes Name Initial class( abstract_vector_rsp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => lin_roessler_rsp private  subroutine lin_roessler_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( jacobian_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => adj_lin_roessler_rsp private  subroutine adj_lin_roessler_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( jacobian_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out Source Code type , extends ( abstract_jacobian_linop_rsp ), public :: jacobian_rsp contains private procedure , pass ( self ), public :: matvec => lin_roessler_rsp procedure , pass ( self ), public :: rmatvec => adj_lin_roessler_rsp end type jacobian_rsp","tags":"","url":"type/jacobian_rsp.html"},{"title":"linop_cdp – LightKrylov ","text":"type, public, extends( abstract_linop_cdp ) :: linop_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public, dimension(test_size, test_size) :: data = zero_cdp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor public        interface linop_cdp private module function construct_linop_cdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_cdp ) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => matvec_cdp private  subroutine matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => rmatvec_cdp private  subroutine rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( linop_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_cdp ), public :: linop_cdp complex ( dp ), dimension ( test_size , test_size ) :: data = zero_cdp contains private procedure , pass ( self ), public :: matvec => matvec_cdp procedure , pass ( self ), public :: rmatvec => rmatvec_cdp end type linop_cdp","tags":"","url":"type/linop_cdp.html"},{"title":"linop_csp – LightKrylov ","text":"type, public, extends( abstract_linop_csp ) :: linop_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public, dimension(test_size, test_size) :: data = zero_csp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor public        interface linop_csp private module function construct_linop_csp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_csp ) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment private  subroutine apply_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => matvec_csp private  subroutine matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => rmatvec_csp private  subroutine rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( linop_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_csp ), public :: linop_csp complex ( sp ), dimension ( test_size , test_size ) :: data = zero_csp contains private procedure , pass ( self ), public :: matvec => matvec_csp procedure , pass ( self ), public :: rmatvec => rmatvec_csp end type linop_csp","tags":"","url":"type/linop_csp.html"},{"title":"linop_rdp – LightKrylov ","text":"type, public, extends( abstract_linop_rdp ) :: linop_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(test_size, test_size) :: data = 0.0_dp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor public        interface linop_rdp private module function construct_linop_rdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_rdp ) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => matvec_rdp private  subroutine matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => rmatvec_rdp private  subroutine rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rdp ), public :: linop_rdp real ( dp ), dimension ( test_size , test_size ) :: data = 0.0_dp contains private procedure , pass ( self ), public :: matvec => matvec_rdp procedure , pass ( self ), public :: rmatvec => rmatvec_rdp end type linop_rdp","tags":"","url":"type/linop_rdp.html"},{"title":"linop_rsp – LightKrylov ","text":"type, public, extends( abstract_linop_rsp ) :: linop_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public, dimension(test_size, test_size) :: data = 0.0_sp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor public        interface linop_rsp private module function construct_linop_rsp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_rsp ) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment private  subroutine apply_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => matvec_rsp private  subroutine matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => rmatvec_rsp private  subroutine rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out Source Code type , extends ( abstract_linop_rsp ), public :: linop_rsp real ( sp ), dimension ( test_size , test_size ) :: data = 0.0_sp contains private procedure , pass ( self ), public :: matvec => matvec_rsp procedure , pass ( self ), public :: rmatvec => rmatvec_rsp end type linop_rsp","tags":"","url":"type/linop_rsp.html"},{"title":"roessler_cdp – LightKrylov ","text":"type, public, extends( abstract_system_cdp ) :: roessler_cdp Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_cdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_cdp Wrapper for response including the counter increment private  subroutine eval_cdp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( abstract_system_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out real(kind=dp), intent(in) :: atol procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history private  subroutine finalize_eval_timer(self) Finalize the system evaluation timer and print summary.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: get_eval_counter Return eval counter value private pure function get_eval_counter(self) result(count) Getter function for the number of system evaluations. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(in) :: self Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self) Print the current timing data for the system evaluation.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: reset_eval_counter Reset eval counter private  subroutine reset_eval_counter(self, procedure, counter, reset_timer, soft_reset, clean_timer) Setter function to reset the system evaluation counter. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timer logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data private  subroutine reset_eval_timer(self, soft, clean) Setter routine to reset the system evaluation timer.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: response => eval_roessler_cdp private  subroutine eval_roessler_cdp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( roessler_cdp ), intent(inout) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out real(kind=dp), intent(in) :: atol Source Code type , extends ( abstract_system_cdp ), public :: roessler_cdp contains private procedure , pass ( self ), public :: response => eval_roessler_cdp end type roessler_cdp","tags":"","url":"type/roessler_cdp.html"},{"title":"roessler_csp – LightKrylov ","text":"type, public, extends( abstract_system_csp ) :: roessler_csp Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_csp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_csp Wrapper for response including the counter increment private  subroutine eval_csp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( abstract_system_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out real(kind=sp), intent(in) :: atol procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history private  subroutine finalize_eval_timer(self) Finalize the system evaluation timer and print summary.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: get_eval_counter Return eval counter value private pure function get_eval_counter(self) result(count) Getter function for the number of system evaluations. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(in) :: self Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self) Print the current timing data for the system evaluation.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: reset_eval_counter Reset eval counter private  subroutine reset_eval_counter(self, procedure, counter, reset_timer, soft_reset, clean_timer) Setter function to reset the system evaluation counter. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timer logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data private  subroutine reset_eval_timer(self, soft, clean) Setter routine to reset the system evaluation timer.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: response => eval_roessler_csp private  subroutine eval_roessler_csp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( roessler_csp ), intent(inout) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out real(kind=sp), intent(in) :: atol Source Code type , extends ( abstract_system_csp ), public :: roessler_csp contains private procedure , pass ( self ), public :: response => eval_roessler_csp end type roessler_csp","tags":"","url":"type/roessler_csp.html"},{"title":"roessler_rdp – LightKrylov ","text":"type, public, extends( abstract_system_rdp ) :: roessler_rdp Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_rdp Wrapper for response including the counter increment private  subroutine eval_rdp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( abstract_system_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out real(kind=dp), intent(in) :: atol procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history private  subroutine finalize_eval_timer(self) Finalize the system evaluation timer and print summary.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: get_eval_counter Return eval counter value private pure function get_eval_counter(self) result(count) Getter function for the number of system evaluations. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(in) :: self Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self) Print the current timing data for the system evaluation.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: reset_eval_counter Reset eval counter private  subroutine reset_eval_counter(self, procedure, counter, reset_timer, soft_reset, clean_timer) Setter function to reset the system evaluation counter. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timer logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data private  subroutine reset_eval_timer(self, soft, clean) Setter routine to reset the system evaluation timer.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: response => eval_roessler_rdp private  subroutine eval_roessler_rdp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( roessler_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out real(kind=dp), intent(in) :: atol Source Code type , extends ( abstract_system_rdp ), public :: roessler_rdp contains private procedure , pass ( self ), public :: response => eval_roessler_rdp end type roessler_rdp","tags":"","url":"type/roessler_rdp.html"},{"title":"roessler_rsp – LightKrylov ","text":"type, public, extends( abstract_system_rsp ) :: roessler_rsp Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rsp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_rsp Wrapper for response including the counter increment private  subroutine eval_rsp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( abstract_system_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out real(kind=sp), intent(in) :: atol procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history private  subroutine finalize_eval_timer(self) Finalize the system evaluation timer and print summary.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: get_eval_counter Return eval counter value private pure function get_eval_counter(self) result(count) Getter function for the number of system evaluations. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(in) :: self Return Value integer procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self) Print the current timing data for the system evaluation.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self procedure, public, pass(self) :: reset_eval_counter Reset eval counter private  subroutine reset_eval_counter(self, procedure, counter, reset_timer, soft_reset, clean_timer) Setter function to reset the system evaluation counter. Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timer logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data private  subroutine reset_eval_timer(self, soft, clean) Setter routine to reset the system evaluation timer.\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_system ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: response => eval_roessler_rsp private  subroutine eval_roessler_rsp(self, vec_in, vec_out, atol) Arguments Type Intent Optional Attributes Name class( roessler_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out real(kind=sp), intent(in) :: atol Source Code type , extends ( abstract_system_rsp ), public :: roessler_rsp contains private procedure , pass ( self ), public :: response => eval_roessler_rsp end type roessler_rsp","tags":"","url":"type/roessler_rsp.html"},{"title":"spd_linop_rdp – LightKrylov ","text":"type, public, extends( abstract_sym_linop_rdp ) :: spd_linop_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(test_size, test_size) :: data = 0.0_dp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor public        interface spd_linop_rdp private module function construct_spd_linop_rdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( spd_linop_rdp ) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_sym_matvec_rdp Wrapper for matvec including the counter increment private  subroutine apply_sym_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => sdp_matvec_rdp private  subroutine sdp_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( spd_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => sdp_matvec_rdp private  subroutine sdp_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( spd_linop_rdp ), intent(inout) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out Source Code type , extends ( abstract_sym_linop_rdp ), public :: spd_linop_rdp real ( dp ), dimension ( test_size , test_size ) :: data = 0.0_dp contains private procedure , pass ( self ), public :: matvec => sdp_matvec_rdp procedure , pass ( self ), public :: rmatvec => sdp_matvec_rdp end type spd_linop_rdp","tags":"","url":"type/spd_linop_rdp.html"},{"title":"spd_linop_rsp – LightKrylov ","text":"type, public, extends( abstract_sym_linop_rsp ) :: spd_linop_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public, dimension(test_size, test_size) :: data = 0.0_sp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor public        interface spd_linop_rsp private module function construct_spd_linop_rsp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( spd_linop_rsp ) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_sym_matvec_rsp Wrapper for matvec including the counter increment private  subroutine apply_sym_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info private  subroutine finalize_linop_timer(self) Finalize the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value private pure function get_counter(self, trans) result(count) Getter function for the number of matvec calls Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(in) :: self logical, intent(in) :: trans matvec or rmatvec? Return Value integer procedure, public, pass(self) :: matvec => sdp_matvec_rsp private  subroutine sdp_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( spd_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: print_timer_info Print current timing data private  subroutine print_timer_info(self, trans) Getter routine to print the current timing information for matvec/rmatvec\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter private  subroutine reset_counter(self, trans, procedure, counter, reset_timer, soft_reset, clean_timer) Setter routine to reset the matvec counter and reset timers Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in) :: trans matvec or rmatvec? character(len=*), intent(in) :: procedure name of the caller routine integer, intent(in), optional :: counter optional flag to reset to an integer other than zero. logical, intent(in), optional :: reset_timer optional flag to reset also the timers logical, intent(in), optional :: soft_reset optional flag to choose whether to save previous timing data (default: .true.) logical, intent(in), optional :: clean_timer optional flag to choose whether to fully reset the timer (default: .false.) procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data private  subroutine reset_linop_timer(self, trans, soft, clean) Setter routine to reset the matvec/rmatvec timers\nNote: Wrapper of the corresponding routine from lightkrylov_timer Arguments Type Intent Optional Attributes Name class( abstract_linop ), intent(inout) :: self logical, intent(in), optional :: trans matvec or rmatvec? logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: rmatvec => sdp_matvec_rsp private  subroutine sdp_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( spd_linop_rsp ), intent(inout) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out Source Code type , extends ( abstract_sym_linop_rsp ), public :: spd_linop_rsp real ( sp ), dimension ( test_size , test_size ) :: data = 0.0_sp contains private procedure , pass ( self ), public :: matvec => sdp_matvec_rsp procedure , pass ( self ), public :: rmatvec => sdp_matvec_rsp end type spd_linop_rsp","tags":"","url":"type/spd_linop_rsp.html"},{"title":"state_vector_cdp – LightKrylov ","text":"type, public, extends( abstract_vector_cdp ) :: state_vector_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public :: x = cmplx(0.0_dp, 0.0_dp, kind=dp) complex(kind=dp), public :: y = cmplx(0.0_dp, 0.0_dp, kind=dp) complex(kind=dp), public :: z = cmplx(0.0_dp, 0.0_dp, kind=dp) Type-Bound Procedures procedure, public, pass(self) :: add => add_cdp Adds two abstract_vector , i.e. . private  subroutine add_cdp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_cdp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => axpby_state_cdp private  subroutine axpby_state_cdp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: alpha class( abstract_vector_cdp ), intent(in) :: vec complex(kind=dp), intent(in) :: beta class( state_vector_cdp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_cdp Change the sign of a vector, i.e. . private  subroutine chsgn_cdp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dot_state_cdp private  function dot_state_cdp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( state_vector_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec Return Value complex(kind=dp) procedure, public, pass(self) :: get_size => get_size_state_cdp private  function get_size_state_cdp(self) result(N) Arguments Type Intent Optional Attributes Name class( state_vector_cdp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_cdp Computes the norm of the abstract_vector . private  function norm_cdp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=dp) Norm of the vector. procedure, public, pass(self) :: rand => rand_state_cdp private  subroutine rand_state_cdp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( state_vector_cdp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => scal_state_cdp private  subroutine scal_state_cdp(self, alpha) Arguments Type Intent Optional Attributes Name class( state_vector_cdp ), intent(inout) :: self complex(kind=dp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_cdp Subtracts two abstract_vector , i.e. . private  subroutine sub_cdp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_cdp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => zero_state_cdp private  subroutine zero_state_cdp(self) Arguments Type Intent Optional Attributes Name class( state_vector_cdp ), intent(inout) :: self Source Code type , extends ( abstract_vector_cdp ), public :: state_vector_cdp complex ( dp ) :: x = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) complex ( dp ) :: y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) complex ( dp ) :: z = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) contains private procedure , pass ( self ), public :: zero => zero_state_cdp procedure , pass ( self ), public :: dot => dot_state_cdp procedure , pass ( self ), public :: scal => scal_state_cdp procedure , pass ( self ), public :: axpby => axpby_state_cdp procedure , pass ( self ), public :: rand => rand_state_cdp procedure , pass ( self ), public :: get_size => get_size_state_cdp end type state_vector_cdp","tags":"","url":"type/state_vector_cdp.html"},{"title":"state_vector_csp – LightKrylov ","text":"type, public, extends( abstract_vector_csp ) :: state_vector_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public :: x = cmplx(0.0_sp, 0.0_sp, kind=sp) complex(kind=sp), public :: y = cmplx(0.0_sp, 0.0_sp, kind=sp) complex(kind=sp), public :: z = cmplx(0.0_sp, 0.0_sp, kind=sp) Type-Bound Procedures procedure, public, pass(self) :: add => add_csp Adds two abstract_vector , i.e. . private  subroutine add_csp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. class( abstract_vector_csp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => axpby_state_csp private  subroutine axpby_state_csp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: alpha class( abstract_vector_csp ), intent(in) :: vec complex(kind=sp), intent(in) :: beta class( state_vector_csp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_csp Change the sign of a vector, i.e. . private  subroutine chsgn_csp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dot_state_csp private  function dot_state_csp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( state_vector_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec Return Value complex(kind=sp) procedure, public, pass(self) :: get_size => get_size_state_csp private  function get_size_state_csp(self) result(N) Arguments Type Intent Optional Attributes Name class( state_vector_csp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_csp Computes the norm of the abstract_vector . private  function norm_csp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=sp) Norm of the vector. procedure, public, pass(self) :: rand => rand_state_csp private  subroutine rand_state_csp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( state_vector_csp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => scal_state_csp private  subroutine scal_state_csp(self, alpha) Arguments Type Intent Optional Attributes Name class( state_vector_csp ), intent(inout) :: self complex(kind=sp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_csp Subtracts two abstract_vector , i.e. . private  subroutine sub_csp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. class( abstract_vector_csp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => zero_state_csp private  subroutine zero_state_csp(self) Arguments Type Intent Optional Attributes Name class( state_vector_csp ), intent(inout) :: self Source Code type , extends ( abstract_vector_csp ), public :: state_vector_csp complex ( sp ) :: x = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) complex ( sp ) :: y = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) complex ( sp ) :: z = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) contains private procedure , pass ( self ), public :: zero => zero_state_csp procedure , pass ( self ), public :: dot => dot_state_csp procedure , pass ( self ), public :: scal => scal_state_csp procedure , pass ( self ), public :: axpby => axpby_state_csp procedure , pass ( self ), public :: rand => rand_state_csp procedure , pass ( self ), public :: get_size => get_size_state_csp end type state_vector_csp","tags":"","url":"type/state_vector_csp.html"},{"title":"state_vector_rdp – LightKrylov ","text":"type, public, extends( abstract_vector_rdp ) :: state_vector_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public :: x = 0.0_dp real(kind=dp), public :: y = 0.0_dp real(kind=dp), public :: z = 0.0_dp Type-Bound Procedures procedure, public, pass(self) :: add => add_rdp Adds two abstract_vector , i.e. . private  subroutine add_rdp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rdp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => axpby_state_rdp private  subroutine axpby_state_rdp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha class( abstract_vector_rdp ), intent(in) :: vec real(kind=dp), intent(in) :: beta class( state_vector_rdp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_rdp Change the sign of a vector, i.e. . private  subroutine chsgn_rdp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dot_state_rdp private  function dot_state_rdp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( state_vector_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec Return Value real(kind=dp) procedure, public, pass(self) :: get_size => get_size_state_rdp private  function get_size_state_rdp(self) result(N) Arguments Type Intent Optional Attributes Name class( state_vector_rdp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_rdp Computes the norm of the abstract_vector . private  function norm_rdp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=dp) Norm of the vector. procedure, public, pass(self) :: rand => rand_state_rdp private  subroutine rand_state_rdp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( state_vector_rdp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => scal_state_rdp private  subroutine scal_state_rdp(self, alpha) Arguments Type Intent Optional Attributes Name class( state_vector_rdp ), intent(inout) :: self real(kind=dp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_rdp Subtracts two abstract_vector , i.e. . private  subroutine sub_rdp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rdp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => zero_state_rdp private  subroutine zero_state_rdp(self) Arguments Type Intent Optional Attributes Name class( state_vector_rdp ), intent(inout) :: self Source Code type , extends ( abstract_vector_rdp ), public :: state_vector_rdp real ( dp ) :: x = 0.0_dp real ( dp ) :: y = 0.0_dp real ( dp ) :: z = 0.0_dp contains private procedure , pass ( self ), public :: zero => zero_state_rdp procedure , pass ( self ), public :: dot => dot_state_rdp procedure , pass ( self ), public :: scal => scal_state_rdp procedure , pass ( self ), public :: axpby => axpby_state_rdp procedure , pass ( self ), public :: rand => rand_state_rdp procedure , pass ( self ), public :: get_size => get_size_state_rdp end type state_vector_rdp","tags":"","url":"type/state_vector_rdp.html"},{"title":"state_vector_rsp – LightKrylov ","text":"type, public, extends( abstract_vector_rsp ) :: state_vector_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public :: x = 0.0_sp real(kind=sp), public :: y = 0.0_sp real(kind=sp), public :: z = 0.0_sp Type-Bound Procedures procedure, public, pass(self) :: add => add_rsp Adds two abstract_vector , i.e. . private  subroutine add_rsp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rsp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => axpby_state_rsp private  subroutine axpby_state_rsp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: alpha class( abstract_vector_rsp ), intent(in) :: vec real(kind=sp), intent(in) :: beta class( state_vector_rsp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_rsp Change the sign of a vector, i.e. . private  subroutine chsgn_rsp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dot_state_rsp private  function dot_state_rsp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( state_vector_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec Return Value real(kind=sp) procedure, public, pass(self) :: get_size => get_size_state_rsp private  function get_size_state_rsp(self) result(N) Arguments Type Intent Optional Attributes Name class( state_vector_rsp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_rsp Computes the norm of the abstract_vector . private  function norm_rsp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=sp) Norm of the vector. procedure, public, pass(self) :: rand => rand_state_rsp private  subroutine rand_state_rsp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( state_vector_rsp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => scal_state_rsp private  subroutine scal_state_rsp(self, alpha) Arguments Type Intent Optional Attributes Name class( state_vector_rsp ), intent(inout) :: self real(kind=sp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_rsp Subtracts two abstract_vector , i.e. . private  subroutine sub_rsp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rsp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => zero_state_rsp private  subroutine zero_state_rsp(self) Arguments Type Intent Optional Attributes Name class( state_vector_rsp ), intent(inout) :: self Source Code type , extends ( abstract_vector_rsp ), public :: state_vector_rsp real ( sp ) :: x = 0.0_sp real ( sp ) :: y = 0.0_sp real ( sp ) :: z = 0.0_sp contains private procedure , pass ( self ), public :: zero => zero_state_rsp procedure , pass ( self ), public :: dot => dot_state_rsp procedure , pass ( self ), public :: scal => scal_state_rsp procedure , pass ( self ), public :: axpby => axpby_state_rsp procedure , pass ( self ), public :: rand => rand_state_rsp procedure , pass ( self ), public :: get_size => get_size_state_rsp end type state_vector_rsp","tags":"","url":"type/state_vector_rsp.html"},{"title":"vector_cdp – LightKrylov ","text":"type, public, extends( abstract_vector_cdp ) :: vector_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public, dimension(test_size) :: data = 0.0_dp Type-Bound Procedures procedure, public, pass(self) :: add => add_cdp Adds two abstract_vector , i.e. . private  subroutine add_cdp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_cdp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => axpby_cdp private  subroutine axpby_cdp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: alpha class( abstract_vector_cdp ), intent(in) :: vec complex(kind=dp), intent(in) :: beta class( vector_cdp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_cdp Change the sign of a vector, i.e. . private  subroutine chsgn_cdp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dot_cdp private  function dot_cdp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( vector_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec Return Value complex(kind=dp) procedure, public, pass(self) :: get_size => get_size_cdp private  function get_size_cdp(self) result(N) Arguments Type Intent Optional Attributes Name class( vector_cdp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_cdp Computes the norm of the abstract_vector . private  function norm_cdp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=dp) Norm of the vector. procedure, public, pass(self) :: rand => rand_cdp private  subroutine rand_cdp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( vector_cdp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => scal_cdp private  subroutine scal_cdp(self, alpha) Arguments Type Intent Optional Attributes Name class( vector_cdp ), intent(inout) :: self complex(kind=dp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_cdp Subtracts two abstract_vector , i.e. . private  subroutine sub_cdp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_cdp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => init_zero_cdp private  subroutine init_zero_cdp(self) Arguments Type Intent Optional Attributes Name class( vector_cdp ), intent(inout) :: self Source Code type , extends ( abstract_vector_cdp ), public :: vector_cdp complex ( dp ), dimension ( test_size ) :: data = 0.0_dp contains private procedure , pass ( self ), public :: zero => init_zero_cdp procedure , pass ( self ), public :: dot => dot_cdp procedure , pass ( self ), public :: scal => scal_cdp procedure , pass ( self ), public :: axpby => axpby_cdp procedure , pass ( self ), public :: rand => rand_cdp procedure , pass ( self ), public :: get_size => get_size_cdp end type vector_cdp","tags":"","url":"type/vector_cdp.html"},{"title":"vector_csp – LightKrylov ","text":"type, public, extends( abstract_vector_csp ) :: vector_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public, dimension(test_size) :: data = 0.0_sp Type-Bound Procedures procedure, public, pass(self) :: add => add_csp Adds two abstract_vector , i.e. . private  subroutine add_csp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. class( abstract_vector_csp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => axpby_csp private  subroutine axpby_csp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: alpha class( abstract_vector_csp ), intent(in) :: vec complex(kind=sp), intent(in) :: beta class( vector_csp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_csp Change the sign of a vector, i.e. . private  subroutine chsgn_csp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dot_csp private  function dot_csp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( vector_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec Return Value complex(kind=sp) procedure, public, pass(self) :: get_size => get_size_csp private  function get_size_csp(self) result(N) Arguments Type Intent Optional Attributes Name class( vector_csp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_csp Computes the norm of the abstract_vector . private  function norm_csp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=sp) Norm of the vector. procedure, public, pass(self) :: rand => rand_csp private  subroutine rand_csp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( vector_csp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => scal_csp private  subroutine scal_csp(self, alpha) Arguments Type Intent Optional Attributes Name class( vector_csp ), intent(inout) :: self complex(kind=sp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_csp Subtracts two abstract_vector , i.e. . private  subroutine sub_csp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. class( abstract_vector_csp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => init_zero_csp private  subroutine init_zero_csp(self) Arguments Type Intent Optional Attributes Name class( vector_csp ), intent(inout) :: self Source Code type , extends ( abstract_vector_csp ), public :: vector_csp complex ( sp ), dimension ( test_size ) :: data = 0.0_sp contains private procedure , pass ( self ), public :: zero => init_zero_csp procedure , pass ( self ), public :: dot => dot_csp procedure , pass ( self ), public :: scal => scal_csp procedure , pass ( self ), public :: axpby => axpby_csp procedure , pass ( self ), public :: rand => rand_csp procedure , pass ( self ), public :: get_size => get_size_csp end type vector_csp","tags":"","url":"type/vector_csp.html"},{"title":"vector_rdp – LightKrylov ","text":"type, public, extends( abstract_vector_rdp ) :: vector_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(test_size) :: data = 0.0_dp Type-Bound Procedures procedure, public, pass(self) :: add => add_rdp Adds two abstract_vector , i.e. . private  subroutine add_rdp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rdp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => axpby_rdp private  subroutine axpby_rdp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha class( abstract_vector_rdp ), intent(in) :: vec real(kind=dp), intent(in) :: beta class( vector_rdp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_rdp Change the sign of a vector, i.e. . private  subroutine chsgn_rdp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dot_rdp private  function dot_rdp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( vector_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec Return Value real(kind=dp) procedure, public, pass(self) :: get_size => get_size_rdp private  function get_size_rdp(self) result(N) Arguments Type Intent Optional Attributes Name class( vector_rdp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_rdp Computes the norm of the abstract_vector . private  function norm_rdp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=dp) Norm of the vector. procedure, public, pass(self) :: rand => rand_rdp private  subroutine rand_rdp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( vector_rdp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => scal_rdp private  subroutine scal_rdp(self, alpha) Arguments Type Intent Optional Attributes Name class( vector_rdp ), intent(inout) :: self real(kind=dp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_rdp Subtracts two abstract_vector , i.e. . private  subroutine sub_rdp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rdp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => init_zero_rdp private  subroutine init_zero_rdp(self) Arguments Type Intent Optional Attributes Name class( vector_rdp ), intent(inout) :: self Source Code type , extends ( abstract_vector_rdp ), public :: vector_rdp real ( dp ), dimension ( test_size ) :: data = 0.0_dp contains private procedure , pass ( self ), public :: zero => init_zero_rdp procedure , pass ( self ), public :: dot => dot_rdp procedure , pass ( self ), public :: scal => scal_rdp procedure , pass ( self ), public :: axpby => axpby_rdp procedure , pass ( self ), public :: rand => rand_rdp procedure , pass ( self ), public :: get_size => get_size_rdp end type vector_rdp","tags":"","url":"type/vector_rdp.html"},{"title":"vector_rsp – LightKrylov ","text":"type, public, extends( abstract_vector_rsp ) :: vector_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public, dimension(test_size) :: data = 0.0_sp Type-Bound Procedures procedure, public, pass(self) :: add => add_rsp Adds two abstract_vector , i.e. . private  subroutine add_rsp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rsp ), intent(in) :: vec Vector to be added. procedure, public, pass(self) :: axpby => axpby_rsp private  subroutine axpby_rsp(alpha, vec, beta, self) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: alpha class( abstract_vector_rsp ), intent(in) :: vec real(kind=sp), intent(in) :: beta class( vector_rsp ), intent(inout) :: self procedure, public, pass(self) :: chsgn => chsgn_rsp Change the sign of a vector, i.e. . private  subroutine chsgn_rsp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Vector whose entries need to change sign. procedure, public, pass(self) :: dot => dot_rsp private  function dot_rsp(self, vec) result(alpha) Arguments Type Intent Optional Attributes Name class( vector_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec Return Value real(kind=sp) procedure, public, pass(self) :: get_size => get_size_rsp private  function get_size_rsp(self) result(N) Arguments Type Intent Optional Attributes Name class( vector_rsp ), intent(in) :: self Return Value integer procedure, public, pass(self) :: norm => norm_rsp Computes the norm of the abstract_vector . private  function norm_rsp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=sp) Norm of the vector. procedure, public, pass(self) :: rand => rand_rsp private  subroutine rand_rsp(self, ifnorm) Arguments Type Intent Optional Attributes Name class( vector_rsp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure, public, pass(self) :: scal => scal_rsp private  subroutine scal_rsp(self, alpha) Arguments Type Intent Optional Attributes Name class( vector_rsp ), intent(inout) :: self real(kind=sp), intent(in) :: alpha procedure, public, pass(self) :: sub => sub_rsp Subtracts two abstract_vector , i.e. . private  subroutine sub_rsp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rsp ), intent(in) :: vec Vector to be subtracted. procedure, public, pass(self) :: zero => init_zero_rsp private  subroutine init_zero_rsp(self) Arguments Type Intent Optional Attributes Name class( vector_rsp ), intent(inout) :: self Source Code type , extends ( abstract_vector_rsp ), public :: vector_rsp real ( sp ), dimension ( test_size ) :: data = 0.0_sp contains private procedure , pass ( self ), public :: zero => init_zero_rsp procedure , pass ( self ), public :: dot => dot_rsp procedure , pass ( self ), public :: scal => scal_rsp procedure , pass ( self ), public :: axpby => axpby_rsp procedure , pass ( self ), public :: rand => rand_rsp procedure , pass ( self ), public :: get_size => get_size_rsp end type vector_rsp","tags":"","url":"type/vector_rsp.html"},{"title":"lightkrylov_watch – LightKrylov ","text":"type, public, extends( abstract_watch ) :: lightkrylov_watch Global timing structure to contain all timers within Lightkrylov Type-Bound Procedures procedure, public, pass(self) :: add_group Add new timer group to the watch. private  subroutine add_group(self, name, istart, iend, count) Type-bound to abstract_watch: Add timer group to watch.\nNote: The new group name must be unique. This is a quick hack and should be done better. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in) :: istart integer, intent(in) :: iend integer, intent(out), optional :: count procedure, public, pass(self) :: add_timer Add new timer to the watch. private  subroutine add_timer(self, name, start, count) Type-bound to abstract_watch: Add timer to watch and optionally start it immediately.\nNote: The new timer name must be unique. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: start integer, intent(out), optional :: count procedure, public, pass(self) :: enumerate Print summary of registered timers and their current status. private  subroutine enumerate(self, only_user) Type-bound to abstract_watch: Summarize registered timers and their status. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(in) :: self logical, intent(in), optional :: only_user Summarize only user defined timers? default: .false. procedure, public, pass(self) :: finalize Gather timing information and print it to screen/logfile. private  subroutine finalize(self, write_to_file) Finalize global watch within LightKrylov and print used timers. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self logical, intent(in), optional :: write_to_file Print timer summary to a dedicated timer logfile as well as the general log file? default: .true. procedure, public, pass(self) :: get_called Get the number and names of timer called (locally or globally) private  subroutine get_called(self, n_called, names, only_user, check_global) Type-bound to abstract_watch: Get number and names of called timers Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self Watch integer, intent(out) :: n_called number of claled times character(len=128), intent(out), allocatable :: names (:) names of called timers logical, intent(in), optional :: only_user Check only for user defined timers? Default: .false. logical, intent(in), optional :: check_global Check for global call? Default: .false. procedure, public, pass(self) :: get_data => get_timer_data_by_name private  subroutine get_timer_data_by_name(self, name, restart, etime, etmin, etmax, etimp, lcount, rcount, gcount) Type-bound to abstract_watch: Getter routine to return the data for timer referenced by name.\nNotes: Wrapper of the corresponding routine from lightkrylov_timer.\n       If it is running, the timer is stopped. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: restart real(kind=dp), intent(out), optional :: etime real(kind=dp), intent(out), optional :: etmin real(kind=dp), intent(out), optional :: etmax real(kind=dp), intent(out), optional :: etimp integer, intent(out), optional :: lcount integer, intent(out), optional :: rcount integer, intent(out), optional :: gcount procedure, public, pass(self) :: get_data_save => get_timer_data_save_by_name private  subroutine get_timer_data_save_by_name(self, name, timed, countd) Type-bound to abstract_watch: Getter routine to return the timer data referenced by name.\nNotes: Wrapper of the corresponding routine from lightkrylov_timer.\n       If it is running, the timer is NOT stopped. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=dp), intent(out), allocatable :: timed (:,:) time information integer, intent(out), allocatable :: countd (:) Count information procedure, public, pass(self) :: get_group_id private  function get_group_id(self, name) result(id) Type-bound to abstract_watch: Getter routine to return the group id based on name. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(in) :: self character(len=*), intent(in) :: name Timer name Return Value integer procedure, public, pass(self) :: get_time => get_timer_etime_by_name private  function get_timer_etime_by_name(self, name, restart) result(etime) Type-bound to abstract_watch: Getter routine to return the current etime for timer referenced by name.\nNotes: Wrapper of the corresponding routine from lightkrylov_timer.\n       If it is running, the timer is stopped. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: restart Return Value real(kind=dp) procedure, public, pass(self) :: get_timer_id private  function get_timer_id(self, name) result(id) Type-bound to abstract_watch: Getter routine to return the timer id based on name. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(in) :: self character(len=*), intent(in) :: name Timer name Return Value integer procedure, public, pass(self) :: initialize Set up private timers, flags and counters. Switch on timing. private  subroutine initialize(self) Initialize global watch within LightKrylov and define private system timers. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self procedure, public, pass(self) :: pause => pause_timer_by_name private  subroutine pause_timer_by_name(self, name) Type-bound to abstract_watch: Pause timer referenced by name.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name procedure, public, pass(self) :: print_info => print_timer_info_by_name private  subroutine print_timer_info_by_name(self, name) Type-bound to abstract_watch: Print timing information for timer referenced by name.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name procedure, public, pass(self) :: remove_timer Remove existing timer from the watch. private  subroutine remove_timer(self, name, count) Type-bound to abstract_watch: Remove timer from watch.\nNote: Timers considered private (defined during initialisation) cannot be removed. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(out), optional :: count procedure, public, pass(self) :: reset => reset_timer_by_name private  subroutine reset_timer_by_name(self, name, soft, clean) Type-bound to abstract_watch: Reset timer referenced by name.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: reset_all Reset all timers in watch. private  subroutine reset_all(self, soft, clean) Type-bound to abstract_watch: Utility function to reset all timers at once.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self logical, intent(in), optional :: soft logical, intent(in), optional :: clean procedure, public, pass(self) :: set_private_timers_and_name => set_lightkrylov_timers private  subroutine set_lightkrylov_timers(self) Initialize global watch within LightKrylov and define private system timers. Arguments Type Intent Optional Attributes Name class( lightkrylov_watch ), intent(inout) :: self procedure, public, pass(self) :: set_watch_name private  subroutine set_watch_name(self, name) Type-bound to abstract_watch: Set name of watch Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name Watch name procedure, public, pass(self) :: start => start_timer_by_name private  subroutine start_timer_by_name(self, name) Type-bound to abstract_watch: Start timer referenced by name.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name procedure, public, pass(self) :: stop => stop_timer_by_name private  subroutine stop_timer_by_name(self, name) Type-bound to abstract_watch: Stop timer referenced by name.\nNote: Wrapper of the corresponding routine from lightkrylov_timer. Arguments Type Intent Optional Attributes Name class( abstract_watch ), intent(inout) :: self character(len=*), intent(in) :: name Source Code type , extends ( abstract_watch ), public :: lightkrylov_watch !! Global timing structure to contain all timers within Lightkrylov contains private procedure , pass ( self ), public :: set_private_timers_and_name => set_lightkrylov_timers end type lightkrylov_watch","tags":"","url":"type/lightkrylov_watch.html"},{"title":"abstract_linear_solver_cdp – LightKrylov","text":"interface public  subroutine abstract_linear_solver_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator to invert. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. Description Abstract interface to use a user-defined linear solver in LightKrylov .","tags":"","url":"interface/abstract_linear_solver_cdp.html"},{"title":"abstract_linear_solver_csp – LightKrylov","text":"interface public  subroutine abstract_linear_solver_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator to invert. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. Description Abstract interface to use a user-defined linear solver in LightKrylov .","tags":"","url":"interface/abstract_linear_solver_csp.html"},{"title":"abstract_linear_solver_rdp – LightKrylov","text":"interface public  subroutine abstract_linear_solver_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator to invert. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. Description Abstract interface to use a user-defined linear solver in LightKrylov .","tags":"","url":"interface/abstract_linear_solver_rdp.html"},{"title":"abstract_linear_solver_rsp – LightKrylov","text":"interface public  subroutine abstract_linear_solver_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator to invert. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. Description Abstract interface to use a user-defined linear solver in LightKrylov .","tags":"","url":"interface/abstract_linear_solver_rsp.html"},{"title":"abstract_exptA_cdp – LightKrylov","text":"interface public  subroutine abstract_exptA_cdp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: vec_in Input vector. real(kind=dp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? Description Abstract interface to define the matrix exponential-vector product.","tags":"","url":"interface/abstract_expta_cdp.html"},{"title":"abstract_exptA_csp – LightKrylov","text":"interface public  subroutine abstract_exptA_csp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: vec_out Solution vector. class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: vec_in Input vector. real(kind=sp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? Description Abstract interface to define the matrix exponential-vector product.","tags":"","url":"interface/abstract_expta_csp.html"},{"title":"abstract_exptA_rdp – LightKrylov","text":"interface public  subroutine abstract_exptA_rdp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: vec_in Input vector. real(kind=dp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? Description Abstract interface to define the matrix exponential-vector product.","tags":"","url":"interface/abstract_expta_rdp.html"},{"title":"abstract_exptA_rsp – LightKrylov","text":"interface public  subroutine abstract_exptA_rsp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: vec_in Input vector. real(kind=sp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? Description Abstract interface to define the matrix exponential-vector product.","tags":"","url":"interface/abstract_expta_rsp.html"},{"title":"constant_tol_dp – LightKrylov","text":"public  subroutine constant_tol_dp(tol, target_tol, rnorm, iter, info) Constant tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: tol Tolerance to be used real(kind=dp), intent(in) :: target_tol Target tolerance real(kind=dp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag Source Code subroutine constant_tol_dp ( tol , target_tol , rnorm , iter , info ) !! Constant tolerance scheduler for the Newton iteration real ( dp ), intent ( out ) :: tol !! Tolerance to be used real ( dp ), intent ( in ) :: target_tol !! Target tolerance real ( dp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals character ( len =* ), parameter :: this_procedure = 'constant_tol_dp' character ( len = 256 ) :: msg tol = target_tol if ( target_tol < atol_dp ) then tol = atol_dp write ( msg , '(A,E9.2)' ) 'Input tolerance below atol! Resetting solver tolerance to atol= ' , tol call log_warning ( msg , this_module , this_procedure ) else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if end subroutine constant_tol_dp","tags":"","url":"proc/constant_tol_dp.html"},{"title":"constant_tol_sp – LightKrylov","text":"public  subroutine constant_tol_sp(tol, target_tol, rnorm, iter, info) Constant tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: tol Tolerance to be used real(kind=sp), intent(in) :: target_tol Target tolerance real(kind=sp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag Source Code subroutine constant_tol_sp ( tol , target_tol , rnorm , iter , info ) !! Constant tolerance scheduler for the Newton iteration real ( sp ), intent ( out ) :: tol !! Tolerance to be used real ( sp ), intent ( in ) :: target_tol !! Target tolerance real ( sp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals character ( len =* ), parameter :: this_procedure = 'constant_tol_sp' character ( len = 256 ) :: msg tol = target_tol if ( target_tol < atol_sp ) then tol = atol_sp write ( msg , '(A,E9.2)' ) 'Input tolerance below atol! Resetting solver tolerance to atol= ' , tol call log_warning ( msg , this_module , this_procedure ) else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if end subroutine constant_tol_sp","tags":"","url":"proc/constant_tol_sp.html"},{"title":"dynamic_tol_dp – LightKrylov","text":"public  subroutine dynamic_tol_dp(tol, target_tol, rnorm, iter, info) Dynamic tolerance scheduler for the Newton iteration setting tol based on the current residual tol Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: tol Tolerance to be used real(kind=dp), intent(in) :: target_tol Target tolerance real(kind=dp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag Source Code subroutine dynamic_tol_dp ( tol , target_tol , rnorm , iter , info ) !! Dynamic tolerance scheduler for the Newton iteration setting tol based on the current residual tol real ( dp ), intent ( out ) :: tol !! Tolerance to be used real ( dp ), intent ( in ) :: target_tol !! Target tolerance real ( dp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals character ( len =* ), parameter :: this_procedure = 'dynamic_tol_dp' real ( dp ) :: tol_old , target_tol_ character ( len = 256 ) :: msg target_tol_ = max ( target_tol , atol_dp ) if ( target_tol < atol_dp ) then write ( msg , '(A,E9.2)' ) 'Input target tolerance below atol! Resetting target to atol= ' , target_tol_ call log_warning ( msg , this_module , this_procedure ) end if tol_old = tol tol = max ( 0.1 * rnorm , target_tol_ ) if ( tol /= tol_old ) then if ( tol == target_tol_ ) then write ( msg , '(A,E9.2)' ) 'Solver tolerance set to input target. tol= ' , tol else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol end if call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,E9.2)' ) 'solver tolerances unchanged at tol= ' , tol_old call log_information ( msg , this_module , this_procedure ) end if end subroutine dynamic_tol_dp","tags":"","url":"proc/dynamic_tol_dp.html"},{"title":"dynamic_tol_sp – LightKrylov","text":"public  subroutine dynamic_tol_sp(tol, target_tol, rnorm, iter, info) Dynamic tolerance scheduler for the Newton iteration setting tol based on the current residual tol Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: tol Tolerance to be used real(kind=sp), intent(in) :: target_tol Target tolerance real(kind=sp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag Source Code subroutine dynamic_tol_sp ( tol , target_tol , rnorm , iter , info ) !! Dynamic tolerance scheduler for the Newton iteration setting tol based on the current residual tol real ( sp ), intent ( out ) :: tol !! Tolerance to be used real ( sp ), intent ( in ) :: target_tol !! Target tolerance real ( sp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals character ( len =* ), parameter :: this_procedure = 'dynamic_tol_sp' real ( sp ) :: tol_old , target_tol_ character ( len = 256 ) :: msg target_tol_ = max ( target_tol , atol_sp ) if ( target_tol < atol_sp ) then write ( msg , '(A,E9.2)' ) 'Input target tolerance below atol! Resetting target to atol= ' , target_tol_ call log_warning ( msg , this_module , this_procedure ) end if tol_old = tol tol = max ( 0.1 * rnorm , target_tol_ ) if ( tol /= tol_old ) then if ( tol == target_tol_ ) then write ( msg , '(A,E9.2)' ) 'Solver tolerance set to input target. tol= ' , tol else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol end if call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,E9.2)' ) 'solver tolerances unchanged at tol= ' , tol_old call log_information ( msg , this_module , this_procedure ) end if end subroutine dynamic_tol_sp","tags":"","url":"proc/dynamic_tol_sp.html"},{"title":"newton – LightKrylov","text":"public interface newton Implements the simple Newton-Krylov method for finding roots (fixed points) of a \nnonlinear vector-valued function , i.e. solutions such that starting from an \ninitial guess via successive solution increments based on local linearization (the Jacobian) of the nonlinear function in the \nvicinity of the current solution. Algorthmic Features At iteration , the standard Newton step is \n  computed as the solution of the linear system where is the residual of the nonlinear \n  function. The new guess for the fixed point is then given by: where parametrizes the step length. The \n  standard Newton algorithm sets . The Jacobian is never assembled and the linear system is solved using one of \n  the available iterative solvers. When the residual norm does not decrease during iteration indicating that the \n  linearization is not a very accurate model of the function's behaviour, which \n  often happens during the initial iterations, a 1D step bisection method based \n  on the golden ratio is implemented to dampen the step and improve convergence \n  of the method. The implementation allows for dynamic tolerances (also known as inexact Newton), \n  where the approximation for the residual and the linear system can be solved \n  with relaxed tolerances to reduce overall time to solution. The method is suitable to both fixed points and periodic orbits via the choice \n  of residual and corresponding Jacobian matrix. In the case of unforced periodic \n  orbits, the period is itself an unknown that must be included in the iteration. Advantages The iterative solution of the linear systems has a comparatively low storage \n  footprint. If the Newton iteration converges, the convergence is formally asymptotically \n  of second order. Using dynamic tolerances and line searches slightly reduce \n  this convergence rate in exchange for a larger convergence region. Limitations The method is not guaranteed to converge if the initial guess is too far from \n  the fixed point. If the Newton iteration diverges even with step bisection, \n  the best suggestion is to find a better initial guess. If this is not feasible, \n  some alternatives to improve the convergence of the Newton iteration are possible \n  (but not implemented to date), including various line search algorithms and trust \n  region methods (doglog, double dogleg, hookstep, ...). References Sánchez, J., Net, M., Garcıa-Archilla, B., & Simó, C. (2004). \"Newton–Krylov \n  continuation of periodic orbits for Navier–Stokes flows\". Journal of Computational \n  Physics, 201(1), 13-33. Viswanath, D. (2007). \"Recurrent motions within plane Couette turbulence\". \n  Journal of Fluid Mechanics, 580, 339-358. Duguet, Y., Pringle, C. C. T., Kerswell, R. R. (2008). \"Relative periodic orbits \n  in transitional pipe flow\". Physics  of Fluids, 20(11), 114102. Frantz, R. A., Loiseau, J. C., & Robinet, J. C. (2023). \"Krylov methods for \n  large-scale dynamical systems: Application in fluid dynamics\". Applied Mechanics\n  Reviews, 75(3), 030802. Module Procedures private  subroutine newton_rsp(sys, X, solver, info, rtol, atol, options, linear_solver_options, preconditioner, scheduler, meta) Arguments Type Intent Optional Attributes Name class( abstract_system_rsp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_rsp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_rsp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=sp), intent(in), optional :: rtol real(kind=sp), intent(in), optional :: atol type( newton_sp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_sp), optional :: scheduler class( abstract_metadata ), intent(out), optional :: meta Metadata. private  subroutine newton_rdp(sys, X, solver, info, rtol, atol, options, linear_solver_options, preconditioner, scheduler, meta) Arguments Type Intent Optional Attributes Name class( abstract_system_rdp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_rdp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_rdp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=dp), intent(in), optional :: rtol real(kind=dp), intent(in), optional :: atol type( newton_dp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_dp), optional :: scheduler class( abstract_metadata ), intent(out), optional :: meta Metadata. private  subroutine newton_csp(sys, X, solver, info, rtol, atol, options, linear_solver_options, preconditioner, scheduler, meta) Arguments Type Intent Optional Attributes Name class( abstract_system_csp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_csp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_csp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=sp), intent(in), optional :: rtol real(kind=sp), intent(in), optional :: atol type( newton_sp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_sp), optional :: scheduler class( abstract_metadata ), intent(out), optional :: meta Metadata. private  subroutine newton_cdp(sys, X, solver, info, rtol, atol, options, linear_solver_options, preconditioner, scheduler, meta) Arguments Type Intent Optional Attributes Name class( abstract_system_cdp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_cdp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_cdp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=dp), intent(in), optional :: rtol real(kind=dp), intent(in), optional :: atol type( newton_dp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_dp), optional :: scheduler class( abstract_metadata ), intent(out), optional :: meta Metadata.","tags":"","url":"interface/newton.html"},{"title":"Gram – LightKrylov","text":"public interface Gram Compute the Gram matrix . Description This interface provides methods for computing the Gram matrix associated to a basis of abstract_vector . Example The example below assumes that you have already extended the abstract_vector_rdp class to define your own my_real_vector type. type ( my_real_vector ), dimension ( 10 ) :: X real ( dp ), dimension (:, :), allocatable :: G ! ... Part of your code where you initialize everything ... G = Gram ( X ) ! ... Rest of your code ... Module Procedures private  function gram_matrix_rsp(X) result(G) Computes the inner product/Gram matrix associated with the basis . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: X (:) Return Value real(kind=sp), (size(X),size(X)) private  function gram_matrix_rdp(X) result(G) Computes the inner product/Gram matrix associated with the basis . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: X (:) Return Value real(kind=dp), (size(X),size(X)) private  function gram_matrix_csp(X) result(G) Computes the inner product/Gram matrix associated with the basis . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: X (:) Return Value complex(kind=sp), (size(X),size(X)) private  function gram_matrix_cdp(X) result(G) Computes the inner product/Gram matrix associated with the basis . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: X (:) Return Value complex(kind=dp), (size(X),size(X))","tags":"","url":"interface/gram.html"},{"title":"axpby_basis – LightKrylov","text":"public interface axpby_basis In-place addition of two arrays of extended abstract_vector . Description This interface provides methods to add in-place two arrays of\nextended abstract_vector , i.e. No out-of-place alternative is currently available in LightKrylov .\nIf you do need an out-of-place version, you can combine axpby_basis with copy . Example type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y real ( dp ), dimension ( 10 ) :: alpha , beta ! ... Whatever your code is doing ... call axpby_basis ( alpha , X , beta , Y ) ! ... Rest of your code ... Module Procedures private impure elemental subroutine axpby_basis_rsp(alpha, X, beta, Y) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are real(sp)\nnumbers. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_rsp ), intent(in) :: X Input/Ouput array of abstract_vector . real(kind=sp), intent(in) :: beta Scalar multipliers. class( abstract_vector_rsp ), intent(inout) :: Y Array of abstract_vector to be added/subtracted to/from X . private impure elemental subroutine axpby_basis_rdp(alpha, X, beta, Y) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are real(dp)\nnumbers. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_rdp ), intent(in) :: X Input/Ouput array of abstract_vector . real(kind=dp), intent(in) :: beta Scalar multipliers. class( abstract_vector_rdp ), intent(inout) :: Y Array of abstract_vector to be added/subtracted to/from X . private impure elemental subroutine axpby_basis_csp(alpha, X, beta, Y) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are complex(sp)\nnumbers. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_csp ), intent(in) :: X Input/Ouput array of abstract_vector . complex(kind=sp), intent(in) :: beta Scalar multipliers. class( abstract_vector_csp ), intent(inout) :: Y Array of abstract_vector to be added/subtracted to/from X . private impure elemental subroutine axpby_basis_cdp(alpha, X, beta, Y) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are complex(dp)\nnumbers. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_cdp ), intent(in) :: X Input/Ouput array of abstract_vector . complex(kind=dp), intent(in) :: beta Scalar multipliers. class( abstract_vector_cdp ), intent(inout) :: Y Array of abstract_vector to be added/subtracted to/from X .","tags":"","url":"interface/axpby_basis.html"},{"title":"copy – LightKrylov","text":"public interface copy This interface provides methods to copy an array X of abstract_vector into\nanother array Y . Note that Y needs to be pre-allocated. Example type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y ! ... Your code ... call copy ( Y , X ) ! ... Your code ... Module Procedures private impure elemental subroutine copy_vector_rsp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: out class( abstract_vector_rsp ), intent(in) :: from private impure elemental subroutine copy_vector_rdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: out class( abstract_vector_rdp ), intent(in) :: from private impure elemental subroutine copy_vector_csp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: out class( abstract_vector_csp ), intent(in) :: from private impure elemental subroutine copy_vector_cdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: out class( abstract_vector_cdp ), intent(in) :: from","tags":"","url":"interface/copy.html"},{"title":"dense_vector – LightKrylov","text":"public interface dense_vector Module Procedures private  function initialize_dense_vector_from_array_rsp(x) result(vec) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value type( dense_vector_rsp ) private  function initialize_dense_vector_from_array_rdp(x) result(vec) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value type( dense_vector_rdp ) private  function initialize_dense_vector_from_array_csp(x) result(vec) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value type( dense_vector_csp ) private  function initialize_dense_vector_from_array_cdp(x) result(vec) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value type( dense_vector_cdp )","tags":"","url":"interface/dense_vector.html"},{"title":"innerprod – LightKrylov","text":"public interface innerprod Compute the inner product vector or matrix . Description This interface provides methods for computing the inner products between a basis\nof real or complex vectors and a single vector or another basis . Depending on the case, it\nreturns a one-dimensional array or a two-dimensional array with the same type as . Example The example below assumes that you have already extended the abstract_vector_rdp class to define your own my_real_vector type. type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ) :: y real ( dp ), dimension (:), allocatable :: v ! ... Part of your code where you initialize everything ... v = innerprod ( X , y ) ! ... Rest of your code ... Similarly, for computing the matrix of inner products between two bases type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y real ( dp ), dimension (:, :), allocatable :: M ! ... Part of your code where you initialize everything ... M = innerprod ( X , Y ) ! ... Rest of your code ... Module Procedures private  function innerprod_vector_rsp(X, v) result(y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: X (:) Basis and single instance of abstract_vector whose inner products need to be computed. class( abstract_vector_rsp ), intent(in) :: v Basis and single instance of abstract_vector whose inner products need to be computed. Return Value real(kind=sp), (size(X)) Resulting inner-product vector. private  function innerprod_matrix_rsp(X, Y) result(M) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rsp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. Return Value real(kind=sp), (size(X),size(Y)) Resulting inner-product matrix. private  function innerprod_vector_rdp(X, v) result(y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: X (:) Basis and single instance of abstract_vector whose inner products need to be computed. class( abstract_vector_rdp ), intent(in) :: v Basis and single instance of abstract_vector whose inner products need to be computed. Return Value real(kind=dp), (size(X)) Resulting inner-product vector. private  function innerprod_matrix_rdp(X, Y) result(M) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rdp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. Return Value real(kind=dp), (size(X),size(Y)) Resulting inner-product matrix. private  function innerprod_vector_csp(X, v) result(y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: X (:) Basis and single instance of abstract_vector whose inner products need to be computed. class( abstract_vector_csp ), intent(in) :: v Basis and single instance of abstract_vector whose inner products need to be computed. Return Value complex(kind=sp), (size(X)) Resulting inner-product vector. private  function innerprod_matrix_csp(X, Y) result(M) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_csp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. Return Value complex(kind=sp), (size(X),size(Y)) Resulting inner-product matrix. private  function innerprod_vector_cdp(X, v) result(y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: X (:) Basis and single instance of abstract_vector whose inner products need to be computed. class( abstract_vector_cdp ), intent(in) :: v Basis and single instance of abstract_vector whose inner products need to be computed. Return Value complex(kind=dp), (size(X)) Resulting inner-product vector. private  function innerprod_matrix_cdp(X, Y) result(M) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_cdp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. Return Value complex(kind=dp), (size(X),size(Y)) Resulting inner-product matrix.","tags":"","url":"interface/innerprod.html"},{"title":"linear_combination – LightKrylov","text":"public interface linear_combination Given a set of extended abstract_vectors and coefficients, return the corresponding\nlinear combinations. Description This interface provides methods for computing linear combinations of a set of abstract_vectors . Depending on its input, it either computes i.e. a single vector, or i.e. a set of vectors of the same type as . Example type ( my_real_vector ), dimension ( 10 ) :: X real ( dp ), dimension ( m , n ) :: B type ( my_real_vector ) :: Y ! ... Whatever your code is doing ... call linear_combination ( Y , X , B ) ! ... Rest of your code ... Module Procedures private  subroutine linear_combination_vector_rsp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_rsp ), intent(in) :: X (:) Krylov basis. real(kind=sp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_rsp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_rsp ), intent(in) :: X (:) Krylov basis. real(kind=sp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_rdp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_rdp ), intent(in) :: X (:) Krylov basis. real(kind=dp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_rdp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_rdp ), intent(in) :: X (:) Krylov basis. real(kind=dp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_csp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_csp ), intent(in) :: X (:) Krylov basis. complex(kind=sp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_csp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_csp ), intent(in) :: X (:) Krylov basis. complex(kind=sp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_cdp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_cdp ), intent(in) :: X (:) Krylov basis. complex(kind=dp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_cdp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_cdp ), intent(in) :: X (:) Krylov basis. complex(kind=dp), intent(in) :: B (:,:) Coefficients of the linear combinations.","tags":"","url":"interface/linear_combination.html"},{"title":"rand_basis – LightKrylov","text":"public interface rand_basis This interface provides methods to create an array X of random abstract_vector .\nIt is a simple wrapper around X(i)%rand(ifnorm) . Example type ( my_real_vector ), dimension ( 10 ) :: X logical :: ifnorm = . true . ! ... Your code ... call rand_basis ( X , ifnorm ) ! ... Your code ... Module Procedures private impure elemental subroutine rand_basis_rsp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X logical, intent(in), optional :: ifnorm private impure elemental subroutine rand_basis_rdp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X logical, intent(in), optional :: ifnorm private impure elemental subroutine rand_basis_csp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X logical, intent(in), optional :: ifnorm private impure elemental subroutine rand_basis_cdp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X logical, intent(in), optional :: ifnorm","tags":"","url":"interface/rand_basis.html"},{"title":"zero_basis – LightKrylov","text":"public interface zero_basis This interface provides methods to zero-out a collection of abstract_vector X .\nIt is a simple wrapper around X(i)%zero() . Example type ( my_real_vector ), dimension ( 10 ) :: X ! ... Your code ... call zero_basis ( X ) ! ... Your code ... Module Procedures private impure elemental subroutine zero_basis_rsp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X private impure elemental subroutine zero_basis_rdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X private impure elemental subroutine zero_basis_csp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X private impure elemental subroutine zero_basis_cdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X","tags":"","url":"interface/zero_basis.html"},{"title":"get_comm_size – LightKrylov","text":"public pure function get_comm_size() result(c_size) Utility function to get the dimension of the communicator known to LightKrylov . Arguments None Return Value integer Source Code pure integer function get_comm_size () result ( c_size ) !! Utility function to get the dimension of the communicator known to `LightKrylov`. c_size = comm_size end function get_comm_size","tags":"","url":"proc/get_comm_size.html"},{"title":"get_rank – LightKrylov","text":"public pure function get_rank() result(rank) Utility function to get the rank of the current MPI process. Arguments None Return Value integer Source Code pure integer function get_rank () result ( rank ) !! Utility function to get the rank of the current MPI process. rank = nid end function get_rank","tags":"","url":"proc/get_rank.html"},{"title":"io_rank – LightKrylov","text":"public pure function io_rank() result(is_io) Utility function to determine whether the current MPI process can do I/O. Arguments None Return Value logical Source Code pure logical function io_rank () result ( is_io ) !! Utility function to determine whether the current MPI process can do I/O. is_io = . false . if ( nid == nio ) is_io = . true . end function io_rank","tags":"","url":"proc/io_rank.html"},{"title":"set_comm_size – LightKrylov","text":"public  subroutine set_comm_size(c_size) Utility function to inform LightKrylov of the MPI-communicator's dimension. Arguments Type Intent Optional Attributes Name integer, intent(in) :: c_size Dimension of the MPI communicator. Source Code subroutine set_comm_size ( c_size ) !! Utility function to inform `LightKrylov` of the MPI-communicator's dimension. integer , intent ( in ) :: c_size !! Dimension of the MPI communicator. comm_size = c_size end subroutine set_comm_size","tags":"","url":"proc/set_comm_size.html"},{"title":"set_io_rank – LightKrylov","text":"public  subroutine set_io_rank(rk) Utility function to set the rank of the process doing I/O. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rk Desired rank for the IO process. Source Code subroutine set_io_rank ( rk ) !! Utility function to set the rank of the process doing I/O. integer , intent ( in ) :: rk !! Desired rank for the IO process. if ( rk > comm_size . or . rk < 0 ) then if ( io_rank ()) print * , 'Invalid I/O rank specified!' , rk else nio = rk if ( io_rank ()) print * , 'I/O rank --> rank ' , nio end if end subroutine set_io_rank","tags":"","url":"proc/set_io_rank.html"},{"title":"set_rank – LightKrylov","text":"public  subroutine set_rank(rank) Utility function to set the rank of an MPI process. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank Desired rank identification. Source Code subroutine set_rank ( rank ) !! Utility function to set the rank of an MPI process. integer , intent ( in ) :: rank !! Desired rank identification. nid = rank end subroutine set_rank","tags":"","url":"proc/set_rank.html"},{"title":"greetings – LightKrylov","text":"public  subroutine greetings() Arguments None Source Code subroutine greetings () write ( * , * ) write ( * , * ) write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) write ( * , * ) \"      _     _       _     _   _  __           _            \" write ( * , * ) \"     | |   (_) __ _| |__ | |_| |/ /_ __ _   _| | _____   __\" write ( * , * ) \"     | |   | |/ _` | '_ \\| __| ' /| '__| | | | |/ _ \\ \\ / /\" write ( * , * ) \"     | |___| | (_| | | | | |_| . \\| |  | |_| | | (_) \\ V / \" write ( * , * ) \"     |_____|_|\\__, |_| |_|\\__|_|\\_\\_|   \\__, |_|\\___/ \\_/  \" write ( * , * ) \"              |___/                     |___/              \" write ( * , * ) write ( * , * ) \"Developed by: Jean-Christophe Loiseau\" write ( * , * ) \"              J. Simon Kern\" write ( * , * ) \"              Arts & Métiers Institute of Technology, 2023.\" write ( * , * ) \"              jean-christophe.loiseau@ensam.eu\" write ( * , * ) write ( * , * ) \"Version -- beta 0.1.0\" write ( * , * ) \"License -- BSD 3-Clause\" write ( * , * ) write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) write ( * , * ) end subroutine greetings","tags":"","url":"proc/greetings.html"},{"title":"arnoldi – LightKrylov","text":"public interface arnoldi Description Given a square linear operator , find matrices and such that where is an orthogonal basis and is upper Hessenberg. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis via the Gram-Schmidt process. Constructs an upper Hessenberg matrix whose eigenvalues approximates those of . Checks for convergence and invariant subspaces. References Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003.\n  see Chapter 6.3: Arnoldi's method. Syntax call arnoldi ( A , X , H , info [, kstart ] [, kend ] [, tol ] [, transpose ] [, blksize ]) Arguments A : Linear operator derived from one the base types provided by the AbstractLinops module. The operator needs to be square, i.e. the dimension of its domain and\n        co-domain is the same. It is an intent(inout) argument. X : Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n        the computed Krylov vectors. The first entry X(1) is the starting vector for\n        the Arnoldi factorization. Additionally, the maximum number of Arnoldi steps\n        is equal to size(X) - 1 . It is an intent(inout) argument. - H : real or complex rank-2 array. On exit, it contains the upper Hessenberg matrix computed from the Arnoldi factorization. It is an intent(inout) argument. - info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Arnoldi factorization experienced a lucky breakdown. \n            The array of Krylov vectors X spans an -invariant subpsace of\n            dimension info . kstart ( optional ) : integer value determining the index of the first Arnoldi\n                            step to be computed. By default, kstart = 1 . It is an\n                            optional intent(in) argument. kend ( optional )   : integer value determining the index of the last Arnoldi step\n                            to be computed. It is an optional intent(in) argument. \n                            By default, kend = size(X) - 1 . tol ( optional )    :   Numerical tolerance below which a subspace is considered\n                            to be -invariant. It is an optional intent(in) argument.\n                            By default tol = atol_sp or tol = atol_rp depending on the \n                            kind of A . transpose ( optional )  : logical flag determining whether the Arnoldi factorization\n                                is applied to or . It is an optional intent(in) argument. Default transpose = .false. blksize ( optional )    : integer value determining the dimension of a block for the\n                                block Arnoldi factorization. It is an optional intent(in) argument. Default is blksize=1 . Subroutines private module subroutine arnoldi_cdp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_cdp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. complex(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=dp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private module subroutine arnoldi_csp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_csp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. complex(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=sp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private module subroutine arnoldi_rdp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_rdp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. real(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=dp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private module subroutine arnoldi_rsp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_rsp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. real(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=sp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1).","tags":"","url":"interface/arnoldi.html"},{"title":"bidiagonalization – LightKrylov","text":"public interface bidiagonalization Description Given a general linear operator , find matrices , and such that where and are orthogonal bases for the column span and row span\nof , respectively, and is a bidiagonal matrix. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis for the column span of . Constructs an orthonormal Krylov basis for the row span of . Constructs a bidiagonal matrix whose singular values approximates those of . Checks for convergence and invariant subspaces. References R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\" \n  Technical Report, 1998. (PDF) Syntax call bidiagonalization ( A , U , V , B , info [, kstart ] [, kend ] [, tol ]) Arguments A :   Linear operator derived from one the base types provided by the AbstractLinops module. It is an intent(inout) argument. U :   Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n            the computed Krylov vectors for the column span of A . The first entry U(1) is the starting vector for the Lanczos factorization. Additionally, the \n            maximum number of Lanczos steps is equal to size(X) - 1 . \n            It is an intent(inout) argument. V :   Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n            the computed Krylov vectors for the row span of A . It is an intent(inout) argument. B : real or complex rank-2 array. On exit, it contains the bidiagonal matrix computed from the Lanczos factorization. It is an intent(inout) argument. info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Lanczos factorization experienced a lucky breakdown. kstart ( optional ) : integer value determining the index of the first Lanczos\n                            step to be computed. It is an optional intent(in) argument.\n                            By default, kstart = 1 . kend ( optional )   : integer value determining the index of the last Lanczos step\n                            to be computed. It is an optional intent(in) argument. \n                            By default, kend = size(X) - 1 . tol ( optional )    :   Numerical tolerance below which a subspace is considered\n                            to be -invariant. It is an optional intent(in) argument.\n                            By default tol = atol_sp or tol = atol_rp depending on the \n                            kind of A . Subroutines private module subroutine lanczos_bidiagonalization_cdp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_cdp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_cdp ), intent(inout) :: V (:) Orthonormal basis for the row span of . complex(kind=dp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=dp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private module subroutine lanczos_bidiagonalization_csp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_csp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_csp ), intent(inout) :: V (:) Orthonormal basis for the row span of . complex(kind=sp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=sp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private module subroutine lanczos_bidiagonalization_rdp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_rdp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_rdp ), intent(inout) :: V (:) Orthonormal basis for the row span of . real(kind=dp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=dp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private module subroutine lanczos_bidiagonalization_rsp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_rsp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_rsp ), intent(inout) :: V (:) Orthonormal basis for the row span of . real(kind=sp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=sp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not.","tags":"","url":"interface/bidiagonalization.html"},{"title":"double_gram_schmidt_step – LightKrylov","text":"public interface double_gram_schmidt_step Description Given an array of abstract_vector and an abstract_vector (or array of abstract_vectors ) , this subroutine returns a modified \nvector orthogonal to all columns of , i.e. using a double Gram-Schmidt process. On exit, is orthogonal to but\ndoes not have unit norm. Note moreover that is assumed to be an orthonormal \nset of vectors. The function can also return the projection coefficients . Syntax call double_gram_schmidt_step ( y , X , info [, if_chk_orthonormal ] [, beta ]) Arguments y : abstract_vector (or array of abstract_vector ) that needs to be\n            orthogonalize in-place against . It is an intent(inout) argument. X :   Array of abstract_vector against which needs to be orthogonalized.\n            Note the function assumes that is an orthonormal set of vectors, i.e. . If it this is not the case, the result is meaningless. \n            It is an intent(in) argument. info : integer Information flag. if_chk_orthonormal ( optional ) : logical flag to check whether is an orthonormal set of vectors or not. \n                                        If the orthonormality returns .false. , the function raises\n                                        an error. Note that this check is computationally expensive \n                                        and should be disabled in production unless required\n                                        for better performance. Is is an optional intent(in) argument. Default .true. . beta ( optional )   : real or complex array containing the coefficients .\n                            Is is an optional intent(out) argument. Subroutines private module subroutine DGS_basis_against_basis_cdp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine DGS_basis_against_basis_csp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine DGS_basis_against_basis_rdp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine DGS_basis_against_basis_rsp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine DGS_vector_against_basis_cdp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine DGS_vector_against_basis_csp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine DGS_vector_against_basis_rdp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine DGS_vector_against_basis_rsp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested","tags":"","url":"interface/double_gram_schmidt_step.html"},{"title":"initialize_krylov_subspace – LightKrylov","text":"public interface initialize_krylov_subspace Description Utility function to initialize a basis for a Krylov subspace. Syntax call initialize_krylov_subspace ( X [, X0 ]) Arguments X :   Array of vectors that needs to be initialized. It is an intent(inout) argument. Note that the first action in the subroutine is call zero_basis(X) , effectively zeroing-out any data stored. X0 ( optional ) :   Collection of vectors which will form the first few\n                        Krylov vectors. Note that X0 need not be an orthonormal\n                        basis as this subroutine includes a call orthonormalize_basis(X0) .\n                        It is an optional intent(in) argument. Subroutines private module subroutine initialize_krylov_subspace_cdp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) class( abstract_vector_cdp ), intent(in), optional :: X0 (:) private module subroutine initialize_krylov_subspace_csp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) class( abstract_vector_csp ), intent(in), optional :: X0 (:) private module subroutine initialize_krylov_subspace_rdp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) class( abstract_vector_rdp ), intent(in), optional :: X0 (:) private module subroutine initialize_krylov_subspace_rsp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) class( abstract_vector_rsp ), intent(in), optional :: X0 (:)","tags":"","url":"interface/initialize_krylov_subspace.html"},{"title":"initialize_random_orthonormal_basis – LightKrylov","text":"public interface initialize_random_orthonormal_basis Description Utility function to initialize a random orthonormal basis. Syntax call initialize_random_orthonormal_basis ( X ) Arguments X :   Array of vectors that needs to be initialized with random orthonormal vectors.\n            It is an intent(inout) argument. Subroutines private module subroutine initialize_random_orthonormal_basis_cdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) private module subroutine initialize_random_orthonormal_basis_csp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) private module subroutine initialize_random_orthonormal_basis_rdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) private module subroutine initialize_random_orthonormal_basis_rsp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:)","tags":"","url":"interface/initialize_random_orthonormal_basis.html"},{"title":"invperm – LightKrylov","text":"interface Description Given a permutation vector , this function computes the vector\nrepresentation of the inverse permutation matrix. Syntax inv_perm = invperm ( perm ) Arguments perm :   Rank-1 array of integer corresponding to the desired permutation vector.\n                It is an intent(in) argument. public module function invperm(perm) result(inv_perm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: perm (:) Return Value integer,allocatable,(:)","tags":"","url":"interface/invperm.html"},{"title":"is_orthonormal – LightKrylov","text":"public interface is_orthonormal Description Utility function returning a logical .true. if the set of vectors stored in form\nan orthonormal set of vectors and .false. otherwise. Syntax out = is_orthonormal ( X ) Arguments X :   Array of derived types extended from the base types provided in the AbstractVectors module. It is an intent(in) argument. Functions private module function is_orthonormal_cdp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: X (:) Return Value logical private module function is_orthonormal_csp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: X (:) Return Value logical private module function is_orthonormal_rdp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: X (:) Return Value logical private module function is_orthonormal_rsp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: X (:) Return Value logical","tags":"","url":"interface/is_orthonormal.html"},{"title":"krylov_schur – LightKrylov","text":"public interface krylov_schur Description Given a partial Krylov decomposition this subroutine implements the Krylov-Schur restarting strategy proposed by\nStewart [1]. References G. W. Stewart. \"A Krylov-Schur algorithm for large eigenproblems\".\n  SIAM Journal on Matrix Analysis and Applications, vol 23 (3), 2002. Syntax call krylov_schur ( n , X , H , select_eigs ) Arguments n :   Number of selected eigenvalues moved to the upper left-block of the \n            Schur matrix. It is an intent(out) argument. X :   On entry, array of abstract_vector computed using the Arnoldi process.\n            On exit, the first n columns form an orthonormal basis for the eigenspace\n            associated with eigenvalues moved to the upper left-block of the Schur matrix.\n            It is an intent(inout) argument. H :   On entry, real of complex upper Hessenberg matrix computed using the\n            Arnoldi process. On exit, the leading block contains the block of the re-ordered Schur matrix containing the selected\n            eigenvalues. It is an intent(inout) argument. select_eigs :   Procedure to select which eigenvalues to move in the upper-left\n                block. It is an intent(inout) argument. Module Procedures private  subroutine krylov_schur_rsp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_rsp ), intent(inout) :: X (:) Krylov basis. real(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure(eigvals_select_sp) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_rdp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_rdp ), intent(inout) :: X (:) Krylov basis. real(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure(eigvals_select_dp) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_csp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_csp ), intent(inout) :: X (:) Krylov basis. complex(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure(eigvals_select_sp) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_cdp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_cdp ), intent(inout) :: X (:) Krylov basis. complex(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure(eigvals_select_dp) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block.","tags":"","url":"interface/krylov_schur.html"},{"title":"lanczos – LightKrylov","text":"public interface lanczos Description Given a symmetric or Hermitian linear operator , find matrices and such that where is an orthogonal basis and is symmetric tridiagonal. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis via the Lanczos process with full\n  reorthogonalization. Constructs a symmetric tridiagonal matrix whose eigenvalues approximates those of . Checks for convergence and invariant subspaces. References Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003.\n  see Chapter 6.6: The symmetric Lanczos algorithm. Syntax call lanczos ( A , X , T , info [, kstart ] [, kend ] [, tol ]) Arguments A :   Symmetric or Hermitian linear operator derived from one the base types \n            provided by the AbstractLinops module. It is an intent(inout) argument. X :   Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n            the computed Krylov vectors. The first entry X(1) is the starting vector for\n            the Lanczos factorization. Additionally, the maximum number of Lanczos steps\n            is equal to size(X) - 1 . It is an intent(inout) argument. T : real or complex rank-2 array. On exit, it contains the symmetric tridiagonal matrix computed from the Arnoldi factorization. It is an intent(inout) argument. info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Lanczos factorization experienced a lucky breakdown. \n                The array of Krylov vectors X spans an -invariant subpsace of\n                dimension info . kstart ( optional ) : integer value determining the index of the first Lanczos\n                            step to be computed. It is an optional intent(in) argument.\n                            By default, kstart = 1 . kend ( optional )   : integer value determining the index of the last Lanczos step\n                            to be computed. It is an optional intent(in) argument. \n                            By default, kend = size(X) - 1 . tol ( optional )    :   Numerical tolerance below which a subspace is considered\n                            to be -invariant. It is an optional intent(in) argument.\n                            By default tol = atol_sp or tol = atol_rp depending on the \n                            kind of A . Subroutines private module subroutine lanczos_tridiagonalization_cdp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(inout) :: A class( abstract_vector_cdp ), intent(inout) :: X (:) complex(kind=dp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=dp), intent(in), optional :: tol private module subroutine lanczos_tridiagonalization_csp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(inout) :: A class( abstract_vector_csp ), intent(inout) :: X (:) complex(kind=sp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=sp), intent(in), optional :: tol private module subroutine lanczos_tridiagonalization_rdp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(inout) :: A class( abstract_vector_rdp ), intent(inout) :: X (:) real(kind=dp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=dp), intent(in), optional :: tol private module subroutine lanczos_tridiagonalization_rsp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(inout) :: A class( abstract_vector_rsp ), intent(inout) :: X (:) real(kind=sp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=sp), intent(in), optional :: tol","tags":"","url":"interface/lanczos.html"},{"title":"orthogonalize_against_basis – LightKrylov","text":"public interface orthogonalize_against_basis Subroutines private module subroutine orthogonalize_basis_against_basis_cdp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine orthogonalize_basis_against_basis_csp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine orthogonalize_basis_against_basis_rdp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine orthogonalize_basis_against_basis_rsp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine orthogonalize_vector_against_basis_cdp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine orthogonalize_vector_against_basis_csp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine orthogonalize_vector_against_basis_rdp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine orthogonalize_vector_against_basis_rsp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested","tags":"","url":"interface/orthogonalize_against_basis.html"},{"title":"orthonormalize_basis – LightKrylov","text":"public interface orthonormalize_basis Description Given an array of vectors, it computes an orthonormal basis for its\ncolumn-span using the double_gram_schmidt process. All computations are done\nin-place. Syntax call orthonormalize_basis ( X ) Arguments X :   Array of abstract_vector to orthonormalize. Note that this process is done\n            in-place. It is an intent(inout) argument. Subroutines private module subroutine orthonormalize_basis_cdp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private module subroutine orthonormalize_basis_csp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private module subroutine orthonormalize_basis_rdp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private module subroutine orthonormalize_basis_rsp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against","tags":"","url":"interface/orthonormalize_basis.html"},{"title":"permcols – LightKrylov","text":"public interface permcols Description Given an array and a permutation vector , this function computes in-place the column-permuted matrix where is the column-permutation matrix constructed from the permutation\nvector . Syntax call permcols ( X , perm ) Arguments X :   Array of vectors derived from the base types defined in the AbstractVectors module. On entry, it is the original array. On exit, it contains the\n            column-permuted version computed in-place. It is an intent(inout) argument. perm :   Rank-1 array of integer corresponding to the desired permutation vector.\n                It is an intent(in) argument. Subroutines private module subroutine permcols_array_cdp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_array_csp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_array_rdp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_array_rsp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_basis_cdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_basis_csp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_basis_rdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_basis_rsp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:)","tags":"","url":"interface/permcols.html"},{"title":"qr – LightKrylov","text":"public interface qr Description Given an array of types derived from abstract_vector , it computes the in-place QR factorization of , i.e. where is an orthonormal arrays of vectors such that and is upper triangular. Note that it can also perform the QR factorization\nwith column pivoting where is a permutation matrix ensuring that the diagonal entries of have non-increasing absolute values. This amounts to using the pivoting QR as a\nrank-revealing factorization. References G. H. Golub & C. F. Van Loan. \"Matrix Computations\". 4th edition, The John Hopkins\n University Press, 2013.\n See Chapter 5.2.8: Modified Gram-Schmidt algorithm. Syntax call qr ( Q [, R ] [, perm ], info [, tol ]) Arguments Q :   Array of types derived from one of the base types provided in the AbstractVectors module. On entry, it contains the original array.\n            On exit, it is overwritten by the orthogonal basis for its span.\n            It is an intent(inout) argument. R : real or complex rank-2 array. On exit, its contains the upper triangular\n            matrix resulting from the QR factorization. It is an intent(out) argument. perm ( optional )   :   Rank-1 array of integer corresponding to the indices of\n                            permuted columns. If perm is absent, the naive QR factorization\n                            is being computed. In is an optional intent(in) argument. info : integer information flag. tol ( optional )    :   Numerical tolerance to determine whether two vectors are colinear\n                            or not. It is an optional intent(in) argument. Default tol = atol_sp or tol = atol_dp . Subroutines private module subroutine qr_no_pivoting_cdp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol private module subroutine qr_no_pivoting_csp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol private module subroutine qr_no_pivoting_rdp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol private module subroutine qr_no_pivoting_rsp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol private module subroutine qr_with_pivoting_cdp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol private module subroutine qr_with_pivoting_csp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol private module subroutine qr_with_pivoting_rdp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol private module subroutine qr_with_pivoting_rsp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol","tags":"","url":"interface/qr.html"},{"title":"check_info – LightKrylov","text":"public  subroutine check_info(info, origin, module, procedure, info_msg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: info Informaion flag character(len=*), intent(in) :: origin The name of the subroutine from which the flag originates character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens character(len=*), intent(in), optional :: info_msg Source Code subroutine check_info ( info , origin , module , procedure , info_msg ) integer , intent ( in ) :: info !! Informaion flag character ( len =* ), intent ( in ) :: origin !! The name of the subroutine from which the flag originates character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens character ( len =* ), optional , intent ( in ) :: info_msg character ( len = 128 ) :: str !! Optional extra message ! internals character ( len = 256 ) :: msg integer :: ierr str = optval ( info_msg , '' ) ierr = 0 if ( info == 0 ) then ! Successful exit --> only log on debug write ( msg , '(A)' ) 'The subroutine \"' // trim ( origin ) // '\" returned successfully. ' // trim ( str ) call log_debug ( trim ( msg ), module = module , procedure = procedure ) else ! !   LAPACK ! if ( trim ( to_lower ( origin )) == 'getref' ) then ! GETREF if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A,I0,A,I0,A)' ) \"U(\" , info , \",\" , info , \") is exactly zero. The factorization \" , & & \"has been completed but the factor U is exactly singular. \" , & & \"Division by zero will occur if used to solve Ax=b. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'getri' ) then ! GETRI if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A,I0,A)' ) \"U(\" , info , \",\" , info , \") is exactly zero. \" , & & \"The matrix is singular and its inverse cannot be computed. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'geev' ) then ! GEEV if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A,I0,A)' ) \"The QR alg. failed to compute all of the eigenvalues.\" , & & \"No eigenvector has been computed. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'syev' ) then ! SYEV if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"The QR alg. failed to compute all of the eigenvalues.\" , & & \"No eigenvector has been computed. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'heev' ) then ! HEEV if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"The QR alg. failed to compute all of the eigenvalues.\" , & & \"No eigenvector has been computed. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'gels' ) then ! GELS if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'gees' ) then ! GEES if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"The QR alg. failed to compute all of the eigenvalues.\" , & & \"No eigenvector has been computed. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'trsen' ) then ! GEES if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else if ( info == 1 ) then write ( msg , '(A)' ) \"The reordering of T failed because some eigenvalues are too\" , & & \"close to separate (the problem is very ill-conditioned); \" , & & \"T may have been partially reordered, and WR and WI \" , & & \"contain the eigenvalues in the same order as in T; S and\" , & & \"SEP (if requested) are set to zero. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if ! !   LightKrylov_Utils ! else if ( trim ( to_lower ( origin )) == 'sqrtm' ) then if ( info == 1 ) then write ( msg , '(A)' ) 'The input matrix is singular to tolerance. The singular eigenvalues are set to zero. ' call log_warning ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) \"The input matrix is not positive (semi-)definite. \" call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if ! !   LightKrylov_BaseKrylov ! else if ( trim ( to_lower ( origin )) == 'orthogonalize_against_basis' ) then ! the regular case ! orthogonalization if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Orthogonalization: The ' , info , 'th input vector is numerically zero.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) 'The input Krylov basis is not orthonormal.' call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else if ( info == - 2 ) then write ( msg , '(A)' ) 'Orthogonalization: The last column of the input basis is zero.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'orthogonalize_against_basis_p1' ) then ! orthogonalization if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Orthogonalization: The ' , info , 'th input vector is numerically zero.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) 'The input Krylov basis is not orthonormal.' call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else if ( info == - 2 ) then write ( msg , '(A)' ) 'Orthogonalization: The last column of the input basis is zero.' call log_warning ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'orthogonalize_against_basis_p2' ) then ! orthogonalization if ( info > 0 ) then ! show this information only for debugging write ( msg , '(A,I0,A)' ) 'Orthogonalization: The ' , info , 'th input vector is numerically zero.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) 'The input Krylov basis is not orthonormal.' call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else if ( info == - 2 ) then write ( msg , '(A)' ) 'Orthogonalization: The last column of the input basis is zero.' call log_warning ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'double_gram_schmidt_step' ) then ! orthogonalization if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Orthogonalization: The ' , info , 'th input vector is numerically zero.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) 'The input Krylov basis is not orthonormal.' call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else if ( info == - 2 ) then write ( msg , '(A)' ) 'Orthogonalization: The last column of the input basis is zero.' call log_warning ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'qr' ) then ! qr if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'QR factorization: Colinear column detected in column ' , info , & & '. NOTE: Other subsequent columns may also be colinear.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'qr_pivot' ) then ! qr_pivot if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'QR factorization: Invariant subspace found after ' , info , ' steps.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'arnoldi' ) then ! arnoldi if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Arnoldi factorization: Invariant subspace computed after ' , info , ' iterations.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'bidiagonalization' ) then ! lanczos_bidiagonalization if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Lanczos Bidiagonalisation: Invariant subspace found after ' , info , ' steps.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'lanczos' ) then ! lanczos_tridiagonalization if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Lanczos Tridiagonalisation: Invariant subspace found after ' , info , ' steps.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if ! !   LightKrylov_IterativeSolvers ! else if ( trim ( to_lower ( origin )) == 'eigs' ) then ! GMRES if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'eigs iteration converged after ' , info , ' iterations' call log_information ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'eighs' ) then ! GMRES if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'eigs iteration converged after ' , info , ' iterations' call log_information ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'svds' ) then ! GMRES if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'svds iteration converged after ' , info , ' iterations' call log_information ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'gmres' ) then ! GMRES if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'GMRES iteration converged after ' , info , ' iterations' call log_message ( trim ( msg ), module = module , procedure = procedure ) else if ( info < 0 ) then write ( msg , '(A,I0,A)' ) 'Maximum number of GMRES iterations reached (' , abs ( info ), & & '). Solution tolerance not achieved.' call log_message ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'fgmres' ) then ! GMRES if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'FGMRES iteration converged after ' , info , ' iterations' call log_message ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'cg' ) then ! CG if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'CG iteration converged after ' , info , ' iterations' call log_message ( trim ( msg ), module = module , procedure = procedure ) else if ( info < 0 ) then write ( msg , '(A,I0,A)' ) 'Maximum number of CG iterations reached (' , abs ( info ), & & '). Solution tolerance not achieved.' call log_message ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'linear_solver' ) then ! Abstract linear solver if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'The linear solver converged after ' , info , ' iterations' call log_message ( trim ( msg ), module = module , procedure = procedure ) else if ( info < 0 ) then write ( msg , '(A,I0,A)' ) 'Maximum number of iterations reached (' , abs ( info ), & & '). Solution tolerance not achieved.' call log_message ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if ! !   LightKrylov_ExpmLib ! else if ( trim ( to_lower ( origin )) == 'kexpm' ) then ! Krylov Matrix Exponential if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'kexpm converged. Estimated error below tolerance using ' , info , ' Krylov vectors.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 2 ) then write ( msg , '(A)' ) 'kexpm converged. Arnoldi iteration breakdown. Approximation is exact to arnoldi tolerance.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) 'kexpm did not converge. Maximum number of Krylov vectors reached.' call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if ! !  stop error ! else if ( trim ( origin ) == 'STOP_ERROR' ) then call log_error ( trim ( origin ), module = module , procedure = procedure , stat = info , errmsg = trim ( str )) ierr = - 1 ! !   Default ! else write ( msg , '(A)' ) 'subroutine \"' // trim ( origin ) // '\" returned with a non-zero error flag.' call log_error ( trim ( msg ), module = module , procedure = procedure , stat = info , errmsg = trim ( str )) ierr = - 1 end if end if ! info /= 0 call error_handler ( ierr ) end subroutine check_info","tags":"","url":"proc/check_info.html"},{"title":"comm_close – LightKrylov","text":"public  subroutine comm_close() Arguments None Source Code subroutine comm_close () integer :: ierr #ifdef MPI character ( len = 128 ) :: msg ! Finalize MPI call MPI_Finalize ( ierr ) if ( ierr /= MPI_SUCCESS ) call stop_error ( \"Error finalizing MPI\" , this_module , 'comm_close' ) #else ierr = 0 #endif end subroutine comm_close","tags":"","url":"proc/comm_close.html"},{"title":"comm_setup – LightKrylov","text":"public  subroutine comm_setup() Arguments None Source Code subroutine comm_setup () ! internal character ( len =* ), parameter :: this_procedure = 'comm_setup' character ( len = 128 ) :: msg #ifdef MPI integer :: ierr , rank_local , size_local logical :: mpi_is_initialized call MPI_Initialized ( mpi_is_initialized , ierr ) if (. not . mpi_is_initialized ) then call MPI_Init ( ierr ) if ( ierr /= MPI_SUCCESS ) call stop_error ( \"Error initializing MPI\" , this_module , this_procedure ) end if call MPI_Comm_rank ( MPI_COMM_WORLD , rank_local , ierr ) call MPI_Comm_size ( MPI_COMM_WORLD , size_local , ierr ) call set_rank ( rank_local ) call set_comm_size ( size_local ) if ( rank_local == 0 ) then call logger % log_message ( 'Setup parallel run' , this_module , this_procedure ) write ( msg , '(A,I0,A,I0)' ) 'comm_size = ' , size_local call logger % log_message ( trim ( msg ), this_module , this_procedure ) end if #else call set_rank ( 0 ) call set_comm_size ( 1 ) call logger % log_message ( 'Setup serial run' , this_module , this_procedure ) #endif end subroutine comm_setup","tags":"","url":"proc/comm_setup.html"},{"title":"log_debug – LightKrylov","text":"public  subroutine log_debug(msg, module, procedure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Log message to print character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens Source Code subroutine log_debug ( msg , module , procedure ) character ( len =* ), intent ( in ) :: msg !! Log message to print character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens if ( logger_is_active ) then if ( io_rank ()) then call logger % log_debug ( msg , module = module , procedure = procedure ) call flush_log_units () end if else print '(\"DEBUG: \",A)' , msg end if end subroutine log_debug","tags":"","url":"proc/log_debug.html"},{"title":"log_error – LightKrylov","text":"public  subroutine log_error(msg, module, procedure, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Log message to print character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens integer, intent(in), optional :: stat status message character(len=*), intent(in), optional :: errmsg error message Source Code subroutine log_error ( msg , module , procedure , stat , errmsg ) character ( len =* ), intent ( in ) :: msg !! Log message to print character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens integer , optional , intent ( in ) :: stat !! status message character ( len =* ), optional , intent ( in ) :: errmsg !! error message if ( logger_is_active ) then if ( io_rank ()) then call logger % log_error ( msg , module = module , procedure = procedure , stat = stat , errmsg = errmsg ) call flush_log_units () end if else print '(A,\": \",A)' , msg , errmsg end if end subroutine log_error","tags":"","url":"proc/log_error.html"},{"title":"log_information – LightKrylov","text":"public  subroutine log_information(msg, module, procedure, flush_log) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Log message to print character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens logical, intent(in), optional :: flush_log Flush the I/O buffer? Source Code subroutine log_information ( msg , module , procedure , flush_log ) character ( len =* ), intent ( in ) :: msg !! Log message to print character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens logical , optional , intent ( in ) :: flush_log !! Flush the I/O buffer? ! internal logical :: flush_ flush_ = optval ( flush_log , . true .) if ( logger_is_active ) then if ( io_rank ()) then call logger % log_information ( msg , module = module , procedure = procedure ) if ( flush_ ) call flush_log_units () end if else print '(\"INFO: \",A)' , msg end if end subroutine log_information","tags":"","url":"proc/log_information.html"},{"title":"log_message – LightKrylov","text":"public  subroutine log_message(msg, module, procedure, flush_log) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Log message to print character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens logical, intent(in), optional :: flush_log Flush the I/O buffer? Source Code subroutine log_message ( msg , module , procedure , flush_log ) character ( len =* ), intent ( in ) :: msg !! Log message to print character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens logical , optional , intent ( in ) :: flush_log !! Flush the I/O buffer? ! internal logical :: flush_ flush_ = optval ( flush_log , . true .) if ( logger_is_active ) then if ( io_rank ()) then call logger % log_message ( msg , module = module , procedure = procedure ) if ( flush_ ) call flush_log_units () end if else print '(A)' , msg end if end subroutine log_message","tags":"","url":"proc/log_message.html"},{"title":"log_warning – LightKrylov","text":"public  subroutine log_warning(msg, module, procedure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Log message to print character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens Source Code subroutine log_warning ( msg , module , procedure ) character ( len =* ), intent ( in ) :: msg !! Log message to print character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens if ( logger_is_active ) then if ( io_rank ()) then call logger % log_warning ( msg , module = module , procedure = procedure ) call flush_log_units () end if else print '(\"WARN: \",A)' , msg end if end subroutine log_warning","tags":"","url":"proc/log_warning.html"},{"title":"logger_setup – LightKrylov","text":"public  subroutine logger_setup(logfile, nio, log_level, log_stdout, log_timestamp, close_old, iunit) Wrapper to set up MPI if needed and initialize log files Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: logfile name of the dedicated LightKrylov logfile integer, intent(in), optional :: nio I/O rank for logging integer, intent(in), optional :: log_level set logging level\n0   : all_level\n10  : debug_level\n20  : information_level\n30  : warning_level\n40  : error_level\n100 : none_level logical, intent(in), optional :: log_stdout duplicate log messages to stdout? logical, intent(in), optional :: log_timestamp add timestamp to log messages logical, intent(in), optional :: close_old close previously opened logfiles (if present?) - stdout is not closed integer, intent(out), optional :: iunit log unit identifier Source Code subroutine logger_setup ( logfile , nio , log_level , log_stdout , log_timestamp , close_old , iunit ) !! Wrapper to set up MPI if needed and initialize log files character ( len =* ), optional , intent ( in ) :: logfile !! name of the dedicated LightKrylov logfile integer , optional , intent ( in ) :: nio !! I/O rank for logging integer , optional , intent ( in ) :: log_level !! set logging level !! 0   : all_level !! 10  : debug_level !! 20  : information_level !! 30  : warning_level !! 40  : error_level !! 100 : none_level logical , optional , intent ( in ) :: log_stdout !! duplicate log messages to stdout? logical , optional , intent ( in ) :: log_timestamp !! add timestamp to log messages logical , optional , intent ( in ) :: close_old !! close previously opened logfiles (if present?) - stdout is not closed integer , optional , intent ( out ) :: iunit !! log unit identifier ! internals character ( len =* ), parameter :: this_procedure = 'logger_setup' character ( len = :), allocatable :: logfile_ integer :: nio_ integer :: log_level_ logical :: log_stdout_ logical :: log_timestamp_ logical :: close_old_ integer :: iunit_ ! misc character ( len = 128 ) :: msg integer :: stat logfile_ = optval ( logfile , 'lightkrylov.log' ) nio_ = optval ( nio , 0 ) log_level_ = optval ( log_level , 20 ) log_level_ = max ( 0 , min ( log_level_ , 100 )) log_stdout_ = optval ( log_stdout , . true .) log_timestamp_ = optval ( log_timestamp , . true .) close_old_ = optval ( close_old , . true .) ! Set up comms call comm_setup () ! Set I/O rank if ( nio_ /= 0 ) call set_io_rank ( nio_ ) if ( io_rank ()) then write ( msg , '(A,I0,A,I0)' ) 'IO rank = ' , get_rank () call logger % log_message ( trim ( msg ), this_module , this_procedure ) end if if ( io_rank ()) then ! Flush log units if ( close_old_ ) call reset_log_units () ! set log level call logger % configure ( level = log_level_ , time_stamp = log_timestamp_ ) ! set up LightKrylov log file call logger % add_log_file ( logfile_ , unit = iunit_ , stat = stat ) if ( stat /= 0 ) call stop_error ( 'Unable to open logfile ' // trim ( logfile_ ) // '.' , this_module , this_procedure ) ! log to stdout if ( log_stdout_ ) then call logger % add_log_unit ( unit = 6 , stat = stat ) if ( stat /= 0 ) call stop_error ( 'Unable to add stdout to logger.' , this_module , this_procedure ) end if ! return unit if requested if ( present ( iunit )) iunit = iunit_ end if ! mark that logger is active logger_is_active = . true . end subroutine logger_setup","tags":"","url":"proc/logger_setup.html"},{"title":"stop_error – LightKrylov","text":"public  subroutine stop_error(msg, module, procedure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg The name of the procedure in which the call happens character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens Source Code subroutine stop_error ( msg , module , procedure ) character ( len =* ), intent ( in ) :: msg !! The name of the procedure in which the call happens character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens call check_info ( - 1 , origin = \"STOP_ERROR\" , module = module , procedure = procedure , info_msg = msg ) end subroutine stop_error","tags":"","url":"proc/stop_error.html"},{"title":"type_error – LightKrylov","text":"public  subroutine type_error(var, type, intent, module, procedure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Name of the variable character(len=*), intent(in) :: type Required type of the variable character(len=*), intent(in) :: intent Intent of the argument within the caller character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens Source Code subroutine type_error ( var , type , intent , module , procedure ) character ( len =* ), intent ( in ) :: var !! Name of the variable character ( len =* ), intent ( in ) :: type !! Required type of the variable character ( len =* ), intent ( in ) :: intent !! Intent of the argument within the caller character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens character ( len = 256 ) :: msg msg = \"The intent [\" // trim ( intent ) // \"] argument '\" // trim ( var ) // \"' must be of type '\" // trim ( type ) // \"'\" call stop_error ( msg , module = module , procedure = procedure ) end subroutine type_error","tags":"","url":"proc/type_error.html"},{"title":"write_results_cdp – LightKrylov","text":"public  subroutine write_results_cdp(filename, vals, res, tol) Prints the intermediate results of iterative eigenvalue/singular value decompositions Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Output filename. This file will be overwritten complex(kind=dp), intent(in) :: vals (:) Intermediate values real(kind=dp), intent(inout) :: res (:) Residuals real(kind=dp), intent(in) :: tol Convergence tolerance Source Code subroutine write_results_cdp ( filename , vals , res , tol ) !! Prints the intermediate results of iterative eigenvalue/singular value decompositions implicit none ( type , external ) character ( len =* ), intent ( in ) :: filename !! Output filename. This file will be overwritten complex ( dp ), intent ( in ) :: vals (:) !! Intermediate values real ( dp ), intent ( inout ) :: res (:) !! Residuals real ( dp ), intent ( in ) :: tol !! Convergence tolerance ! internals integer :: i , k , idx , iostat integer , allocatable :: indices (:) character ( len = 100 ) :: errmsg real ( dp ) :: modulus character ( len =* ), parameter :: fmt = '(I6,4(2X,E16.9),2X,L4)' k = size ( vals ) if ( io_rank ()) then ! only IO rank writes allocate ( indices ( k ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"write_results_cdp\" ) call sort_index ( res , indices ) ! res is returned in sorted order open ( 1234 , file = filename , status = 'replace' , action = 'write' ) write ( 1234 , '(A6,4(A18),A6)' ) 'Iter' , 'Re' , 'Im' , 'modulus' , 'residual' , 'conv' do i = 1 , k idx = indices ( i ) modulus = sqrt ( vals ( idx )% re ** 2 + vals ( idx )% im ** 2 ) write ( 1234 , fmt ) k , vals ( idx )% re , vals ( idx )% im , modulus , res ( i ), res ( i ) < tol end do close ( 1234 ) end if end subroutine write_results_cdp","tags":"","url":"proc/write_results_cdp.html"},{"title":"write_results_csp – LightKrylov","text":"public  subroutine write_results_csp(filename, vals, res, tol) Prints the intermediate results of iterative eigenvalue/singular value decompositions Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Output filename. This file will be overwritten complex(kind=sp), intent(in) :: vals (:) Intermediate values real(kind=sp), intent(inout) :: res (:) Residuals real(kind=sp), intent(in) :: tol Convergence tolerance Source Code subroutine write_results_csp ( filename , vals , res , tol ) !! Prints the intermediate results of iterative eigenvalue/singular value decompositions implicit none ( type , external ) character ( len =* ), intent ( in ) :: filename !! Output filename. This file will be overwritten complex ( sp ), intent ( in ) :: vals (:) !! Intermediate values real ( sp ), intent ( inout ) :: res (:) !! Residuals real ( sp ), intent ( in ) :: tol !! Convergence tolerance ! internals integer :: i , k , idx , iostat integer , allocatable :: indices (:) character ( len = 100 ) :: errmsg real ( sp ) :: modulus character ( len =* ), parameter :: fmt = '(I6,4(2X,E16.9),2X,L4)' k = size ( vals ) if ( io_rank ()) then ! only IO rank writes allocate ( indices ( k ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"write_results_csp\" ) call sort_index ( res , indices ) ! res is returned in sorted order open ( 1234 , file = filename , status = 'replace' , action = 'write' ) write ( 1234 , '(A6,4(A18),A6)' ) 'Iter' , 'Re' , 'Im' , 'modulus' , 'residual' , 'conv' do i = 1 , k idx = indices ( i ) modulus = sqrt ( vals ( idx )% re ** 2 + vals ( idx )% im ** 2 ) write ( 1234 , fmt ) k , vals ( idx )% re , vals ( idx )% im , modulus , res ( i ), res ( i ) < tol end do close ( 1234 ) end if end subroutine write_results_csp","tags":"","url":"proc/write_results_csp.html"},{"title":"write_results_rdp – LightKrylov","text":"public  subroutine write_results_rdp(filename, vals, res, tol) Prints the intermediate results of iterative eigenvalue/singular value decompositions Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Output filename. This file will be overwritten real(kind=dp), intent(in) :: vals (:) Intermediate values real(kind=dp), intent(inout) :: res (:) Residuals real(kind=dp), intent(in) :: tol Convergence tolerance Source Code subroutine write_results_rdp ( filename , vals , res , tol ) !! Prints the intermediate results of iterative eigenvalue/singular value decompositions implicit none ( type , external ) character ( len =* ), intent ( in ) :: filename !! Output filename. This file will be overwritten real ( dp ), intent ( in ) :: vals (:) !! Intermediate values real ( dp ), intent ( inout ) :: res (:) !! Residuals real ( dp ), intent ( in ) :: tol !! Convergence tolerance ! internals integer :: i , k , idx , iostat integer , allocatable :: indices (:) character ( len = 100 ) :: errmsg character ( len =* ), parameter :: fmt = '(I6,2(2X,E16.9),2X,L4)' k = size ( vals ) if ( io_rank ()) then ! only IO rank writes allocate ( indices ( k ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"write_results_rdp\" ) call sort_index ( res , indices ) ! res is returned in sorted order open ( 1234 , file = filename , status = 'replace' , action = 'write' ) write ( 1234 , '(A6,2(A18),A6)' ) 'Iter' , 'value' , 'residual' , 'conv' do i = 1 , k idx = indices ( i ) write ( 1234 , fmt ) k , vals ( idx ), res ( i ), res ( i ) < tol end do close ( 1234 ) end if end subroutine write_results_rdp","tags":"","url":"proc/write_results_rdp.html"},{"title":"write_results_rsp – LightKrylov","text":"public  subroutine write_results_rsp(filename, vals, res, tol) Prints the intermediate results of iterative eigenvalue/singular value decompositions Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Output filename. This file will be overwritten real(kind=sp), intent(in) :: vals (:) Intermediate values real(kind=sp), intent(inout) :: res (:) Residuals real(kind=sp), intent(in) :: tol Convergence tolerance Source Code subroutine write_results_rsp ( filename , vals , res , tol ) !! Prints the intermediate results of iterative eigenvalue/singular value decompositions implicit none ( type , external ) character ( len =* ), intent ( in ) :: filename !! Output filename. This file will be overwritten real ( sp ), intent ( in ) :: vals (:) !! Intermediate values real ( sp ), intent ( inout ) :: res (:) !! Residuals real ( sp ), intent ( in ) :: tol !! Convergence tolerance ! internals integer :: i , k , idx , iostat integer , allocatable :: indices (:) character ( len = 100 ) :: errmsg character ( len =* ), parameter :: fmt = '(I6,2(2X,E16.9),2X,L4)' k = size ( vals ) if ( io_rank ()) then ! only IO rank writes allocate ( indices ( k ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"write_results_rsp\" ) call sort_index ( res , indices ) ! res is returned in sorted order open ( 1234 , file = filename , status = 'replace' , action = 'write' ) write ( 1234 , '(A6,2(A18),A6)' ) 'Iter' , 'value' , 'residual' , 'conv' do i = 1 , k idx = indices ( i ) write ( 1234 , fmt ) k , vals ( idx ), res ( i ), res ( i ) < tol end do close ( 1234 ) end if end subroutine write_results_rsp","tags":"","url":"proc/write_results_rsp.html"},{"title":"cg – LightKrylov","text":"public interface cg Description Given a symmetric (positive definite) matrix , solves the linear system using the Conjugate Gradient method. References Hestenes, M. R., and Stiefel, E. (1952). \"Methods of Conjugate Gradients for Solving\nLinear Systems,\" Journal of Research of the National Bureau of Standards,\n49(6), 409–436. Syntax call cg ( A , b , x , info [, rtol ] [, atol ] [, preconditioner ] [, options ]) Arguments A :   Linear operator derived from one of the abstract_sym_linop or abstract_hermitian_linop types provided by the AbstractLinops module. It is an intent(inout) argument. b :   Right-hand side vector derived from one the abstract_vector types provided\n            by the AbstractVectors module. It needs to have the same type and kind as A .\n            It is an intent(in) argument. x :   On entry, initial guess for the solution. On exit, the solution computed by\n            cg. It is a vector derived from one the abstract_vector types provided by the AbstractVectors module. It needs to have the same type and kind as A . It is\n            an intent(inout) argument. info : integer information flag. rtol (optional) : real relative tolerance for the solver. atol (optional) : real absolute tolerance for the solver. preconditioner (optional)   :   Right preconditioner used to solve the system. It needs to be \n                                    consistent with the abstract_preconditioner interface. \n                                    It is an optional intent(in) argument. options (optional)  :   Container for the gmres options given by the cg_opts type.\n                            It is an optional intent(in) argument. Subroutines private module subroutine cg_cdp(A, b, x, info, rtol, atol, preconditioner, options, meta) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine cg_csp(A, b, x, info, rtol, atol, preconditioner, options, meta) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine cg_rdp(A, b, x, info, rtol, atol, preconditioner, options, meta) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine cg_rsp(A, b, x, info, rtol, atol, preconditioner, options, meta) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. class( abstract_metadata ), intent(out), optional :: meta Metadata.","tags":"","url":"interface/cg.html"},{"title":"eighs – LightKrylov","text":"public interface eighs Description Computes the leading eigenpairs of a symmetric operator using the \nLanczos iterative process. Given a square linear operator , it finds\nthe leading eigvalues and eigvectors such that: The subspace is constructed via Lanczos factorization, resulting in a symmetric\ntridiagonal matrix . The eigenvalues of are approximated by those of and the eigenvectors are computed accordingly. References Lanczos, C. (1950). \"An Iteration Method for the Solution of the Eigenvalue Problem\nof Linear Differential and Integral Operators\". United States Governm. Press Office. Syntax call eighs ( A , X , eigvals , residuals , info [, kdim ] [, tolerance ]) Arguments A :   Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n            eigenpairs need to be computed. It is an intent(inout) argument. X :   Array of abstract_vectors with the same type and kind as A . On exit, it\n            contains the leading eigenvectors of A . Note that the dimension of X fixes\n            the number of eigenpairs computed. It is an intent(out) argument. eigvals :   Rank-1 array of real numbers. On exit, it contains the leading\n                eigenvalues of A . It is an intent(out) argument. residuals :   Rank-1 array of real numbers. On exit, it contains the residuals\n                    associated with each eigenpairs. It is an intent(out) argument. info : integer Information flag. kdim ( optional )   : integer , maximum dimension of the Krylov subspace used to\n                            approximate the leading eigenpairs. It is an optional intent(in) argument. By default, kdim = 4*size(X) . tolerance ( optional )  : real tolerance below which an eigenpair is considered as\n                                being converged. It is an optional intent(in) argument. By default, tolerance = rtol_sp or tolerance = rtol_dp . Note This implementation does not currently include an automatic restarting procedure\nsuch as krylov_schur for eigs . This is work in progress. Subroutines private module subroutine eighs_cdp(A, X, eigvals, residuals, info, x0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_cdp ), intent(out) :: X (:) Leading eigevectors of . real(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. class( abstract_vector_cdp ), intent(in), optional :: x0 Optional starting vector to generate the Krylov subspace. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine eighs_csp(A, X, eigvals, residuals, info, x0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_csp ), intent(out) :: X (:) Leading eigevectors of . real(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. class( abstract_vector_csp ), intent(in), optional :: x0 Optional starting vector to generate the Krylov subspace. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine eighs_rdp(A, X, eigvals, residuals, info, x0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rdp ), intent(out) :: X (:) Leading eigevectors of . real(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. class( abstract_vector_rdp ), intent(in), optional :: x0 Optional starting vector to generate the Krylov subspace. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine eighs_rsp(A, X, eigvals, residuals, info, x0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rsp ), intent(out) :: X (:) Leading eigevectors of . real(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. class( abstract_vector_rsp ), intent(in), optional :: x0 Optional starting vector to generate the Krylov subspace. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration?","tags":"","url":"interface/eighs.html"},{"title":"eigs – LightKrylov","text":"public interface eigs Description Computes the leading eigenpairs of a square linear operator using the Arnoldi iterative process. Given a square linear operator , it finds\nthe leading eigenvalues and eigenvectors such that: or The subspace is constructed via Arnoldi factorization, resulting in an upper\nHessenberg matrix . The eigenvalues of are approximated by those of and the eigenvectors are computed accordingly. References Arnoldi, W. E. (1951). \"The Principle of Minimized Iterations in the Solution of\n  the Matrix Eigenvalue Problem.\" Quarterly of Applied Mathematics, 9(1), 17–29. Syntax call eigs ( A , X , eigvals , residuals , info [, kdim ] [, select ] [, tolerance ] [, transpose ]) Arguments A :   Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n            eigenpairs need to be computed. It is an intent(inout) argument. X :   Array of abstract_vectors with the same type and kind as A . On exit, it\n            contains the leading eigenvectors of A . Note that the dimension of X fixes\n            the number of eigenpairs computed. It is an intent(out) argument. eigvals :   Rank-1 array of real numbers. On exit, it contains the leading\n                eigenvalues of A . It is an intent(out) argument. residuals :   Rank-1 array of real numbers. On exit, it contains the residuals\n                    associated with each eigenpairs. It is an intent(out) argument. info : integer Information flag. kdim ( optional )   : integer , maximum dimension of the Krylov subspace used to\n                            approximate the leading eigenpairs. It is an optional intent(in) argument. By default, kdim = 4*size(X) . select ( optional ) : Function to select which eigenvalues to compute. tolerance ( optional )  : real tolerance below which an eigenpair is considered as\n                                being converged. It is an optional intent(in) argument.\n                                By default, tolerance = rtol_sp or tolerance = rtol_dp . transpose ( optional )  : logical flag determining whether the eigenvalues of or need to be computed. It is an optional intent(in) argument. Module Procedures private  subroutine eigs_rsp(A, X, eigvals, residuals, info, x0, kdim, tolerance, transpose, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rsp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_rsp ), intent(in), optional :: x0 Optional starting vector for generating the Krylov subspace. integer, intent(in), optional :: kdim Maximum dimension of the Krylov subspace (optional). real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private  subroutine eigs_rdp(A, X, eigvals, residuals, info, x0, kdim, tolerance, transpose, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rdp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_rdp ), intent(in), optional :: x0 Optional starting vector for generating the Krylov subspace. integer, intent(in), optional :: kdim Maximum dimension of the Krylov subspace (optional). real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private  subroutine eigs_csp(A, X, eigvals, residuals, info, x0, kdim, tolerance, transpose, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_csp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_csp ), intent(in), optional :: x0 Optional starting vector for generating the Krylov subspace. integer, intent(in), optional :: kdim Maximum dimension of the Krylov subspace (optional). real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private  subroutine eigs_cdp(A, X, eigvals, residuals, info, x0, kdim, tolerance, transpose, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_cdp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_cdp ), intent(in), optional :: x0 Optional starting vector for generating the Krylov subspace. integer, intent(in), optional :: kdim Maximum dimension of the Krylov subspace (optional). real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration?","tags":"","url":"interface/eigs.html"},{"title":"fgmres – LightKrylov","text":"public interface fgmres Description Solve a square linear system of equations using the Flexible Generalized Minimum RESidual (FGMRES) method. References Saad Y. and Schultz M. H. \"GMRES: A generalized minimal residual algorithm for\nsolving nonsymmetric linear systems.\" SIAM Journal on Scientific and Statistical\nComputing, 7(3), 1986. Syntax call fgmres ( A , b , x , info [, rtol ] [, atol ] [, preconditioner ] [, options ] [, transpose ]) Arguments A :   Linear operator derived from one of the abstract_linop types provided by the AbstractLinops module. It is an intent(inout) argument. b :   Right-hand side vector derived from one the abstract_vector types provided\n            by the AbstractVectors module. It needs to have the same type and kind as A .\n            It is an intent(in) argument. x :   On entry, initial guess for the solution. On exit, the solution computed by\n            gmres. It is a vector derived from one the abstract_vector types provided by the AbstractVectors module. It needs to have the same type and kind as A . It is\n            an intent(inout) argument. info : integer information flag. rtol (optional) : real relative tolerance for the solver. atol (optional) : real absolute tolerance for the solver. preconditioner (optional)   :   Right preconditioner used to solve the system. It needs to be \n                                    consistent with the abstract_preconditioner interface. \n                                    It is an optional intent(in) argument. options (optional)  :   Container for the gmres options given by the gmres_opts type.\n                            It is an optional intent(in) argument. transpose (optional): logical flag controlling whether or is being solved. Subroutines private module subroutine dense_fgmres_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Linear operator to be inverted. complex(kind=dp), intent(in) :: b (:) Right-hand side vector. complex(kind=dp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_fgmres_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Linear operator to be inverted. complex(kind=sp), intent(in) :: b (:) Right-hand side vector. complex(kind=sp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_fgmres_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Linear operator to be inverted. real(kind=dp), intent(in) :: b (:) Right-hand side vector. real(kind=dp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_fgmres_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Linear operator to be inverted. real(kind=sp), intent(in) :: b (:) Right-hand side vector. real(kind=sp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine fgmres_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine fgmres_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine fgmres_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine fgmres_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata.","tags":"","url":"interface/fgmres.html"},{"title":"gmres – LightKrylov","text":"public interface gmres Description Solve a square linear system of equations using the Generalized Minimum RESidual (GMRES) method. References Saad Y. and Schultz M. H. \"GMRES: A generalized minimal residual algorithm for\nsolving nonsymmetric linear systems.\" SIAM Journal on Scientific and Statistical\nComputing, 7(3), 1986. Syntax call gmres ( A , b , x , info [, rtol ] [, atol ] [, preconditioner ] [, options ] [, transpose ]) Arguments A :   Linear operator derived from one of the abstract_linop types provided by the AbstractLinops module. It is an intent(inout) argument. b :   Right-hand side vector derived from one the abstract_vector types provided\n            by the AbstractVectors module. It needs to have the same type and kind as A .\n            It is an intent(in) argument. x :   On entry, initial guess for the solution. On exit, the solution computed by\n            gmres. It is a vector derived from one the abstract_vector types provided by the AbstractVectors module. It needs to have the same type and kind as A . It is\n            an intent(inout) argument. info : integer information flag. rtol (optional) : real relative tolerance for the solver. atol (optional) : real absolute tolerance for the solver. preconditioner (optional)   :   Right preconditioner used to solve the system. It needs\n                                    to be consistent with the abstract_preconditioner interface.\n                                    It is an optional intent(in) argument. options (optional)  :   Container for the gmres options given by the gmres_opts type.\n                            It is an optional intent(in) argument. transpose (optional): logical flag controlling whether or is being solved. meta (optional) :   Container for the gmres metadata. It needs to be of type gmres_metadata . Subroutines private module subroutine dense_gmres_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Linear operator to be inverted. complex(kind=dp), intent(in) :: b (:) Right-hand side vector. complex(kind=dp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_gmres_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Linear operator to be inverted. complex(kind=sp), intent(in) :: b (:) Right-hand side vector. complex(kind=sp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_gmres_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Linear operator to be inverted. real(kind=dp), intent(in) :: b (:) Right-hand side vector. real(kind=dp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_gmres_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Linear operator to be inverted. real(kind=sp), intent(in) :: b (:) Right-hand side vector. real(kind=sp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine gmres_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine gmres_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine gmres_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine gmres_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata.","tags":"","url":"interface/gmres.html"},{"title":"save_eigenspectrum – LightKrylov","text":"public interface save_eigenspectrum Description Utility function to save the eigenspectrum computed from the Arnoldi factorization.\nIt outpost a .npy file. Syntax call save_eigenspectrum ( eigvals , residuals , fname ) Arguments eigvals : complex rank-1 array containing the eigenvalues. It is an intent(in) argument. residuals : real rank-1 array containing the residuals associated to each\n                    eigenvalues. It is an intent(in) argument. fname : Name of the file to save the eigenspectrum. It is an intent(in) argument. Subroutines private module subroutine save_eigenspectrum_cdp(lambda, residuals, fname) Implementation → Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: lambda (:) Eigenalues. real(kind=dp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. private module subroutine save_eigenspectrum_csp(lambda, residuals, fname) Implementation → Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: lambda (:) Eigenalues. real(kind=sp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. private module subroutine save_eigenspectrum_rdp(lambda, residuals, fname) Implementation → Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda (:) Eigenalues. real(kind=dp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. private module subroutine save_eigenspectrum_rsp(lambda, residuals, fname) Implementation → Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: lambda (:) Eigenalues. real(kind=sp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file.","tags":"","url":"interface/save_eigenspectrum.html"},{"title":"svds – LightKrylov","text":"public interface svds Description Computes the leading singular triplets of an arbitrary linear operator using the Lanczos iterative process. Given a linear operator , it finds\nthe leading singular values and singular vectors such that: The subspaces and are constructed via Lanczos factorization, resulting in\na bidiagonal matrix . The singular values of are approximated by those of and the singular vectors are computed accordingly. References Golub, G. H., & Kahan, W. (1965). \"Calculating the Singular Values and\n Pseudo-Inverse of a Matrix.\" Baglama, J., & Reichel, L. (2005). \"Augmented implicitly restarted Lanczos\n bidiagonalization methods.\" R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\"\n Technical Report, 1998. Syntax call svds ( A , U , S , V , residuals , info [, kdim ] [, tolerance ]) Arguments A :   Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n            eigenpairs need to be computed. It is an intent(inout) argument. U :   Array of abstract_vectors with the same type and kind as A . On exit, it\n            contains the left singular vectors of A . Note that the dimension of U fixes\n            the number of eigenpairs computed. It is an intent(out) argument. S :   Rank-1 array of real numbers. On exit, it contains the leading\n            singular values of A . It is an intent(out) argument. V :   Array of abstract_vectors with the same type and kind as A . On exit, it\n            contains the left singular vectors of A . Note that the dimension of U fixes\n            the number of eigenpairs computed. It is an intent(out) argument. residuals :   Rank-1 array of real numbers. On exit, it contains the residuals\n                    associated with each singular triplet. It is an intent(out) argument. info : integer Information flag. kdim ( optional )   : integer , maximum dimension of the Krylov subspace used to\n                            approximate the leading singular triplets. It is an optional intent(in) argument. By default, kdim = 4*size(X) . tolerance ( optional )  : real tolerance below which a triplet is considered as being converged. It is an\n                                optional intent(in) argument. By default, tolerance = rtol_sp or tolerance = rtol_dp`. Note This implementation does not currently include an automatic restarting procedure\nsuch as krylov_schur for eigs . This is work in progress. Subroutines private module subroutine svds_cdp(A, U, S, V, residuals, info, u0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_cdp ), intent(out) :: U (:) Leading left singular vectors. real(kind=dp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_cdp ), intent(out) :: V (:) Leading right singular vectors. real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_cdp ), intent(in), optional :: u0 integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine svds_csp(A, U, S, V, residuals, info, u0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_csp ), intent(out) :: U (:) Leading left singular vectors. real(kind=sp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_csp ), intent(out) :: V (:) Leading right singular vectors. real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_csp ), intent(in), optional :: u0 integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine svds_rdp(A, U, S, V, residuals, info, u0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_rdp ), intent(out) :: U (:) Leading left singular vectors. real(kind=dp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_rdp ), intent(out) :: V (:) Leading right singular vectors. real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_rdp ), intent(in), optional :: u0 integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine svds_rsp(A, U, S, V, residuals, info, u0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_rsp ), intent(out) :: U (:) Leading left singular vectors. real(kind=sp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_rsp ), intent(out) :: V (:) Leading right singular vectors. real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_rsp ), intent(in), optional :: u0 integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration?","tags":"","url":"interface/svds.html"},{"title":"adjoint – LightKrylov","text":"public interface adjoint Module Procedures private  function initialize_adjoint_rsp(A) result(B) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Return Value class( adjoint_linop_rsp ), allocatable private  function initialize_adjoint_rdp(A) result(B) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Return Value class( adjoint_linop_rdp ), allocatable private  function initialize_adjoint_csp(A) result(B) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Return Value class( adjoint_linop_csp ), allocatable private  function initialize_adjoint_cdp(A) result(B) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Return Value class( adjoint_linop_cdp ), allocatable","tags":"","url":"interface/adjoint.html"},{"title":"dense_linop – LightKrylov","text":"public interface dense_linop Module Procedures private  function initialize_dense_linop_from_array_rsp(A) result(linop) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value type( dense_linop_rsp ) private  function initialize_dense_linop_from_array_rdp(A) result(linop) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value type( dense_linop_rdp ) private  function initialize_dense_linop_from_array_csp(A) result(linop) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value type( dense_linop_csp ) private  function initialize_dense_linop_from_array_cdp(A) result(linop) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value type( dense_linop_cdp )","tags":"","url":"interface/dense_linop.html"},{"title":"apply_givens_rotation – LightKrylov","text":"public interface apply_givens_rotation Subroutines private pure module subroutine apply_givens_rotation_cdp(h, c, s) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), target, contiguous :: h (:) k-th column of the Hessenberg matrix. complex(kind=dp), intent(inout) :: c (:) Cosine components of the Givens rotations. complex(kind=dp), intent(inout) :: s (:) Sine components of the Givens rotations. private pure module subroutine apply_givens_rotation_csp(h, c, s) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout), target, contiguous :: h (:) k-th column of the Hessenberg matrix. complex(kind=sp), intent(inout) :: c (:) Cosine components of the Givens rotations. complex(kind=sp), intent(inout) :: s (:) Sine components of the Givens rotations. private pure module subroutine apply_givens_rotation_rdp(h, c, s) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), target, contiguous :: h (:) k-th column of the Hessenberg matrix. real(kind=dp), intent(inout) :: c (:) Cosine components of the Givens rotations. real(kind=dp), intent(inout) :: s (:) Sine components of the Givens rotations. private pure module subroutine apply_givens_rotation_rsp(h, c, s) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), target, contiguous :: h (:) k-th column of the Hessenberg matrix. real(kind=sp), intent(inout) :: c (:) Cosine components of the Givens rotations. real(kind=sp), intent(inout) :: s (:) Sine components of the Givens rotations.","tags":"","url":"interface/apply_givens_rotation.html"},{"title":"assert_shape – LightKrylov","text":"public interface assert_shape This interface provides methods to assert tha thte shape of its input vector or\nmatrix is as expected. It throws an error if not. Subroutines private module subroutine assert_shape_matrix_cdp(A, size, matname, module, procedure) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: size (:) character(len=*), intent(in) :: matname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_matrix_csp(A, size, matname, module, procedure) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: size (:) character(len=*), intent(in) :: matname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_matrix_rdp(A, size, matname, module, procedure) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: size (:) character(len=*), intent(in) :: matname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_matrix_rsp(A, size, matname, module, procedure) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: size (:) character(len=*), intent(in) :: matname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_vector_cdp(v, size, vecname, module, procedure) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) integer, intent(in) :: size (:) character(len=*), intent(in) :: vecname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_vector_csp(v, size, vecname, module, procedure) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) integer, intent(in) :: size (:) character(len=*), intent(in) :: vecname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_vector_rdp(v, size, vecname, module, procedure) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) integer, intent(in) :: size (:) character(len=*), intent(in) :: vecname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_vector_rsp(v, size, vecname, module, procedure) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) integer, intent(in) :: size (:) character(len=*), intent(in) :: vecname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure","tags":"","url":"interface/assert_shape.html"},{"title":"check_allocation – LightKrylov","text":"interface public module subroutine check_allocation(iostat, msg, module, procedure) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iostat character(len=*), intent(in) :: msg character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure","tags":"","url":"interface/check_allocation.html"},{"title":"eig – LightKrylov","text":"public interface eig Computes the eigenvalue decomposition of a general square matrix. Description This interface provides methods to compute the solution to the eigenproblem , where $\\mathbf{A}$ is a square real or complex matrix. Result array lambda returns the eigenvalues of , while vecs returns the corresponding eigenvectors. Note that it follows the LAPACK convention\nwhen is real . The solver is based on LAPACK's *GEEV backends. Syntax call eig(A, vecs, lambda) Arguments A : real or complex square array containing the coefficient matrix. It is an intent(in) argument. vecs : Square array of the same size, type, and kind as A containing the eigenvectors\n(following LAPACK's convention for real matrices). It is an intent(out) argument. lambda : complex rank-1 array of the same kind as A containing the eigenvalues.\nIt is an intent(out) argument. Note Due to the abstrct nature of the vector types defined in LightKrylov , it is unlikely\nthat this implementation will be superseeded in favor of the stdlib one as the latter\ndoes not follow the LAPACK's convention. Subroutines private module subroutine eig_cdp(A, vecs, vals) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) complex(kind=dp), intent(out) :: vecs (:,:) complex(kind=dp), intent(out) :: vals (:) private module subroutine eig_csp(A, vecs, vals) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) complex(kind=sp), intent(out) :: vecs (:,:) complex(kind=sp), intent(out) :: vals (:) private module subroutine eig_rdp(A, vecs, vals) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: vecs (:,:) complex(kind=dp), intent(out) :: vals (:) private module subroutine eig_rsp(A, vecs, vals) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(out) :: vecs (:,:) complex(kind=sp), intent(out) :: vals (:)","tags":"","url":"interface/eig.html"},{"title":"givens_rotation – LightKrylov","text":"public interface givens_rotation Functions private pure module function givens_rotation_cdp(x) result(g) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (2) Vector whose second entry needs to be eliminated. Return Value complex(kind=dp), (2) Entries of the Givens rotation matrix. private pure module function givens_rotation_csp(x) result(g) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (2) Vector whose second entry needs to be eliminated. Return Value complex(kind=sp), (2) Entries of the Givens rotation matrix. private pure module function givens_rotation_rdp(x) result(g) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (2) Vector whose second entry needs to be eliminated. Return Value real(kind=dp), (2) Entries of the Givens rotation matrix. private pure module function givens_rotation_rsp(x) result(g) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (2) Vector whose second entry needs to be eliminated. Return Value real(kind=sp), (2) Entries of the Givens rotation matrix.","tags":"","url":"interface/givens_rotation.html"},{"title":"log2 – LightKrylov","text":"public interface log2 Utility function to compute the base-2 logarithm of a real number. Functions private elemental module function log2_rdp(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private elemental module function log2_rsp(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp)","tags":"","url":"interface/log2.html"},{"title":"ordschur – LightKrylov","text":"public interface ordschur Given the Schur factorization and basis of a matrix, reorders it to have the selected\neigenvalues in the upper left block. Description This interface provides methods to re-order the Schur factorization of a real or complex square matrix. Note that, if is real , it returns the\nreal Schur form. Syntax call ordschur(T, Q, selected) Arguments T : real or complex square array containing the Schur factorization of a matrix. \nOn exit, it is overwritten with its re-ordered counterpart. It is an intent(inout) argument. Q : Two-dimensional square array of the same size, type and kind as A . It contains\nthe original Schur basis on entry and the re-ordered one on exit.\nIt is an intent(inout) argument. selected : logical rank-1 array selecting which eigenvalues need to be moved in the\nupper left block of the Schur factorization. It is an intent(in) arguement. Subroutines private module subroutine ordschur_cdp(T, Q, selected) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: T (:,:) complex(kind=dp), intent(inout) :: Q (:,:) logical, intent(in) :: selected (:) private module subroutine ordschur_csp(T, Q, selected) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: T (:,:) complex(kind=sp), intent(inout) :: Q (:,:) logical, intent(in) :: selected (:) private module subroutine ordschur_rdp(T, Q, selected) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: T (:,:) real(kind=dp), intent(inout) :: Q (:,:) logical, intent(in) :: selected (:) private module subroutine ordschur_rsp(T, Q, selected) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: T (:,:) real(kind=sp), intent(inout) :: Q (:,:) logical, intent(in) :: selected (:)","tags":"","url":"interface/ordschur.html"},{"title":"sqrtm – LightKrylov","text":"public interface sqrtm Computes the non-negative square root of a symmetric positive definite matrix\nusing its singular value decomposition. Description This interface provides methods to compute the non-negative square root of a symmetric\n(hermitian) positive definite matrix . Syntax call sqrtm(A, sqrtmA, info) Arguments A : Symmetric (hermitian) positive definite matrix whose non-negative square root\nneeds to be computed. It is an intent(in) argument. sqrtmA : Non-negative square root of A . It has the same size, kind and type as A .\nIt is an intent(out) argument. info : Information flag. It is an intent(out) argument. Subroutines private module subroutine sqrtm_cdp(A, sqrtA, info) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: A (:,:) complex(kind=dp), intent(out) :: sqrtA (:,:) integer, intent(out) :: info private module subroutine sqrtm_csp(A, sqrtA, info) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: A (:,:) complex(kind=sp), intent(out) :: sqrtA (:,:) integer, intent(out) :: info private module subroutine sqrtm_rdp(A, sqrtA, info) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (:,:) real(kind=dp), intent(out) :: sqrtA (:,:) integer, intent(out) :: info private module subroutine sqrtm_rsp(A, sqrtA, info) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: A (:,:) real(kind=sp), intent(out) :: sqrtA (:,:) integer, intent(out) :: info","tags":"","url":"interface/sqrtm.html"},{"title":"get_state_cdp – LightKrylov","text":"public  subroutine get_state_cdp(state, X, Y, z) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: state real(kind=dp), intent(out) :: X real(kind=dp), intent(out) :: Y real(kind=dp), intent(out) :: z Source Code subroutine get_state_cdp ( state , X , Y , Z ) class ( abstract_vector_cdp ), intent ( in ) :: state real ( dp ), intent ( out ) :: X , Y , z select type ( state ) type is ( state_vector_cdp ) X = state % x Y = state % y Z = state % z class default call type_error ( 'state' , 'state_vector_cdp' , 'IN' , this_module , 'get_state_cdp' ) end select end subroutine get_state_cdp","tags":"","url":"proc/get_state_cdp.html"},{"title":"get_state_csp – LightKrylov","text":"public  subroutine get_state_csp(state, X, Y, z) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: state real(kind=sp), intent(out) :: X real(kind=sp), intent(out) :: Y real(kind=sp), intent(out) :: z Source Code subroutine get_state_csp ( state , X , Y , Z ) class ( abstract_vector_csp ), intent ( in ) :: state real ( sp ), intent ( out ) :: X , Y , z select type ( state ) type is ( state_vector_csp ) X = state % x Y = state % y Z = state % z class default call type_error ( 'state' , 'state_vector_csp' , 'IN' , this_module , 'get_state_csp' ) end select end subroutine get_state_csp","tags":"","url":"proc/get_state_csp.html"},{"title":"get_state_rdp – LightKrylov","text":"public  subroutine get_state_rdp(state, X, Y, z) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: state real(kind=dp), intent(out) :: X real(kind=dp), intent(out) :: Y real(kind=dp), intent(out) :: z Source Code subroutine get_state_rdp ( state , X , Y , Z ) class ( abstract_vector_rdp ), intent ( in ) :: state real ( dp ), intent ( out ) :: X , Y , z select type ( state ) type is ( state_vector_rdp ) X = state % x Y = state % y Z = state % z class default call type_error ( 'state' , 'state_vector_rdp' , 'IN' , this_module , 'get_state_rdp' ) end select end subroutine get_state_rdp","tags":"","url":"proc/get_state_rdp.html"},{"title":"get_state_rsp – LightKrylov","text":"public  subroutine get_state_rsp(state, X, Y, z) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: state real(kind=sp), intent(out) :: X real(kind=sp), intent(out) :: Y real(kind=sp), intent(out) :: z Source Code subroutine get_state_rsp ( state , X , Y , Z ) class ( abstract_vector_rsp ), intent ( in ) :: state real ( sp ), intent ( out ) :: X , Y , z select type ( state ) type is ( state_vector_rsp ) X = state % x Y = state % y Z = state % z class default call type_error ( 'state' , 'state_vector_rsp' , 'IN' , this_module , 'get_state_rsp' ) end select end subroutine get_state_rsp","tags":"","url":"proc/get_state_rsp.html"},{"title":"roessler_analytical_fp_cdp – LightKrylov","text":"public  subroutine roessler_analytical_fp_cdp(fp1, fp2) Arguments Type Intent Optional Attributes Name class( state_vector_cdp ), intent(out) :: fp1 class( state_vector_cdp ), intent(out) :: fp2 Source Code subroutine roessler_analytical_fp_cdp ( fp1 , fp2 ) class ( state_vector_cdp ), intent ( out ) :: fp1 , fp2 complex ( dp ) :: d d = sqrt ( c_dp ** 2 - 4 * one_im_cdp * a_dp * b_dp ) fp1 % z = ( c_dp - d ) / ( 2 * one_im_cdp * a_dp ) fp1 % x = one_im_cdp * a_dp * fp1 % z fp1 % y = - one_im_cdp * fp1 % z fp2 % z = ( c_dp + d ) / ( 2 * one_im_cdp * a_dp ) fp2 % x = one_im_cdp * a_dp * fp2 % z fp2 % y = - one_im_cdp * fp2 % z end subroutine roessler_analytical_fp_cdp","tags":"","url":"proc/roessler_analytical_fp_cdp.html"},{"title":"roessler_analytical_fp_csp – LightKrylov","text":"public  subroutine roessler_analytical_fp_csp(fp1, fp2) Arguments Type Intent Optional Attributes Name class( state_vector_csp ), intent(out) :: fp1 class( state_vector_csp ), intent(out) :: fp2 Source Code subroutine roessler_analytical_fp_csp ( fp1 , fp2 ) class ( state_vector_csp ), intent ( out ) :: fp1 , fp2 complex ( sp ) :: d d = sqrt ( c_sp ** 2 - 4 * one_im_csp * a_sp * b_sp ) fp1 % z = ( c_sp - d ) / ( 2 * one_im_csp * a_sp ) fp1 % x = one_im_csp * a_sp * fp1 % z fp1 % y = - one_im_csp * fp1 % z fp2 % z = ( c_sp + d ) / ( 2 * one_im_csp * a_sp ) fp2 % x = one_im_csp * a_sp * fp2 % z fp2 % y = - one_im_csp * fp2 % z end subroutine roessler_analytical_fp_csp","tags":"","url":"proc/roessler_analytical_fp_csp.html"},{"title":"roessler_analytical_fp_rdp – LightKrylov","text":"public  subroutine roessler_analytical_fp_rdp(fp1, fp2) Arguments Type Intent Optional Attributes Name class( state_vector_rdp ), intent(out) :: fp1 class( state_vector_rdp ), intent(out) :: fp2 Source Code subroutine roessler_analytical_fp_rdp ( fp1 , fp2 ) class ( state_vector_rdp ), intent ( out ) :: fp1 , fp2 ! internal real ( dp ) :: d d = sqrt ( c_dp ** 2 - 4 * a_dp * b_dp ) fp1 % x = ( c_dp - d ) / 2 fp1 % y = ( - c_dp + d ) / ( 2 * a_dp ) fp1 % z = ( c_dp - d ) / ( 2 * a_dp ) fp2 % x = ( c_dp + d ) / 2 fp2 % y = ( - c_dp - d ) / ( 2 * a_dp ) fp2 % z = ( c_dp + d ) / ( 2 * a_dp ) end subroutine roessler_analytical_fp_rdp","tags":"","url":"proc/roessler_analytical_fp_rdp.html"},{"title":"roessler_analytical_fp_rsp – LightKrylov","text":"public  subroutine roessler_analytical_fp_rsp(fp1, fp2) Arguments Type Intent Optional Attributes Name class( state_vector_rsp ), intent(out) :: fp1 class( state_vector_rsp ), intent(out) :: fp2 Source Code subroutine roessler_analytical_fp_rsp ( fp1 , fp2 ) class ( state_vector_rsp ), intent ( out ) :: fp1 , fp2 ! internal real ( sp ) :: d d = sqrt ( c_sp ** 2 - 4 * a_sp * b_sp ) fp1 % x = ( c_sp - d ) / 2 fp1 % y = ( - c_sp + d ) / ( 2 * a_sp ) fp1 % z = ( c_sp - d ) / ( 2 * a_sp ) fp2 % x = ( c_sp + d ) / 2 fp2 % y = ( - c_sp - d ) / ( 2 * a_sp ) fp2 % z = ( c_sp + d ) / ( 2 * a_sp ) end subroutine roessler_analytical_fp_rsp","tags":"","url":"proc/roessler_analytical_fp_rsp.html"},{"title":"get_data – LightKrylov","text":"public interface get_data Module Procedures private  subroutine get_data_vec_rsp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: vec_out (:) type( vector_rsp ), intent(in) :: vec_in private  subroutine get_data_vec_basis_rsp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: basis_out (:,:) type( vector_rsp ), intent(in) :: basis_in (:) private  subroutine get_data_linop_rsp(mat_out, linop_in) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: mat_out (:,:) type( linop_rsp ), intent(in) :: linop_in private  subroutine get_data_vec_rdp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: vec_out (:) type( vector_rdp ), intent(in) :: vec_in private  subroutine get_data_vec_basis_rdp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: basis_out (:,:) type( vector_rdp ), intent(in) :: basis_in (:) private  subroutine get_data_linop_rdp(mat_out, linop_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: mat_out (:,:) type( linop_rdp ), intent(in) :: linop_in private  subroutine get_data_vec_csp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(out) :: vec_out (:) type( vector_csp ), intent(in) :: vec_in private  subroutine get_data_vec_basis_csp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(out) :: basis_out (:,:) type( vector_csp ), intent(in) :: basis_in (:) private  subroutine get_data_linop_csp(mat_out, linop_in) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(out) :: mat_out (:,:) type( linop_csp ), intent(in) :: linop_in private  subroutine get_data_vec_cdp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out) :: vec_out (:) type( vector_cdp ), intent(in) :: vec_in private  subroutine get_data_vec_basis_cdp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out) :: basis_out (:,:) type( vector_cdp ), intent(in) :: basis_in (:) private  subroutine get_data_linop_cdp(mat_out, linop_in) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out) :: mat_out (:,:) type( linop_cdp ), intent(in) :: linop_in","tags":"","url":"interface/get_data.html"},{"title":"get_err_str – LightKrylov","text":"public interface get_err_str Module Procedures private  subroutine get_err_str_sp(msg, info, err) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: msg character(len=*), intent(in) :: info real(kind=sp), intent(in) :: err private  subroutine get_err_str_dp(msg, info, err) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: msg character(len=*), intent(in) :: info real(kind=dp), intent(in) :: err","tags":"","url":"interface/get_err_str.html"},{"title":"hermitian_linop_cdp – LightKrylov","text":"public interface hermitian_linop_cdp Functions private module function construct_hermitian_linop_cdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( hermitian_linop_cdp )","tags":"","url":"interface/hermitian_linop_cdp.html"},{"title":"hermitian_linop_csp – LightKrylov","text":"public interface hermitian_linop_csp Functions private module function construct_hermitian_linop_csp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( hermitian_linop_csp )","tags":"","url":"interface/hermitian_linop_csp.html"},{"title":"init_rand – LightKrylov","text":"public interface init_rand Module Procedures private  subroutine init_rand_vec_rsp(x) Arguments Type Intent Optional Attributes Name type( vector_rsp ), intent(inout) :: x private  subroutine init_rand_basis_rsp(X) Arguments Type Intent Optional Attributes Name type( vector_rsp ), intent(inout) :: X (:) private  subroutine init_rand_linop_rsp(linop) Arguments Type Intent Optional Attributes Name type( linop_rsp ), intent(inout) :: linop private  subroutine init_rand_spd_linop_rsp(linop) Arguments Type Intent Optional Attributes Name type( spd_linop_rsp ), intent(inout) :: linop private  subroutine init_rand_vec_rdp(x) Arguments Type Intent Optional Attributes Name type( vector_rdp ), intent(inout) :: x private  subroutine init_rand_basis_rdp(X) Arguments Type Intent Optional Attributes Name type( vector_rdp ), intent(inout) :: X (:) private  subroutine init_rand_linop_rdp(linop) Arguments Type Intent Optional Attributes Name type( linop_rdp ), intent(inout) :: linop private  subroutine init_rand_spd_linop_rdp(linop) Arguments Type Intent Optional Attributes Name type( spd_linop_rdp ), intent(inout) :: linop private  subroutine init_rand_vec_csp(x) Arguments Type Intent Optional Attributes Name type( vector_csp ), intent(inout) :: x private  subroutine init_rand_basis_csp(X) Arguments Type Intent Optional Attributes Name type( vector_csp ), intent(inout) :: X (:) private  subroutine init_rand_linop_csp(linop) Arguments Type Intent Optional Attributes Name type( linop_csp ), intent(inout) :: linop private  subroutine init_rand_hermitian_linop_csp(linop) Arguments Type Intent Optional Attributes Name type( hermitian_linop_csp ), intent(inout) :: linop private  subroutine init_rand_vec_cdp(x) Arguments Type Intent Optional Attributes Name type( vector_cdp ), intent(inout) :: x private  subroutine init_rand_basis_cdp(X) Arguments Type Intent Optional Attributes Name type( vector_cdp ), intent(inout) :: X (:) private  subroutine init_rand_linop_cdp(linop) Arguments Type Intent Optional Attributes Name type( linop_cdp ), intent(inout) :: linop private  subroutine init_rand_hermitian_linop_cdp(linop) Arguments Type Intent Optional Attributes Name type( hermitian_linop_cdp ), intent(inout) :: linop","tags":"","url":"interface/init_rand.html"},{"title":"linop_cdp – LightKrylov","text":"public interface linop_cdp Functions private module function construct_linop_cdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_cdp )","tags":"","url":"interface/linop_cdp.html"},{"title":"linop_csp – LightKrylov","text":"public interface linop_csp Functions private module function construct_linop_csp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_csp )","tags":"","url":"interface/linop_csp.html"},{"title":"linop_rdp – LightKrylov","text":"public interface linop_rdp Functions private module function construct_linop_rdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_rdp )","tags":"","url":"interface/linop_rdp.html"},{"title":"linop_rsp – LightKrylov","text":"public interface linop_rsp Functions private module function construct_linop_rsp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_rsp )","tags":"","url":"interface/linop_rsp.html"},{"title":"put_data – LightKrylov","text":"public interface put_data Module Procedures private  subroutine put_data_vec_rsp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name type( vector_rsp ), intent(out) :: vec_out real(kind=sp), intent(in) :: vec_in private  subroutine put_data_vec_basis_rsp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name type( vector_rsp ), intent(out) :: basis_out (:) real(kind=sp), intent(in) :: basis_in (:,:) private  subroutine put_data_linop_rsp(linop_out, mat_in) Arguments Type Intent Optional Attributes Name type( linop_rsp ), intent(out) :: linop_out real(kind=sp), intent(in) :: mat_in (:,:) private  subroutine put_data_vec_rdp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name type( vector_rdp ), intent(out) :: vec_out real(kind=dp), intent(in) :: vec_in private  subroutine put_data_vec_basis_rdp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name type( vector_rdp ), intent(out) :: basis_out (:) real(kind=dp), intent(in) :: basis_in (:,:) private  subroutine put_data_linop_rdp(linop_out, mat_in) Arguments Type Intent Optional Attributes Name type( linop_rdp ), intent(out) :: linop_out real(kind=dp), intent(in) :: mat_in (:,:) private  subroutine put_data_vec_csp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name type( vector_csp ), intent(out) :: vec_out complex(kind=sp), intent(in) :: vec_in private  subroutine put_data_vec_basis_csp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name type( vector_csp ), intent(out) :: basis_out (:) complex(kind=sp), intent(in) :: basis_in (:,:) private  subroutine put_data_linop_csp(linop_out, mat_in) Arguments Type Intent Optional Attributes Name type( linop_csp ), intent(out) :: linop_out complex(kind=sp), intent(in) :: mat_in (:,:) private  subroutine put_data_vec_cdp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name type( vector_cdp ), intent(out) :: vec_out complex(kind=dp), intent(in) :: vec_in private  subroutine put_data_vec_basis_cdp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name type( vector_cdp ), intent(out) :: basis_out (:) complex(kind=dp), intent(in) :: basis_in (:,:) private  subroutine put_data_linop_cdp(linop_out, mat_in) Arguments Type Intent Optional Attributes Name type( linop_cdp ), intent(out) :: linop_out complex(kind=dp), intent(in) :: mat_in (:,:)","tags":"","url":"interface/put_data.html"},{"title":"spd_linop_rdp – LightKrylov","text":"public interface spd_linop_rdp Functions private module function construct_spd_linop_rdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( spd_linop_rdp )","tags":"","url":"interface/spd_linop_rdp.html"},{"title":"spd_linop_rsp – LightKrylov","text":"public interface spd_linop_rsp Functions private module function construct_spd_linop_rsp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( spd_linop_rsp )","tags":"","url":"interface/spd_linop_rsp.html"},{"title":"time_lightkrylov – LightKrylov","text":"public pure function time_lightkrylov() result(if_time_lightkrylov) Arguments None Return Value logical Source Code pure logical function time_lightkrylov () result ( if_time_lightkrylov ) if_time_lightkrylov = if_time end function time_lightkrylov","tags":"","url":"proc/time_lightkrylov.html"},{"title":"krylov_exptA_cdp – LightKrylov","text":"public  subroutine krylov_exptA_cdp(vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_cdp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? Source Code subroutine krylov_exptA_cdp ( vec_out , A , vec_in , tau , info , trans ) !! Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator !! on a vector that conforms to the `abstract_exptA_cdp` interface. implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_cdp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'krylov_exptA_cdp' real ( dp ) :: tol integer :: kdim tol = atol_dp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , this_module , this_procedure ) end subroutine krylov_exptA_cdp","tags":"","url":"proc/krylov_expta_cdp.html"},{"title":"krylov_exptA_csp – LightKrylov","text":"public  subroutine krylov_exptA_csp(vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_csp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: vec_out Solution vector. class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? Source Code subroutine krylov_exptA_csp ( vec_out , A , vec_in , tau , info , trans ) !! Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator !! on a vector that conforms to the `abstract_exptA_csp` interface. implicit none ( type , external ) class ( abstract_vector_csp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_csp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'krylov_exptA_csp' real ( sp ) :: tol integer :: kdim tol = atol_sp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , this_module , this_procedure ) end subroutine krylov_exptA_csp","tags":"","url":"proc/krylov_expta_csp.html"},{"title":"krylov_exptA_rdp – LightKrylov","text":"public  subroutine krylov_exptA_rdp(vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_rdp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? Source Code subroutine krylov_exptA_rdp ( vec_out , A , vec_in , tau , info , trans ) !! Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator !! on a vector that conforms to the `abstract_exptA_rdp` interface. implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rdp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'krylov_exptA_rdp' real ( dp ) :: tol integer :: kdim tol = atol_dp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , this_module , this_procedure ) end subroutine krylov_exptA_rdp","tags":"","url":"proc/krylov_expta_rdp.html"},{"title":"krylov_exptA_rsp – LightKrylov","text":"public  subroutine krylov_exptA_rsp(vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_rsp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? Source Code subroutine krylov_exptA_rsp ( vec_out , A , vec_in , tau , info , trans ) !! Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator !! on a vector that conforms to the `abstract_exptA_rsp` interface. implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rsp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'krylov_exptA_rsp' real ( sp ) :: tol integer :: kdim tol = atol_sp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , this_module , this_procedure ) end subroutine krylov_exptA_rsp","tags":"","url":"proc/krylov_expta_rsp.html"},{"title":"kexpm – LightKrylov","text":"public interface kexpm Description This interface provides methods to evaluate the matrix-vector product based on the Arnoldi method. Syntax call kexpm ( c , A , b , tau , tol , info [, trans ] [, kdim ]) Arguments c :   Output vector (or vectors). It is an intent(out) argument. A :   Linear operator to be exponentiated. It is an intent(inout) argument. b :   Vector to be multiplied by . It is an intent(in) argument. tau : real (singe or double) time over which the matrix exponential needs to\n            be computed. It is an intent(in) argument. info : integer Information flag. trans (optional)    :   Whether or is being used.\n                            (default trans=.false. ) kdim (optional)     :   Dimension of the Krylov subspace used in the Arnoldi method. Module Procedures private  subroutine kexpm_vec_rsp(c, A, b, tau, tol, info, trans, kdim) Best approximation of in the computed Krylov subspace Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: c class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: b Input vector on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_rsp(C, A, B, tau, tol, info, trans, kdim) Best Krylov approximation of in the computed Krylov subspace. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: C (:) class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_rdp(c, A, b, tau, tol, info, trans, kdim) Best approximation of in the computed Krylov subspace Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: c class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: b Input vector on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_rdp(C, A, B, tau, tol, info, trans, kdim) Best Krylov approximation of in the computed Krylov subspace. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: C (:) class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_csp(c, A, b, tau, tol, info, trans, kdim) Best approximation of in the computed Krylov subspace Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: c class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: b Input vector on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_csp(C, A, B, tau, tol, info, trans, kdim) Best Krylov approximation of in the computed Krylov subspace. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: C (:) class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_cdp(c, A, b, tau, tol, info, trans, kdim) Best approximation of in the computed Krylov subspace Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: c class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: b Input vector on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_cdp(C, A, B, tau, tol, info, trans, kdim) Best Krylov approximation of in the computed Krylov subspace. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: C (:) class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace.","tags":"","url":"interface/kexpm.html"},{"title":"krylov_exptA – LightKrylov","text":"public interface krylov_exptA Description Utility function to evaluate the matrix-exponential times vector. Syntax call k_exptA ( vec_out , A , vec_in , tau , info , trans ) Arguments vec_out :   Output vector. A :   Matrix to be exponentiated. vec_in :   Input vector. tau :   Integration time. info :   Information flag. trans :   Whether or is being used. Module Procedures public  subroutine krylov_exptA_rsp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_rsp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? public  subroutine krylov_exptA_rdp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_rdp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? public  subroutine krylov_exptA_csp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_csp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: vec_out Solution vector. class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? public  subroutine krylov_exptA_cdp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_cdp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ?","tags":"","url":"interface/krylov_expta.html"},{"title":"save_eigenspectrum_cdp – LightKrylov","text":"module procedure save_eigenspectrum_cdp private module subroutine save_eigenspectrum_cdp(lambda, residuals, fname) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: lambda (:) Eigenalues. real(kind=dp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. Source Code module subroutine save_eigenspectrum_cdp ( lambda , residuals , fname ) !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format. implicit none ( type , external ) complex ( dp ), intent ( in ) :: lambda (:) !! Eigenalues. real ( dp ), intent ( in ) :: residuals (:) !! Residual of the corresponding Ritz eigenpairs. character ( len =* ), intent ( in ) :: fname !! Name of the output file. end subroutine save_eigenspectrum_cdp","tags":"","url":"proc/save_eigenspectrum_cdp.html"},{"title":"save_eigenspectrum_csp – LightKrylov","text":"module procedure save_eigenspectrum_csp private module subroutine save_eigenspectrum_csp(lambda, residuals, fname) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: lambda (:) Eigenalues. real(kind=sp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. Source Code module subroutine save_eigenspectrum_csp ( lambda , residuals , fname ) !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format. implicit none ( type , external ) complex ( sp ), intent ( in ) :: lambda (:) !! Eigenalues. real ( sp ), intent ( in ) :: residuals (:) !! Residual of the corresponding Ritz eigenpairs. character ( len =* ), intent ( in ) :: fname !! Name of the output file. end subroutine save_eigenspectrum_csp","tags":"","url":"proc/save_eigenspectrum_csp.html"},{"title":"save_eigenspectrum_rdp – LightKrylov","text":"module procedure save_eigenspectrum_rdp private module subroutine save_eigenspectrum_rdp(lambda, residuals, fname) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda (:) Eigenalues. real(kind=dp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. Source Code module subroutine save_eigenspectrum_rdp ( lambda , residuals , fname ) !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format. implicit none ( type , external ) real ( dp ), intent ( in ) :: lambda (:) !! Eigenalues. real ( dp ), intent ( in ) :: residuals (:) !! Residual of the corresponding Ritz eigenpairs. character ( len =* ), intent ( in ) :: fname !! Name of the output file. end subroutine save_eigenspectrum_rdp","tags":"","url":"proc/save_eigenspectrum_rdp.html"},{"title":"save_eigenspectrum_rsp – LightKrylov","text":"module procedure save_eigenspectrum_rsp private module subroutine save_eigenspectrum_rsp(lambda, residuals, fname) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: lambda (:) Eigenalues. real(kind=sp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. Source Code module subroutine save_eigenspectrum_rsp ( lambda , residuals , fname ) !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format. implicit none ( type , external ) real ( sp ), intent ( in ) :: lambda (:) !! Eigenalues. real ( sp ), intent ( in ) :: residuals (:) !! Residual of the corresponding Ritz eigenpairs. character ( len =* ), intent ( in ) :: fname !! Name of the output file. end subroutine save_eigenspectrum_rsp","tags":"","url":"proc/save_eigenspectrum_rsp.html"},{"title":"construct_hermitian_linop_cdp – LightKrylov","text":"module procedure construct_hermitian_linop_cdp private module function construct_hermitian_linop_cdp(data) result(A) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( hermitian_linop_cdp ) Source Code module function construct_hermitian_linop_cdp ( data ) result ( A ) implicit none ( type , external ) complex ( dp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( hermitian_linop_cdp ) :: A end function construct_hermitian_linop_cdp","tags":"","url":"proc/construct_hermitian_linop_cdp.html"},{"title":"construct_hermitian_linop_csp – LightKrylov","text":"module procedure construct_hermitian_linop_csp private module function construct_hermitian_linop_csp(data) result(A) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( hermitian_linop_csp ) Source Code module function construct_hermitian_linop_csp ( data ) result ( A ) implicit none ( type , external ) complex ( sp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( hermitian_linop_csp ) :: A end function construct_hermitian_linop_csp","tags":"","url":"proc/construct_hermitian_linop_csp.html"},{"title":"construct_linop_cdp – LightKrylov","text":"module procedure construct_linop_cdp private module function construct_linop_cdp(data) result(A) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_cdp ) Source Code module function construct_linop_cdp ( data ) result ( A ) implicit none ( type , external ) complex ( dp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( linop_cdp ) :: A end function construct_linop_cdp","tags":"","url":"proc/construct_linop_cdp.html"},{"title":"construct_linop_csp – LightKrylov","text":"module procedure construct_linop_csp private module function construct_linop_csp(data) result(A) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_csp ) Source Code module function construct_linop_csp ( data ) result ( A ) implicit none ( type , external ) complex ( sp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( linop_csp ) :: A end function construct_linop_csp","tags":"","url":"proc/construct_linop_csp.html"},{"title":"construct_linop_rdp – LightKrylov","text":"module procedure construct_linop_rdp private module function construct_linop_rdp(data) result(A) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_rdp ) Source Code module function construct_linop_rdp ( data ) result ( A ) implicit none ( type , external ) real ( dp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( linop_rdp ) :: A end function construct_linop_rdp","tags":"","url":"proc/construct_linop_rdp.html"},{"title":"construct_linop_rsp – LightKrylov","text":"module procedure construct_linop_rsp private module function construct_linop_rsp(data) result(A) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_rsp ) Source Code module function construct_linop_rsp ( data ) result ( A ) implicit none ( type , external ) real ( sp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( linop_rsp ) :: A end function construct_linop_rsp","tags":"","url":"proc/construct_linop_rsp.html"},{"title":"construct_spd_linop_rdp – LightKrylov","text":"module procedure construct_spd_linop_rdp private module function construct_spd_linop_rdp(data) result(A) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( spd_linop_rdp ) Source Code module function construct_spd_linop_rdp ( data ) result ( A ) implicit none ( type , external ) real ( dp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( spd_linop_rdp ) :: A end function construct_spd_linop_rdp","tags":"","url":"proc/construct_spd_linop_rdp.html"},{"title":"construct_spd_linop_rsp – LightKrylov","text":"module procedure construct_spd_linop_rsp private module function construct_spd_linop_rsp(data) result(A) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( spd_linop_rsp ) Source Code module function construct_spd_linop_rsp ( data ) result ( A ) implicit none ( type , external ) real ( sp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( spd_linop_rsp ) :: A end function construct_spd_linop_rsp","tags":"","url":"proc/construct_spd_linop_rsp.html"},{"title":"LightKrylov_NewtonKrylov – LightKrylov","text":"Uses LightKrylov_IterativeSolvers LightKrylov_Logger LightKrylov_Timing LightKrylov_Utils LightKrylov_AbstractLinops stdlib_optval LightKrylov_AbstractVectors LightKrylov_AbstractSystems LightKrylov_Constants stdlib_strings Interfaces public        interface newton Implements the simple Newton-Krylov method for finding roots (fixed points) of a \nnonlinear vector-valued function , i.e. solutions such that starting from an \ninitial guess via successive solution increments based on local linearization (the Jacobian) of the nonlinear function in the \nvicinity of the current solution. Algorthmic Features At iteration , the standard Newton step is \n  computed as the solution of the linear system where is the residual of the nonlinear \n  function. The new guess for the fixed point is then given by: where parametrizes the step length. The \n  standard Newton algorithm sets . The Jacobian is never assembled and the linear system is solved using one of \n  the available iterative solvers. When the residual norm does not decrease during iteration indicating that the \n  linearization is not a very accurate model of the function's behaviour, which \n  often happens during the initial iterations, a 1D step bisection method based \n  on the golden ratio is implemented to dampen the step and improve convergence \n  of the method. The implementation allows for dynamic tolerances (also known as inexact Newton), \n  where the approximation for the residual and the linear system can be solved \n  with relaxed tolerances to reduce overall time to solution. The method is suitable to both fixed points and periodic orbits via the choice \n  of residual and corresponding Jacobian matrix. In the case of unforced periodic \n  orbits, the period is itself an unknown that must be included in the iteration. Advantages The iterative solution of the linear systems has a comparatively low storage \n  footprint. If the Newton iteration converges, the convergence is formally asymptotically \n  of second order. Using dynamic tolerances and line searches slightly reduce \n  this convergence rate in exchange for a larger convergence region. Limitations The method is not guaranteed to converge if the initial guess is too far from \n  the fixed point. If the Newton iteration diverges even with step bisection, \n  the best suggestion is to find a better initial guess. If this is not feasible, \n  some alternatives to improve the convergence of the Newton iteration are possible \n  (but not implemented to date), including various line search algorithms and trust \n  region methods (doglog, double dogleg, hookstep, ...). References Sánchez, J., Net, M., Garcıa-Archilla, B., & Simó, C. (2004). \"Newton–Krylov \n  continuation of periodic orbits for Navier–Stokes flows\". Journal of Computational \n  Physics, 201(1), 13-33. Viswanath, D. (2007). \"Recurrent motions within plane Couette turbulence\". \n  Journal of Fluid Mechanics, 580, 339-358. Duguet, Y., Pringle, C. C. T., Kerswell, R. R. (2008). \"Relative periodic orbits \n  in transitional pipe flow\". Physics  of Fluids, 20(11), 114102. Frantz, R. A., Loiseau, J. C., & Robinet, J. C. (2023). \"Krylov methods for \n  large-scale dynamical systems: Application in fluid dynamics\". Applied Mechanics\n  Reviews, 75(3), 030802. private  subroutine newton_rsp(sys, X, solver, info, rtol, atol, options, linear_solver_options, preconditioner, scheduler, meta) Arguments Type Intent Optional Attributes Name class( abstract_system_rsp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_rsp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_rsp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=sp), intent(in), optional :: rtol real(kind=sp), intent(in), optional :: atol type( newton_sp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_sp), optional :: scheduler class( abstract_metadata ), intent(out), optional :: meta Metadata. private  subroutine newton_rdp(sys, X, solver, info, rtol, atol, options, linear_solver_options, preconditioner, scheduler, meta) Arguments Type Intent Optional Attributes Name class( abstract_system_rdp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_rdp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_rdp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=dp), intent(in), optional :: rtol real(kind=dp), intent(in), optional :: atol type( newton_dp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_dp), optional :: scheduler class( abstract_metadata ), intent(out), optional :: meta Metadata. private  subroutine newton_csp(sys, X, solver, info, rtol, atol, options, linear_solver_options, preconditioner, scheduler, meta) Arguments Type Intent Optional Attributes Name class( abstract_system_csp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_csp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_csp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=sp), intent(in), optional :: rtol real(kind=sp), intent(in), optional :: atol type( newton_sp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_sp), optional :: scheduler class( abstract_metadata ), intent(out), optional :: meta Metadata. private  subroutine newton_cdp(sys, X, solver, info, rtol, atol, options, linear_solver_options, preconditioner, scheduler, meta) Arguments Type Intent Optional Attributes Name class( abstract_system_cdp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_cdp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_cdp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=dp), intent(in), optional :: rtol real(kind=dp), intent(in), optional :: atol type( newton_dp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_dp), optional :: scheduler class( abstract_metadata ), intent(out), optional :: meta Metadata. Derived Types type, public, extends( abstract_metadata ) :: newton_dp_metadata Metadata for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag integer, public :: eval_counter_record = 0 System response evaluation counter:\nN.B.: For each of these evals the current residual and tolerance are recorded. integer, public :: info = 0 Copy of the information flag for completeness logical, public :: input_is_fixed_point = .false. Flag indicating lucky convergence (Newton is not run and no solution is computed) integer, public :: n_iter = 0 Iteration counter real(kind=dp), public, dimension(:), allocatable :: res Residual history real(kind=dp), public, dimension(:), allocatable :: tol Tolerance history Type-Bound Procedures procedure, public, pass(self) :: print => print_newton_dp procedure, public, pass(self) :: record => record_data_dp procedure, public, pass(self) :: reset => reset_newton_dp type, public, extends( abstract_opts ) :: newton_dp_opts Options for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print interation metadata on exit (default = .false.) logical, public :: ifbisect = .false. Bisection toggle to enforce residual reduction (default = .false.) integer, public :: maxiter = 100 Maximum number of Newton iterations (default = 100) integer, public :: maxstep_bisection = 5 Maximum number of bisections (evaluations of F) for step selection (default = 5)\nIgnored if ifbisect = .false. type, public, extends( abstract_metadata ) :: newton_sp_metadata Metadata for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag integer, public :: eval_counter_record = 0 System response evaluation counter:\nN.B.: For each of these evals the current residual and tolerance are recorded. integer, public :: info = 0 Copy of the information flag for completeness logical, public :: input_is_fixed_point = .false. Flag indicating lucky convergence (Newton is not run and no solution is computed) integer, public :: n_iter = 0 Iteration counter real(kind=sp), public, dimension(:), allocatable :: res Residual history real(kind=sp), public, dimension(:), allocatable :: tol Tolerance history Type-Bound Procedures procedure, public, pass(self) :: print => print_newton_sp procedure, public, pass(self) :: record => record_data_sp procedure, public, pass(self) :: reset => reset_newton_sp type, public, extends( abstract_opts ) :: newton_sp_opts Options for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print interation metadata on exit (default = .false.) logical, public :: ifbisect = .false. Bisection toggle to enforce residual reduction (default = .false.) integer, public :: maxiter = 100 Maximum number of Newton iterations (default = 100) integer, public :: maxstep_bisection = 5 Maximum number of bisections (evaluations of F) for step selection (default = 5)\nIgnored if ifbisect = .false. Subroutines public  subroutine constant_tol_dp (tol, target_tol, rnorm, iter, info) Constant tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: tol Tolerance to be used real(kind=dp), intent(in) :: target_tol Target tolerance real(kind=dp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag public  subroutine constant_tol_sp (tol, target_tol, rnorm, iter, info) Constant tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: tol Tolerance to be used real(kind=sp), intent(in) :: target_tol Target tolerance real(kind=sp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag public  subroutine dynamic_tol_dp (tol, target_tol, rnorm, iter, info) Dynamic tolerance scheduler for the Newton iteration setting tol based on the current residual tol Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: tol Tolerance to be used real(kind=dp), intent(in) :: target_tol Target tolerance real(kind=dp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag public  subroutine dynamic_tol_sp (tol, target_tol, rnorm, iter, info) Dynamic tolerance scheduler for the Newton iteration setting tol based on the current residual tol Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: tol Tolerance to be used real(kind=sp), intent(in) :: target_tol Target tolerance real(kind=sp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag","tags":"","url":"module/lightkrylov_newtonkrylov.html"},{"title":"LightKrylov_AbstractVectors – LightKrylov","text":"This module provides the base class absract_vector from which all Krylov vectors\nneeds to be derived. To use LightKrylov , you need to extend one of the\nfollowings: abstract_vector_rsp :   Real-valued vector with single precision arithmetic. abstract_vector_rdp :   Real-valued vector with double precision arithmetic. abstract_vector_csp :   Complex-valued vector with single precision arithmetic. abstract_vector_cdp :   Complex-valued vector with double precision arithmetic. To extend either of these abstract types, you need to provide an associated implementation\nfor the following type-bound procedures: zero(self) :   A subroutine zeroing-out the vector. rand(self, ifnorm) :   A subroutine creating a random vector, possibily normalized to have unit-norm ( ifnorm = .true. ). scal(self, alpha) :   A subroutine computing in-place the scalar multiplication . `axpby(alpha, vec, beta, self) :   A subroutine computing in-place the product . dot(self, vec) :   A function computing the inner product . get_size(self) :   A function returning the dimension of the vector . Once these type-bound procedures have been implemented by the user, they will automatically \nbe used to define: vector addition    : add(self, vec) = axpby(1, vec, 1, self) vector subtraction : sub(self, vec) = axpby(-1, vec, 1, self) vector norm        : norm(self)     = sqrt(self%dot(self)) This module also provides the following utility subroutines: innerprod(X, Y) : Function computing the product between a Krylov basis X and a Krylov vector  (resp. basis) Y . linear_combination(Y, X, V) : Subroutine computing the linear combination . axpby_basis(alpha, X, beta, Y) : In-place computation of where X and Y are arrays of abstract_vector . zero_basis(X) : Zero-out a collection of abstract_vectors . copy_basis(out, from) : Copy a collection of abstract_vectors . rand_basis(X, ifnorm) : Create a collection of random abstract_vectors . If ifnorm = .true. , the vectors are normalized to have unit-norm. Warning The resulting vectors do not form an orthonormal basis. For this purpose use the utility function initialize_random_orthonormal_basis . Uses LightKrylov_Logger stdlib_linalg_blas LightKrylov_Utils stdlib_optval LightKrylov_Constants Interfaces public        interface Gram Compute the Gram matrix . Description This interface provides methods for computing the Gram matrix associated to a basis of abstract_vector . Example The example below assumes that you have already extended the abstract_vector_rdp class to define your own my_real_vector type. type ( my_real_vector ), dimension ( 10 ) :: X real ( dp ), dimension (:, :), allocatable :: G ! ... Part of your code where you initialize everything ... G = Gram ( X ) ! ... Rest of your code ... private  function gram_matrix_rsp(X) result(G) Computes the inner product/Gram matrix associated with the basis . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: X (:) Return Value real(kind=sp), (size(X),size(X)) private  function gram_matrix_rdp(X) result(G) Computes the inner product/Gram matrix associated with the basis . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: X (:) Return Value real(kind=dp), (size(X),size(X)) private  function gram_matrix_csp(X) result(G) Computes the inner product/Gram matrix associated with the basis . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: X (:) Return Value complex(kind=sp), (size(X),size(X)) private  function gram_matrix_cdp(X) result(G) Computes the inner product/Gram matrix associated with the basis . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: X (:) Return Value complex(kind=dp), (size(X),size(X)) public        interface axpby_basis In-place addition of two arrays of extended abstract_vector . Description This interface provides methods to add in-place two arrays of\nextended abstract_vector , i.e. No out-of-place alternative is currently available in LightKrylov .\nIf you do need an out-of-place version, you can combine axpby_basis with copy . Example type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y real ( dp ), dimension ( 10 ) :: alpha , beta ! ... Whatever your code is doing ... call axpby_basis ( alpha , X , beta , Y ) ! ... Rest of your code ... private impure elemental subroutine axpby_basis_rsp(alpha, X, beta, Y) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are real(sp)\nnumbers. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_rsp ), intent(in) :: X Input/Ouput array of abstract_vector . real(kind=sp), intent(in) :: beta Scalar multipliers. class( abstract_vector_rsp ), intent(inout) :: Y Array of abstract_vector to be added/subtracted to/from X . private impure elemental subroutine axpby_basis_rdp(alpha, X, beta, Y) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are real(dp)\nnumbers. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_rdp ), intent(in) :: X Input/Ouput array of abstract_vector . real(kind=dp), intent(in) :: beta Scalar multipliers. class( abstract_vector_rdp ), intent(inout) :: Y Array of abstract_vector to be added/subtracted to/from X . private impure elemental subroutine axpby_basis_csp(alpha, X, beta, Y) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are complex(sp)\nnumbers. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_csp ), intent(in) :: X Input/Ouput array of abstract_vector . complex(kind=sp), intent(in) :: beta Scalar multipliers. class( abstract_vector_csp ), intent(inout) :: Y Array of abstract_vector to be added/subtracted to/from X . private impure elemental subroutine axpby_basis_cdp(alpha, X, beta, Y) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are complex(dp)\nnumbers. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_cdp ), intent(in) :: X Input/Ouput array of abstract_vector . complex(kind=dp), intent(in) :: beta Scalar multipliers. class( abstract_vector_cdp ), intent(inout) :: Y Array of abstract_vector to be added/subtracted to/from X . public        interface copy This interface provides methods to copy an array X of abstract_vector into\nanother array Y . Note that Y needs to be pre-allocated. Example type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y ! ... Your code ... call copy ( Y , X ) ! ... Your code ... private impure elemental subroutine copy_vector_rsp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: out class( abstract_vector_rsp ), intent(in) :: from private impure elemental subroutine copy_vector_rdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: out class( abstract_vector_rdp ), intent(in) :: from private impure elemental subroutine copy_vector_csp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: out class( abstract_vector_csp ), intent(in) :: from private impure elemental subroutine copy_vector_cdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: out class( abstract_vector_cdp ), intent(in) :: from public        interface dense_vector private  function initialize_dense_vector_from_array_rsp(x) result(vec) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value type( dense_vector_rsp ) private  function initialize_dense_vector_from_array_rdp(x) result(vec) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value type( dense_vector_rdp ) private  function initialize_dense_vector_from_array_csp(x) result(vec) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value type( dense_vector_csp ) private  function initialize_dense_vector_from_array_cdp(x) result(vec) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value type( dense_vector_cdp ) public        interface innerprod Compute the inner product vector or matrix . Description This interface provides methods for computing the inner products between a basis\nof real or complex vectors and a single vector or another basis . Depending on the case, it\nreturns a one-dimensional array or a two-dimensional array with the same type as . Example The example below assumes that you have already extended the abstract_vector_rdp class to define your own my_real_vector type. type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ) :: y real ( dp ), dimension (:), allocatable :: v ! ... Part of your code where you initialize everything ... v = innerprod ( X , y ) ! ... Rest of your code ... Similarly, for computing the matrix of inner products between two bases type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y real ( dp ), dimension (:, :), allocatable :: M ! ... Part of your code where you initialize everything ... M = innerprod ( X , Y ) ! ... Rest of your code ... private  function innerprod_vector_rsp(X, v) result(y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: X (:) Basis and single instance of abstract_vector whose inner products need to be computed. class( abstract_vector_rsp ), intent(in) :: v Basis and single instance of abstract_vector whose inner products need to be computed. Return Value real(kind=sp), (size(X)) Resulting inner-product vector. private  function innerprod_matrix_rsp(X, Y) result(M) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rsp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. Return Value real(kind=sp), (size(X),size(Y)) Resulting inner-product matrix. private  function innerprod_vector_rdp(X, v) result(y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: X (:) Basis and single instance of abstract_vector whose inner products need to be computed. class( abstract_vector_rdp ), intent(in) :: v Basis and single instance of abstract_vector whose inner products need to be computed. Return Value real(kind=dp), (size(X)) Resulting inner-product vector. private  function innerprod_matrix_rdp(X, Y) result(M) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rdp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. Return Value real(kind=dp), (size(X),size(Y)) Resulting inner-product matrix. private  function innerprod_vector_csp(X, v) result(y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: X (:) Basis and single instance of abstract_vector whose inner products need to be computed. class( abstract_vector_csp ), intent(in) :: v Basis and single instance of abstract_vector whose inner products need to be computed. Return Value complex(kind=sp), (size(X)) Resulting inner-product vector. private  function innerprod_matrix_csp(X, Y) result(M) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_csp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. Return Value complex(kind=sp), (size(X),size(Y)) Resulting inner-product matrix. private  function innerprod_vector_cdp(X, v) result(y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: X (:) Basis and single instance of abstract_vector whose inner products need to be computed. class( abstract_vector_cdp ), intent(in) :: v Basis and single instance of abstract_vector whose inner products need to be computed. Return Value complex(kind=dp), (size(X)) Resulting inner-product vector. private  function innerprod_matrix_cdp(X, Y) result(M) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_cdp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. Return Value complex(kind=dp), (size(X),size(Y)) Resulting inner-product matrix. public        interface linear_combination Given a set of extended abstract_vectors and coefficients, return the corresponding\nlinear combinations. Description This interface provides methods for computing linear combinations of a set of abstract_vectors . Depending on its input, it either computes i.e. a single vector, or i.e. a set of vectors of the same type as . Example type ( my_real_vector ), dimension ( 10 ) :: X real ( dp ), dimension ( m , n ) :: B type ( my_real_vector ) :: Y ! ... Whatever your code is doing ... call linear_combination ( Y , X , B ) ! ... Rest of your code ... private  subroutine linear_combination_vector_rsp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_rsp ), intent(in) :: X (:) Krylov basis. real(kind=sp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_rsp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_rsp ), intent(in) :: X (:) Krylov basis. real(kind=sp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_rdp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_rdp ), intent(in) :: X (:) Krylov basis. real(kind=dp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_rdp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_rdp ), intent(in) :: X (:) Krylov basis. real(kind=dp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_csp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_csp ), intent(in) :: X (:) Krylov basis. complex(kind=sp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_csp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_csp ), intent(in) :: X (:) Krylov basis. complex(kind=sp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_cdp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_cdp ), intent(in) :: X (:) Krylov basis. complex(kind=dp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_cdp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_cdp ), intent(in) :: X (:) Krylov basis. complex(kind=dp), intent(in) :: B (:,:) Coefficients of the linear combinations. public        interface rand_basis This interface provides methods to create an array X of random abstract_vector .\nIt is a simple wrapper around X(i)%rand(ifnorm) . Example type ( my_real_vector ), dimension ( 10 ) :: X logical :: ifnorm = . true . ! ... Your code ... call rand_basis ( X , ifnorm ) ! ... Your code ... private impure elemental subroutine rand_basis_rsp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X logical, intent(in), optional :: ifnorm private impure elemental subroutine rand_basis_rdp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X logical, intent(in), optional :: ifnorm private impure elemental subroutine rand_basis_csp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X logical, intent(in), optional :: ifnorm private impure elemental subroutine rand_basis_cdp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X logical, intent(in), optional :: ifnorm public        interface zero_basis This interface provides methods to zero-out a collection of abstract_vector X .\nIt is a simple wrapper around X(i)%zero() . Example type ( my_real_vector ), dimension ( 10 ) :: X ! ... Your code ... call zero_basis ( X ) ! ... Your code ... private impure elemental subroutine zero_basis_rsp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X private impure elemental subroutine zero_basis_rdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X private impure elemental subroutine zero_basis_csp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X private impure elemental subroutine zero_basis_cdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X Derived Types type, public, abstract :: abstract_vector Base abstract type from which all other types of vectors used in LightKrylov are being derived from. Read more… type, public, abstract, extends( abstract_vector ) :: abstract_vector_cdp Abstract type to define complex(dp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_cdp Adds two abstract_vector , i.e. . procedure(abstract_axpby_cdp), public, deferred, pass(self) :: axpby In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_cdp Change the sign of a vector, i.e. . procedure(abstract_dot_cdp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_cdp . procedure(abstract_get_size_cdp), public, deferred, pass(self) :: get_size Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_cdp Computes the norm of the abstract_vector . procedure(abstract_rand_cdp), public, deferred, pass(self) :: rand Creates a random abstract_vector_cdp . procedure(abstract_scal_cdp), public, deferred, pass(self) :: scal Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_cdp Subtracts two abstract_vector , i.e. . procedure(abstract_zero_cdp), public, deferred, pass(self) :: zero Sets an abstract_vector_cdp to zero. type, public, abstract, extends( abstract_vector ) :: abstract_vector_csp Abstract type to define complex(sp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_csp Adds two abstract_vector , i.e. . procedure(abstract_axpby_csp), public, deferred, pass(self) :: axpby In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_csp Change the sign of a vector, i.e. . procedure(abstract_dot_csp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_csp . procedure(abstract_get_size_csp), public, deferred, pass(self) :: get_size Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_csp Computes the norm of the abstract_vector . procedure(abstract_rand_csp), public, deferred, pass(self) :: rand Creates a random abstract_vector_csp . procedure(abstract_scal_csp), public, deferred, pass(self) :: scal Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_csp Subtracts two abstract_vector , i.e. . procedure(abstract_zero_csp), public, deferred, pass(self) :: zero Sets an abstract_vector_csp to zero. type, public, abstract, extends( abstract_vector ) :: abstract_vector_rdp Abstract type to define real(dp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_rdp Adds two abstract_vector , i.e. . procedure(abstract_axpby_rdp), public, deferred, pass(self) :: axpby In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_rdp Change the sign of a vector, i.e. . procedure(abstract_dot_rdp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_rdp . procedure(abstract_get_size_rdp), public, deferred, pass(self) :: get_size Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_rdp Computes the norm of the abstract_vector . procedure(abstract_rand_rdp), public, deferred, pass(self) :: rand Creates a random abstract_vector_rdp . procedure(abstract_scal_rdp), public, deferred, pass(self) :: scal Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_rdp Subtracts two abstract_vector , i.e. . procedure(abstract_zero_rdp), public, deferred, pass(self) :: zero Sets an abstract_vector_rdp to zero. type, public, abstract, extends( abstract_vector ) :: abstract_vector_rsp Abstract type to define real(sp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_rsp Adds two abstract_vector , i.e. . procedure(abstract_axpby_rsp), public, deferred, pass(self) :: axpby In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_rsp Change the sign of a vector, i.e. . procedure(abstract_dot_rsp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_rsp . procedure(abstract_get_size_rsp), public, deferred, pass(self) :: get_size Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_rsp Computes the norm of the abstract_vector . procedure(abstract_rand_rsp), public, deferred, pass(self) :: rand Creates a random abstract_vector_rsp . procedure(abstract_scal_rsp), public, deferred, pass(self) :: scal Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_rsp Subtracts two abstract_vector , i.e. . procedure(abstract_zero_rsp), public, deferred, pass(self) :: zero Sets an abstract_vector_rsp to zero. type, public, extends( abstract_vector_cdp ) :: dense_vector_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: data (:) integer, public :: n Type-Bound Procedures procedure, public, pass(self) :: add => add_cdp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => dense_axpby_cdp In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_cdp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dense_dot_cdp Computes the dot product between two abstract_vector_cdp . procedure, public, pass(self) :: get_size => dense_get_size_cdp Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_cdp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => dense_rand_cdp Creates a random abstract_vector_cdp . procedure, public, pass(self) :: scal => dense_scal_cdp Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_cdp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => dense_zero_cdp Sets an abstract_vector_cdp to zero. type, public, extends( abstract_vector_csp ) :: dense_vector_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public, allocatable :: data (:) integer, public :: n Type-Bound Procedures procedure, public, pass(self) :: add => add_csp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => dense_axpby_csp In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_csp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dense_dot_csp Computes the dot product between two abstract_vector_csp . procedure, public, pass(self) :: get_size => dense_get_size_csp Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_csp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => dense_rand_csp Creates a random abstract_vector_csp . procedure, public, pass(self) :: scal => dense_scal_csp Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_csp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => dense_zero_csp Sets an abstract_vector_csp to zero. type, public, extends( abstract_vector_rdp ) :: dense_vector_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: data (:) integer, public :: n Type-Bound Procedures procedure, public, pass(self) :: add => add_rdp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => dense_axpby_rdp In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_rdp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dense_dot_rdp Computes the dot product between two abstract_vector_rdp . procedure, public, pass(self) :: get_size => dense_get_size_rdp Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_rdp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => dense_rand_rdp Creates a random abstract_vector_rdp . procedure, public, pass(self) :: scal => dense_scal_rdp Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_rdp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => dense_zero_rdp Sets an abstract_vector_rdp to zero. type, public, extends( abstract_vector_rsp ) :: dense_vector_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public, allocatable :: data (:) integer, public :: n Type-Bound Procedures procedure, public, pass(self) :: add => add_rsp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => dense_axpby_rsp In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_rsp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dense_dot_rsp Computes the dot product between two abstract_vector_rsp . procedure, public, pass(self) :: get_size => dense_get_size_rsp Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_rsp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => dense_rand_rsp Creates a random abstract_vector_rsp . procedure, public, pass(self) :: scal => dense_scal_rsp Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_rsp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => dense_zero_rsp Sets an abstract_vector_rsp to zero.","tags":"","url":"module/lightkrylov_abstractvectors.html"},{"title":"LightKrylov_Constants – LightKrylov","text":"This module defines a list of simple constants used throughout LightKrylov .\nIt also provides some utility functions related to let LightKrylov be aware\nof any MPI-related information (e.g. rank of the current MPI process, dimension\nof the MPI communicator, etc). Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: atol_dp = 10.0_dp**(-precision(1.0_dp)) Absolute tolerance for double precision computations. real(kind=sp), public, parameter :: atol_sp = 10.0_sp**(-precision(1.0_sp)) Absolute tolerance for single precision computations. integer, public, parameter :: dp = selected_real_kind(15, 307) Double precision data type. complex(kind=dp), public, parameter :: one_cdp = cmplx(1.0_dp, 0.0_dp, kind=dp) Complex-valued double precision one. complex(kind=sp), public, parameter :: one_csp = cmplx(1.0_sp, 0.0_sp, kind=sp) Complex-valued single precision one. complex(kind=dp), public, parameter :: one_im_cdp = cmplx(0.0_dp, 1.0_dp, kind=dp) Complex-valued double precision imaginary unit. complex(kind=sp), public, parameter :: one_im_csp = cmplx(0.0_sp, 1.0_sp, kind=sp) Complex-valued single precision imaginary unit. real(kind=dp), public, parameter :: one_rdp = 1.0_dp Real-valued double precision one. real(kind=sp), public, parameter :: one_rsp = 1.0_sp Real-valued single precision one. real(kind=dp), public, parameter :: rtol_dp = sqrt(atol_dp) Relative tolerance for double precision computations. real(kind=sp), public, parameter :: rtol_sp = sqrt(atol_sp) Relative tolerance for single precision computations. integer, public, parameter :: sp = selected_real_kind(6, 37) Single precision data type. complex(kind=dp), public, parameter :: zero_cdp = cmplx(0.0_dp, 0.0_dp, kind=dp) Complex-valued double precision zero. complex(kind=sp), public, parameter :: zero_csp = cmplx(0.0_sp, 0.0_sp, kind=sp) Complex-value single precision zero. real(kind=dp), public, parameter :: zero_rdp = 0.0_dp Real-valued double precision zero. real(kind=sp), public, parameter :: zero_rsp = 0.0_sp Real-valued single precision zero. Functions public pure function get_comm_size () result(c_size) Utility function to get the dimension of the communicator known to LightKrylov . Arguments None Return Value integer public pure function get_rank () result(rank) Utility function to get the rank of the current MPI process. Arguments None Return Value integer public pure function io_rank () result(is_io) Utility function to determine whether the current MPI process can do I/O. Arguments None Return Value logical Subroutines public  subroutine set_comm_size (c_size) Utility function to inform LightKrylov of the MPI-communicator's dimension. Arguments Type Intent Optional Attributes Name integer, intent(in) :: c_size Dimension of the MPI communicator. public  subroutine set_io_rank (rk) Utility function to set the rank of the process doing I/O. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rk Desired rank for the IO process. public  subroutine set_rank (rank) Utility function to set the rank of an MPI process. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank Desired rank identification.","tags":"","url":"module/lightkrylov_constants.html"},{"title":"LightKrylov – LightKrylov","text":"Uses LightKrylov_IterativeSolvers LightKrylov_Timing LightKrylov_ExpmLib LightKrylov_Utils LightKrylov_NewtonKrylov LightKrylov_Timer_Utils LightKrylov_AbstractLinops LightKrylov_BaseKrylov LightKrylov_AbstractVectors LightKrylov_AbstractSystems LightKrylov_Constants Subroutines public  subroutine greetings () Arguments None","tags":"","url":"module/lightkrylov.html"},{"title":"LightKrylov_BaseKrylov – LightKrylov","text":"This module provides a collection of Krylov-based factorizations forming the\ncomputational core of LightKrylov . It also provides a set of utility functions\nto operate on arrays of abstract_vector . The most important ones are: arnoldi(A, X, H, info) : Arnoldi factorization for general square matrices. lanczos(A, X, H, info) : Lanczos factorization for general symmetric/hermitian matrices. bidiagonalization(A, U, V, B) : Lanczos bidiagonalization for arbitrary matrices. qr(X, R, perm, info) : QR factorization (with and without column pivoting) of an array of abstract_vector . Uses LightKrylov_Logger LightKrylov_Timing LightKrylov_Utils stdlib_linalg LightKrylov_AbstractLinops stdlib_optval LightKrylov_AbstractVectors LightKrylov_Constants Used by Descendants: arnoldi_method golub_kahan_methods gram_schmidt_process krylov_utilities lanczos_methods qr_solvers Interfaces public        interface arnoldi Description Given a square linear operator , find matrices and such that where is an orthogonal basis and is upper Hessenberg. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis via the Gram-Schmidt process. Constructs an upper Hessenberg matrix whose eigenvalues approximates those of . Checks for convergence and invariant subspaces. References Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003.\n  see Chapter 6.3: Arnoldi's method. Syntax call arnoldi ( A , X , H , info [, kstart ] [, kend ] [, tol ] [, transpose ] [, blksize ]) Arguments A : Linear operator derived from one the base types provided by the AbstractLinops module. The operator needs to be square, i.e. the dimension of its domain and\n        co-domain is the same. It is an intent(inout) argument. X : Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n        the computed Krylov vectors. The first entry X(1) is the starting vector for\n        the Arnoldi factorization. Additionally, the maximum number of Arnoldi steps\n        is equal to size(X) - 1 . It is an intent(inout) argument. - H : real or complex rank-2 array. On exit, it contains the upper Hessenberg matrix computed from the Arnoldi factorization. It is an intent(inout) argument. - info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Arnoldi factorization experienced a lucky breakdown. \n            The array of Krylov vectors X spans an -invariant subpsace of\n            dimension info . kstart ( optional ) : integer value determining the index of the first Arnoldi\n                            step to be computed. By default, kstart = 1 . It is an\n                            optional intent(in) argument. kend ( optional )   : integer value determining the index of the last Arnoldi step\n                            to be computed. It is an optional intent(in) argument. \n                            By default, kend = size(X) - 1 . tol ( optional )    :   Numerical tolerance below which a subspace is considered\n                            to be -invariant. It is an optional intent(in) argument.\n                            By default tol = atol_sp or tol = atol_rp depending on the \n                            kind of A . transpose ( optional )  : logical flag determining whether the Arnoldi factorization\n                                is applied to or . It is an optional intent(in) argument. Default transpose = .false. blksize ( optional )    : integer value determining the dimension of a block for the\n                                block Arnoldi factorization. It is an optional intent(in) argument. Default is blksize=1 . private module subroutine arnoldi_cdp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_cdp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. complex(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=dp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private module subroutine arnoldi_csp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_csp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. complex(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=sp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private module subroutine arnoldi_rdp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_rdp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. real(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=dp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private module subroutine arnoldi_rsp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_rsp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. real(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=sp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). public        interface bidiagonalization Description Given a general linear operator , find matrices , and such that where and are orthogonal bases for the column span and row span\nof , respectively, and is a bidiagonal matrix. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis for the column span of . Constructs an orthonormal Krylov basis for the row span of . Constructs a bidiagonal matrix whose singular values approximates those of . Checks for convergence and invariant subspaces. References R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\" \n  Technical Report, 1998. (PDF) Syntax call bidiagonalization ( A , U , V , B , info [, kstart ] [, kend ] [, tol ]) Arguments A :   Linear operator derived from one the base types provided by the AbstractLinops module. It is an intent(inout) argument. U :   Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n            the computed Krylov vectors for the column span of A . The first entry U(1) is the starting vector for the Lanczos factorization. Additionally, the \n            maximum number of Lanczos steps is equal to size(X) - 1 . \n            It is an intent(inout) argument. V :   Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n            the computed Krylov vectors for the row span of A . It is an intent(inout) argument. B : real or complex rank-2 array. On exit, it contains the bidiagonal matrix computed from the Lanczos factorization. It is an intent(inout) argument. info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Lanczos factorization experienced a lucky breakdown. kstart ( optional ) : integer value determining the index of the first Lanczos\n                            step to be computed. It is an optional intent(in) argument.\n                            By default, kstart = 1 . kend ( optional )   : integer value determining the index of the last Lanczos step\n                            to be computed. It is an optional intent(in) argument. \n                            By default, kend = size(X) - 1 . tol ( optional )    :   Numerical tolerance below which a subspace is considered\n                            to be -invariant. It is an optional intent(in) argument.\n                            By default tol = atol_sp or tol = atol_rp depending on the \n                            kind of A . private module subroutine lanczos_bidiagonalization_cdp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_cdp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_cdp ), intent(inout) :: V (:) Orthonormal basis for the row span of . complex(kind=dp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=dp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private module subroutine lanczos_bidiagonalization_csp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_csp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_csp ), intent(inout) :: V (:) Orthonormal basis for the row span of . complex(kind=sp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=sp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private module subroutine lanczos_bidiagonalization_rdp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_rdp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_rdp ), intent(inout) :: V (:) Orthonormal basis for the row span of . real(kind=dp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=dp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private module subroutine lanczos_bidiagonalization_rsp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be factorized. class( abstract_vector_rsp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_rsp ), intent(inout) :: V (:) Orthonormal basis for the row span of . real(kind=sp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=sp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. public        interface double_gram_schmidt_step Description Given an array of abstract_vector and an abstract_vector (or array of abstract_vectors ) , this subroutine returns a modified \nvector orthogonal to all columns of , i.e. using a double Gram-Schmidt process. On exit, is orthogonal to but\ndoes not have unit norm. Note moreover that is assumed to be an orthonormal \nset of vectors. The function can also return the projection coefficients . Syntax call double_gram_schmidt_step ( y , X , info [, if_chk_orthonormal ] [, beta ]) Arguments y : abstract_vector (or array of abstract_vector ) that needs to be\n            orthogonalize in-place against . It is an intent(inout) argument. X :   Array of abstract_vector against which needs to be orthogonalized.\n            Note the function assumes that is an orthonormal set of vectors, i.e. . If it this is not the case, the result is meaningless. \n            It is an intent(in) argument. info : integer Information flag. if_chk_orthonormal ( optional ) : logical flag to check whether is an orthonormal set of vectors or not. \n                                        If the orthonormality returns .false. , the function raises\n                                        an error. Note that this check is computationally expensive \n                                        and should be disabled in production unless required\n                                        for better performance. Is is an optional intent(in) argument. Default .true. . beta ( optional )   : real or complex array containing the coefficients .\n                            Is is an optional intent(out) argument. private module subroutine DGS_basis_against_basis_cdp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine DGS_basis_against_basis_csp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine DGS_basis_against_basis_rdp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine DGS_basis_against_basis_rsp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine DGS_vector_against_basis_cdp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine DGS_vector_against_basis_csp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine DGS_vector_against_basis_rdp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine DGS_vector_against_basis_rsp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested public        interface initialize_krylov_subspace Description Utility function to initialize a basis for a Krylov subspace. Syntax call initialize_krylov_subspace ( X [, X0 ]) Arguments X :   Array of vectors that needs to be initialized. It is an intent(inout) argument. Note that the first action in the subroutine is call zero_basis(X) , effectively zeroing-out any data stored. X0 ( optional ) :   Collection of vectors which will form the first few\n                        Krylov vectors. Note that X0 need not be an orthonormal\n                        basis as this subroutine includes a call orthonormalize_basis(X0) .\n                        It is an optional intent(in) argument. private module subroutine initialize_krylov_subspace_cdp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) class( abstract_vector_cdp ), intent(in), optional :: X0 (:) private module subroutine initialize_krylov_subspace_csp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) class( abstract_vector_csp ), intent(in), optional :: X0 (:) private module subroutine initialize_krylov_subspace_rdp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) class( abstract_vector_rdp ), intent(in), optional :: X0 (:) private module subroutine initialize_krylov_subspace_rsp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) class( abstract_vector_rsp ), intent(in), optional :: X0 (:) public        interface initialize_random_orthonormal_basis Description Utility function to initialize a random orthonormal basis. Syntax call initialize_random_orthonormal_basis ( X ) Arguments X :   Array of vectors that needs to be initialized with random orthonormal vectors.\n            It is an intent(inout) argument. private module subroutine initialize_random_orthonormal_basis_cdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) private module subroutine initialize_random_orthonormal_basis_csp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) private module subroutine initialize_random_orthonormal_basis_rdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) private module subroutine initialize_random_orthonormal_basis_rsp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) interface Description Given a permutation vector , this function computes the vector\nrepresentation of the inverse permutation matrix. Syntax inv_perm = invperm ( perm ) Arguments perm :   Rank-1 array of integer corresponding to the desired permutation vector.\n                It is an intent(in) argument. public module function invperm(perm) result(inv_perm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: perm (:) Return Value integer, allocatable, (:) public        interface is_orthonormal Description Utility function returning a logical .true. if the set of vectors stored in form\nan orthonormal set of vectors and .false. otherwise. Syntax out = is_orthonormal ( X ) Arguments X :   Array of derived types extended from the base types provided in the AbstractVectors module. It is an intent(in) argument. private module function is_orthonormal_cdp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: X (:) Return Value logical private module function is_orthonormal_csp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: X (:) Return Value logical private module function is_orthonormal_rdp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: X (:) Return Value logical private module function is_orthonormal_rsp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: X (:) Return Value logical public        interface krylov_schur Description Given a partial Krylov decomposition this subroutine implements the Krylov-Schur restarting strategy proposed by\nStewart [1]. References G. W. Stewart. \"A Krylov-Schur algorithm for large eigenproblems\".\n  SIAM Journal on Matrix Analysis and Applications, vol 23 (3), 2002. Syntax call krylov_schur ( n , X , H , select_eigs ) Arguments n :   Number of selected eigenvalues moved to the upper left-block of the \n            Schur matrix. It is an intent(out) argument. X :   On entry, array of abstract_vector computed using the Arnoldi process.\n            On exit, the first n columns form an orthonormal basis for the eigenspace\n            associated with eigenvalues moved to the upper left-block of the Schur matrix.\n            It is an intent(inout) argument. H :   On entry, real of complex upper Hessenberg matrix computed using the\n            Arnoldi process. On exit, the leading block contains the block of the re-ordered Schur matrix containing the selected\n            eigenvalues. It is an intent(inout) argument. select_eigs :   Procedure to select which eigenvalues to move in the upper-left\n                block. It is an intent(inout) argument. private  subroutine krylov_schur_rsp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_rsp ), intent(inout) :: X (:) Krylov basis. real(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure(eigvals_select_sp) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_rdp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_rdp ), intent(inout) :: X (:) Krylov basis. real(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure(eigvals_select_dp) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_csp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_csp ), intent(inout) :: X (:) Krylov basis. complex(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure(eigvals_select_sp) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_cdp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_cdp ), intent(inout) :: X (:) Krylov basis. complex(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure(eigvals_select_dp) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. public        interface lanczos Description Given a symmetric or Hermitian linear operator , find matrices and such that where is an orthogonal basis and is symmetric tridiagonal. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis via the Lanczos process with full\n  reorthogonalization. Constructs a symmetric tridiagonal matrix whose eigenvalues approximates those of . Checks for convergence and invariant subspaces. References Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003.\n  see Chapter 6.6: The symmetric Lanczos algorithm. Syntax call lanczos ( A , X , T , info [, kstart ] [, kend ] [, tol ]) Arguments A :   Symmetric or Hermitian linear operator derived from one the base types \n            provided by the AbstractLinops module. It is an intent(inout) argument. X :   Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n            the computed Krylov vectors. The first entry X(1) is the starting vector for\n            the Lanczos factorization. Additionally, the maximum number of Lanczos steps\n            is equal to size(X) - 1 . It is an intent(inout) argument. T : real or complex rank-2 array. On exit, it contains the symmetric tridiagonal matrix computed from the Arnoldi factorization. It is an intent(inout) argument. info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Lanczos factorization experienced a lucky breakdown. \n                The array of Krylov vectors X spans an -invariant subpsace of\n                dimension info . kstart ( optional ) : integer value determining the index of the first Lanczos\n                            step to be computed. It is an optional intent(in) argument.\n                            By default, kstart = 1 . kend ( optional )   : integer value determining the index of the last Lanczos step\n                            to be computed. It is an optional intent(in) argument. \n                            By default, kend = size(X) - 1 . tol ( optional )    :   Numerical tolerance below which a subspace is considered\n                            to be -invariant. It is an optional intent(in) argument.\n                            By default tol = atol_sp or tol = atol_rp depending on the \n                            kind of A . private module subroutine lanczos_tridiagonalization_cdp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(inout) :: A class( abstract_vector_cdp ), intent(inout) :: X (:) complex(kind=dp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=dp), intent(in), optional :: tol private module subroutine lanczos_tridiagonalization_csp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(inout) :: A class( abstract_vector_csp ), intent(inout) :: X (:) complex(kind=sp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=sp), intent(in), optional :: tol private module subroutine lanczos_tridiagonalization_rdp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(inout) :: A class( abstract_vector_rdp ), intent(inout) :: X (:) real(kind=dp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=dp), intent(in), optional :: tol private module subroutine lanczos_tridiagonalization_rsp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(inout) :: A class( abstract_vector_rsp ), intent(inout) :: X (:) real(kind=sp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=sp), intent(in), optional :: tol public        interface orthogonalize_against_basis private module subroutine orthogonalize_basis_against_basis_cdp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine orthogonalize_basis_against_basis_csp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine orthogonalize_basis_against_basis_rdp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine orthogonalize_basis_against_basis_rsp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private module subroutine orthogonalize_vector_against_basis_cdp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine orthogonalize_vector_against_basis_csp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . complex(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine orthogonalize_vector_against_basis_rdp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private module subroutine orthogonalize_vector_against_basis_rsp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal Check that input Krylov vectors X form an orthonormal basis (expensive!). Default .true. . real(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested public        interface orthonormalize_basis Description Given an array of vectors, it computes an orthonormal basis for its\ncolumn-span using the double_gram_schmidt process. All computations are done\nin-place. Syntax call orthonormalize_basis ( X ) Arguments X :   Array of abstract_vector to orthonormalize. Note that this process is done\n            in-place. It is an intent(inout) argument. private module subroutine orthonormalize_basis_cdp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private module subroutine orthonormalize_basis_csp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private module subroutine orthonormalize_basis_rdp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private module subroutine orthonormalize_basis_rsp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against public        interface permcols Description Given an array and a permutation vector , this function computes in-place the column-permuted matrix where is the column-permutation matrix constructed from the permutation\nvector . Syntax call permcols ( X , perm ) Arguments X :   Array of vectors derived from the base types defined in the AbstractVectors module. On entry, it is the original array. On exit, it contains the\n            column-permuted version computed in-place. It is an intent(inout) argument. perm :   Rank-1 array of integer corresponding to the desired permutation vector.\n                It is an intent(in) argument. private module subroutine permcols_array_cdp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_array_csp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_array_rdp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_array_rsp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_basis_cdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_basis_csp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_basis_rdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) private module subroutine permcols_basis_rsp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) public        interface qr Description Given an array of types derived from abstract_vector , it computes the in-place QR factorization of , i.e. where is an orthonormal arrays of vectors such that and is upper triangular. Note that it can also perform the QR factorization\nwith column pivoting where is a permutation matrix ensuring that the diagonal entries of have non-increasing absolute values. This amounts to using the pivoting QR as a\nrank-revealing factorization. References G. H. Golub & C. F. Van Loan. \"Matrix Computations\". 4th edition, The John Hopkins\n University Press, 2013.\n See Chapter 5.2.8: Modified Gram-Schmidt algorithm. Syntax call qr ( Q [, R ] [, perm ], info [, tol ]) Arguments Q :   Array of types derived from one of the base types provided in the AbstractVectors module. On entry, it contains the original array.\n            On exit, it is overwritten by the orthogonal basis for its span.\n            It is an intent(inout) argument. R : real or complex rank-2 array. On exit, its contains the upper triangular\n            matrix resulting from the QR factorization. It is an intent(out) argument. perm ( optional )   :   Rank-1 array of integer corresponding to the indices of\n                            permuted columns. If perm is absent, the naive QR factorization\n                            is being computed. In is an optional intent(in) argument. info : integer information flag. tol ( optional )    :   Numerical tolerance to determine whether two vectors are colinear\n                            or not. It is an optional intent(in) argument. Default tol = atol_sp or tol = atol_dp . private module subroutine qr_no_pivoting_cdp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol private module subroutine qr_no_pivoting_csp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol private module subroutine qr_no_pivoting_rdp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol private module subroutine qr_no_pivoting_rsp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol private module subroutine qr_with_pivoting_cdp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol private module subroutine qr_with_pivoting_csp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol private module subroutine qr_with_pivoting_rdp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol private module subroutine qr_with_pivoting_rsp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol","tags":"","url":"module/lightkrylov_basekrylov.html"},{"title":"LightKrylov_Logger – LightKrylov","text":"Uses stdlib_ascii stdlib_logger mpi_f08 stdlib_optval LightKrylov_Constants stdlib_strings Subroutines public  subroutine check_info (info, origin, module, procedure, info_msg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: info Informaion flag character(len=*), intent(in) :: origin The name of the subroutine from which the flag originates character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens character(len=*), intent(in), optional :: info_msg public  subroutine comm_close () Arguments None public  subroutine comm_setup () Arguments None public  subroutine log_debug (msg, module, procedure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Log message to print character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens public  subroutine log_error (msg, module, procedure, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Log message to print character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens integer, intent(in), optional :: stat status message character(len=*), intent(in), optional :: errmsg error message public  subroutine log_information (msg, module, procedure, flush_log) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Log message to print character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens logical, intent(in), optional :: flush_log Flush the I/O buffer? public  subroutine log_message (msg, module, procedure, flush_log) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Log message to print character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens logical, intent(in), optional :: flush_log Flush the I/O buffer? public  subroutine log_warning (msg, module, procedure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Log message to print character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens public  subroutine logger_setup (logfile, nio, log_level, log_stdout, log_timestamp, close_old, iunit) Wrapper to set up MPI if needed and initialize log files Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: logfile name of the dedicated LightKrylov logfile integer, intent(in), optional :: nio I/O rank for logging integer, intent(in), optional :: log_level set logging level\n0   : all_level\n10  : debug_level\n20  : information_level\n30  : warning_level\n40  : error_level\n100 : none_level logical, intent(in), optional :: log_stdout duplicate log messages to stdout? logical, intent(in), optional :: log_timestamp add timestamp to log messages logical, intent(in), optional :: close_old close previously opened logfiles (if present?) - stdout is not closed integer, intent(out), optional :: iunit log unit identifier public  subroutine stop_error (msg, module, procedure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg The name of the procedure in which the call happens character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens public  subroutine type_error (var, type, intent, module, procedure) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var Name of the variable character(len=*), intent(in) :: type Required type of the variable character(len=*), intent(in) :: intent Intent of the argument within the caller character(len=*), intent(in), optional :: module The name of the module in which the call happens character(len=*), intent(in), optional :: procedure The name of the procedure in which the call happens","tags":"","url":"module/lightkrylov_logger.html"},{"title":"LightKrylov_Timer_Utils – LightKrylov","text":"Uses LightKrylov_Logger stdlib_ascii LightKrylov_Constants stdlib_optval Derived Types type, public, abstract :: abstract_watch Base type to define a global timer.\nAll watches within LightKrylov and associated tools are derived from this type. Read more… Type-Bound Procedures procedure, public, pass(self) :: add_group Add new timer group to the watch. procedure, public, pass(self) :: add_timer Add new timer to the watch. procedure, public, pass(self) :: enumerate Print summary of registered timers and their current status. procedure, public, pass(self) :: finalize Gather timing information and print it to screen/logfile. procedure, public, pass(self) :: get_called Get the number and names of timer called (locally or globally) procedure, public, pass(self) :: get_data => get_timer_data_by_name procedure, public, pass(self) :: get_data_save => get_timer_data_save_by_name procedure, public, pass(self) :: get_group_id procedure, public, pass(self) :: get_time => get_timer_etime_by_name procedure, public, pass(self) :: get_timer_id procedure, public, pass(self) :: initialize Set up private timers, flags and counters. Switch on timing. procedure, public, pass(self) :: pause => pause_timer_by_name procedure, public, pass(self) :: print_info => print_timer_info_by_name procedure, public, pass(self) :: remove_timer Remove existing timer from the watch. procedure, public, pass(self) :: reset => reset_timer_by_name procedure, public, pass(self) :: reset_all Reset all timers in watch. procedure(abstract_set_timers), public, deferred, pass(self) :: set_private_timers_and_name Define private timers that cannot be removed by the user. procedure, public, pass(self) :: set_watch_name procedure, public, pass(self) :: start => start_timer_by_name procedure, public, pass(self) :: stop => stop_timer_by_name type, public :: lightkrylov_timer Individual timer.\nAtomic timer that is associated to a particular 'event' by name which may be a\nprocedure or a user-defined string at instantiation. Read more… Components Type Visibility Attributes Name Initial character(len=128), public :: name = 'default_timer' Timer name. Type-Bound Procedures procedure, public, pass(self) :: finalize => finalize_timer Aggregate data and prepare summary. procedure, public, pass(self) :: get_data => get_timer_data Getter routine to access to all local data: etime, counts, etime_max, etime_min, etime_pause. procedure, public, pass(self) :: get_data_save => get_timer_data_save Getter routine to access to global data. procedure, public, pass(self) :: get_time => get_timer_etime Getter routine to access self%etime only. procedure, public, pass(self) :: pause => pause_timer procedure, public, pass(self) :: print_info => print_timer_info Print timing data. procedure, public, pass(self) :: reset => reset_timer Reset timing data (soft/hard, clear/save data). procedure, public, pass(self) :: save_timer_data Transfer timing data to arrays. procedure, public, pass(self) :: start => start_timer procedure, public, pass(self) :: stop => stop_timer type, public :: lightkrylov_timer_group Simple type to allow for some structure in the timer output. Components Type Visibility Attributes Name Initial character(len=128), public :: name = 'default_group' group name.","tags":"","url":"module/lightkrylov_timer_utils.html"},{"title":"LightKrylov_IterativeSolvers – LightKrylov","text":"This module provides some of the most important computational routines provided by LightKrylov . These include: eigs :   Compute the leading eigenpairs of a square linear operator . eighs :   Compute the leading eigenpairs of a symmetric positive definite \n                operator . svds :   Compute the leading singular triplets of a linear operator . gmres :   Solve the linear system using the generalized minimum residual method . cg :   Solve the linear system where is symmetric \n                positive definite using the Conjugate Gradient method. It also provides abstract interfaces to pass user-defined solvers and preconditioners\nto LightKrylov . Note that these features are still experimental for now. Uses LightKrylov_Logger LightKrylov_Timing stdlib_io_npy LightKrylov_Utils LightKrylov_AbstractVectors stdlib_sorting iso_fortran_env LightKrylov_AbstractLinops LightKrylov_BaseKrylov stdlib_optval stdlib_stats LightKrylov_Constants Used by Descendants: cg_solver fgmres_solver gmres_solver hermitian_eigensolvers svds_solver Interfaces public        interface cg Description Given a symmetric (positive definite) matrix , solves the linear system using the Conjugate Gradient method. References Hestenes, M. R., and Stiefel, E. (1952). \"Methods of Conjugate Gradients for Solving\nLinear Systems,\" Journal of Research of the National Bureau of Standards,\n49(6), 409–436. Syntax call cg ( A , b , x , info [, rtol ] [, atol ] [, preconditioner ] [, options ]) Arguments A :   Linear operator derived from one of the abstract_sym_linop or abstract_hermitian_linop types provided by the AbstractLinops module. It is an intent(inout) argument. b :   Right-hand side vector derived from one the abstract_vector types provided\n            by the AbstractVectors module. It needs to have the same type and kind as A .\n            It is an intent(in) argument. x :   On entry, initial guess for the solution. On exit, the solution computed by\n            cg. It is a vector derived from one the abstract_vector types provided by the AbstractVectors module. It needs to have the same type and kind as A . It is\n            an intent(inout) argument. info : integer information flag. rtol (optional) : real relative tolerance for the solver. atol (optional) : real absolute tolerance for the solver. preconditioner (optional)   :   Right preconditioner used to solve the system. It needs to be \n                                    consistent with the abstract_preconditioner interface. \n                                    It is an optional intent(in) argument. options (optional)  :   Container for the gmres options given by the cg_opts type.\n                            It is an optional intent(in) argument. private module subroutine cg_cdp(A, b, x, info, rtol, atol, preconditioner, options, meta) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine cg_csp(A, b, x, info, rtol, atol, preconditioner, options, meta) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine cg_rdp(A, b, x, info, rtol, atol, preconditioner, options, meta) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine cg_rsp(A, b, x, info, rtol, atol, preconditioner, options, meta) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. class( abstract_metadata ), intent(out), optional :: meta Metadata. public        interface eighs Description Computes the leading eigenpairs of a symmetric operator using the \nLanczos iterative process. Given a square linear operator , it finds\nthe leading eigvalues and eigvectors such that: The subspace is constructed via Lanczos factorization, resulting in a symmetric\ntridiagonal matrix . The eigenvalues of are approximated by those of and the eigenvectors are computed accordingly. References Lanczos, C. (1950). \"An Iteration Method for the Solution of the Eigenvalue Problem\nof Linear Differential and Integral Operators\". United States Governm. Press Office. Syntax call eighs ( A , X , eigvals , residuals , info [, kdim ] [, tolerance ]) Arguments A :   Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n            eigenpairs need to be computed. It is an intent(inout) argument. X :   Array of abstract_vectors with the same type and kind as A . On exit, it\n            contains the leading eigenvectors of A . Note that the dimension of X fixes\n            the number of eigenpairs computed. It is an intent(out) argument. eigvals :   Rank-1 array of real numbers. On exit, it contains the leading\n                eigenvalues of A . It is an intent(out) argument. residuals :   Rank-1 array of real numbers. On exit, it contains the residuals\n                    associated with each eigenpairs. It is an intent(out) argument. info : integer Information flag. kdim ( optional )   : integer , maximum dimension of the Krylov subspace used to\n                            approximate the leading eigenpairs. It is an optional intent(in) argument. By default, kdim = 4*size(X) . tolerance ( optional )  : real tolerance below which an eigenpair is considered as\n                                being converged. It is an optional intent(in) argument. By default, tolerance = rtol_sp or tolerance = rtol_dp . Note This implementation does not currently include an automatic restarting procedure\nsuch as krylov_schur for eigs . This is work in progress. private module subroutine eighs_cdp(A, X, eigvals, residuals, info, x0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_cdp ), intent(out) :: X (:) Leading eigevectors of . real(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. class( abstract_vector_cdp ), intent(in), optional :: x0 Optional starting vector to generate the Krylov subspace. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine eighs_csp(A, X, eigvals, residuals, info, x0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_csp ), intent(out) :: X (:) Leading eigevectors of . real(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. class( abstract_vector_csp ), intent(in), optional :: x0 Optional starting vector to generate the Krylov subspace. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine eighs_rdp(A, X, eigvals, residuals, info, x0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rdp ), intent(out) :: X (:) Leading eigevectors of . real(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. class( abstract_vector_rdp ), intent(in), optional :: x0 Optional starting vector to generate the Krylov subspace. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine eighs_rsp(A, X, eigvals, residuals, info, x0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rsp ), intent(out) :: X (:) Leading eigevectors of . real(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. class( abstract_vector_rsp ), intent(in), optional :: x0 Optional starting vector to generate the Krylov subspace. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? public        interface eigs Description Computes the leading eigenpairs of a square linear operator using the Arnoldi iterative process. Given a square linear operator , it finds\nthe leading eigenvalues and eigenvectors such that: or The subspace is constructed via Arnoldi factorization, resulting in an upper\nHessenberg matrix . The eigenvalues of are approximated by those of and the eigenvectors are computed accordingly. References Arnoldi, W. E. (1951). \"The Principle of Minimized Iterations in the Solution of\n  the Matrix Eigenvalue Problem.\" Quarterly of Applied Mathematics, 9(1), 17–29. Syntax call eigs ( A , X , eigvals , residuals , info [, kdim ] [, select ] [, tolerance ] [, transpose ]) Arguments A :   Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n            eigenpairs need to be computed. It is an intent(inout) argument. X :   Array of abstract_vectors with the same type and kind as A . On exit, it\n            contains the leading eigenvectors of A . Note that the dimension of X fixes\n            the number of eigenpairs computed. It is an intent(out) argument. eigvals :   Rank-1 array of real numbers. On exit, it contains the leading\n                eigenvalues of A . It is an intent(out) argument. residuals :   Rank-1 array of real numbers. On exit, it contains the residuals\n                    associated with each eigenpairs. It is an intent(out) argument. info : integer Information flag. kdim ( optional )   : integer , maximum dimension of the Krylov subspace used to\n                            approximate the leading eigenpairs. It is an optional intent(in) argument. By default, kdim = 4*size(X) . select ( optional ) : Function to select which eigenvalues to compute. tolerance ( optional )  : real tolerance below which an eigenpair is considered as\n                                being converged. It is an optional intent(in) argument.\n                                By default, tolerance = rtol_sp or tolerance = rtol_dp . transpose ( optional )  : logical flag determining whether the eigenvalues of or need to be computed. It is an optional intent(in) argument. private  subroutine eigs_rsp(A, X, eigvals, residuals, info, x0, kdim, tolerance, transpose, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rsp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_rsp ), intent(in), optional :: x0 Optional starting vector for generating the Krylov subspace. integer, intent(in), optional :: kdim Maximum dimension of the Krylov subspace (optional). real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private  subroutine eigs_rdp(A, X, eigvals, residuals, info, x0, kdim, tolerance, transpose, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rdp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_rdp ), intent(in), optional :: x0 Optional starting vector for generating the Krylov subspace. integer, intent(in), optional :: kdim Maximum dimension of the Krylov subspace (optional). real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private  subroutine eigs_csp(A, X, eigvals, residuals, info, x0, kdim, tolerance, transpose, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_csp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_csp ), intent(in), optional :: x0 Optional starting vector for generating the Krylov subspace. integer, intent(in), optional :: kdim Maximum dimension of the Krylov subspace (optional). real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private  subroutine eigs_cdp(A, X, eigvals, residuals, info, x0, kdim, tolerance, transpose, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_cdp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_cdp ), intent(in), optional :: x0 Optional starting vector for generating the Krylov subspace. integer, intent(in), optional :: kdim Maximum dimension of the Krylov subspace (optional). real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? public        interface fgmres Description Solve a square linear system of equations using the Flexible Generalized Minimum RESidual (FGMRES) method. References Saad Y. and Schultz M. H. \"GMRES: A generalized minimal residual algorithm for\nsolving nonsymmetric linear systems.\" SIAM Journal on Scientific and Statistical\nComputing, 7(3), 1986. Syntax call fgmres ( A , b , x , info [, rtol ] [, atol ] [, preconditioner ] [, options ] [, transpose ]) Arguments A :   Linear operator derived from one of the abstract_linop types provided by the AbstractLinops module. It is an intent(inout) argument. b :   Right-hand side vector derived from one the abstract_vector types provided\n            by the AbstractVectors module. It needs to have the same type and kind as A .\n            It is an intent(in) argument. x :   On entry, initial guess for the solution. On exit, the solution computed by\n            gmres. It is a vector derived from one the abstract_vector types provided by the AbstractVectors module. It needs to have the same type and kind as A . It is\n            an intent(inout) argument. info : integer information flag. rtol (optional) : real relative tolerance for the solver. atol (optional) : real absolute tolerance for the solver. preconditioner (optional)   :   Right preconditioner used to solve the system. It needs to be \n                                    consistent with the abstract_preconditioner interface. \n                                    It is an optional intent(in) argument. options (optional)  :   Container for the gmres options given by the gmres_opts type.\n                            It is an optional intent(in) argument. transpose (optional): logical flag controlling whether or is being solved. private module subroutine dense_fgmres_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Linear operator to be inverted. complex(kind=dp), intent(in) :: b (:) Right-hand side vector. complex(kind=dp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_fgmres_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Linear operator to be inverted. complex(kind=sp), intent(in) :: b (:) Right-hand side vector. complex(kind=sp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_fgmres_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Linear operator to be inverted. real(kind=dp), intent(in) :: b (:) Right-hand side vector. real(kind=dp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_fgmres_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Linear operator to be inverted. real(kind=sp), intent(in) :: b (:) Right-hand side vector. real(kind=sp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine fgmres_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine fgmres_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine fgmres_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine fgmres_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. public        interface gmres Description Solve a square linear system of equations using the Generalized Minimum RESidual (GMRES) method. References Saad Y. and Schultz M. H. \"GMRES: A generalized minimal residual algorithm for\nsolving nonsymmetric linear systems.\" SIAM Journal on Scientific and Statistical\nComputing, 7(3), 1986. Syntax call gmres ( A , b , x , info [, rtol ] [, atol ] [, preconditioner ] [, options ] [, transpose ]) Arguments A :   Linear operator derived from one of the abstract_linop types provided by the AbstractLinops module. It is an intent(inout) argument. b :   Right-hand side vector derived from one the abstract_vector types provided\n            by the AbstractVectors module. It needs to have the same type and kind as A .\n            It is an intent(in) argument. x :   On entry, initial guess for the solution. On exit, the solution computed by\n            gmres. It is a vector derived from one the abstract_vector types provided by the AbstractVectors module. It needs to have the same type and kind as A . It is\n            an intent(inout) argument. info : integer information flag. rtol (optional) : real relative tolerance for the solver. atol (optional) : real absolute tolerance for the solver. preconditioner (optional)   :   Right preconditioner used to solve the system. It needs\n                                    to be consistent with the abstract_preconditioner interface.\n                                    It is an optional intent(in) argument. options (optional)  :   Container for the gmres options given by the gmres_opts type.\n                            It is an optional intent(in) argument. transpose (optional): logical flag controlling whether or is being solved. meta (optional) :   Container for the gmres metadata. It needs to be of type gmres_metadata . private module subroutine dense_gmres_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Linear operator to be inverted. complex(kind=dp), intent(in) :: b (:) Right-hand side vector. complex(kind=dp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_gmres_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Linear operator to be inverted. complex(kind=sp), intent(in) :: b (:) Right-hand side vector. complex(kind=sp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_gmres_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Linear operator to be inverted. real(kind=dp), intent(in) :: b (:) Right-hand side vector. real(kind=dp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine dense_gmres_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Linear operator to be inverted. real(kind=sp), intent(in) :: b (:) Right-hand side vector. real(kind=sp), intent(inout) :: x (:) Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine gmres_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine gmres_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine gmres_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. private module subroutine gmres_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. public        interface save_eigenspectrum Description Utility function to save the eigenspectrum computed from the Arnoldi factorization.\nIt outpost a .npy file. Syntax call save_eigenspectrum ( eigvals , residuals , fname ) Arguments eigvals : complex rank-1 array containing the eigenvalues. It is an intent(in) argument. residuals : real rank-1 array containing the residuals associated to each\n                    eigenvalues. It is an intent(in) argument. fname : Name of the file to save the eigenspectrum. It is an intent(in) argument. private module subroutine save_eigenspectrum_cdp(lambda, residuals, fname) Implementation → Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: lambda (:) Eigenalues. real(kind=dp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. private module subroutine save_eigenspectrum_csp(lambda, residuals, fname) Implementation → Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: lambda (:) Eigenalues. real(kind=sp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. private module subroutine save_eigenspectrum_rdp(lambda, residuals, fname) Implementation → Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda (:) Eigenalues. real(kind=dp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. private module subroutine save_eigenspectrum_rsp(lambda, residuals, fname) Implementation → Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: lambda (:) Eigenalues. real(kind=sp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. public        interface svds Description Computes the leading singular triplets of an arbitrary linear operator using the Lanczos iterative process. Given a linear operator , it finds\nthe leading singular values and singular vectors such that: The subspaces and are constructed via Lanczos factorization, resulting in\na bidiagonal matrix . The singular values of are approximated by those of and the singular vectors are computed accordingly. References Golub, G. H., & Kahan, W. (1965). \"Calculating the Singular Values and\n Pseudo-Inverse of a Matrix.\" Baglama, J., & Reichel, L. (2005). \"Augmented implicitly restarted Lanczos\n bidiagonalization methods.\" R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\"\n Technical Report, 1998. Syntax call svds ( A , U , S , V , residuals , info [, kdim ] [, tolerance ]) Arguments A :   Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n            eigenpairs need to be computed. It is an intent(inout) argument. U :   Array of abstract_vectors with the same type and kind as A . On exit, it\n            contains the left singular vectors of A . Note that the dimension of U fixes\n            the number of eigenpairs computed. It is an intent(out) argument. S :   Rank-1 array of real numbers. On exit, it contains the leading\n            singular values of A . It is an intent(out) argument. V :   Array of abstract_vectors with the same type and kind as A . On exit, it\n            contains the left singular vectors of A . Note that the dimension of U fixes\n            the number of eigenpairs computed. It is an intent(out) argument. residuals :   Rank-1 array of real numbers. On exit, it contains the residuals\n                    associated with each singular triplet. It is an intent(out) argument. info : integer Information flag. kdim ( optional )   : integer , maximum dimension of the Krylov subspace used to\n                            approximate the leading singular triplets. It is an optional intent(in) argument. By default, kdim = 4*size(X) . tolerance ( optional )  : real tolerance below which a triplet is considered as being converged. It is an\n                                optional intent(in) argument. By default, tolerance = rtol_sp or tolerance = rtol_dp`. Note This implementation does not currently include an automatic restarting procedure\nsuch as krylov_schur for eigs . This is work in progress. private module subroutine svds_cdp(A, U, S, V, residuals, info, u0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_cdp ), intent(out) :: U (:) Leading left singular vectors. real(kind=dp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_cdp ), intent(out) :: V (:) Leading right singular vectors. real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_cdp ), intent(in), optional :: u0 integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine svds_csp(A, U, S, V, residuals, info, u0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_csp ), intent(out) :: U (:) Leading left singular vectors. real(kind=sp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_csp ), intent(out) :: V (:) Leading right singular vectors. real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_csp ), intent(in), optional :: u0 integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine svds_rdp(A, U, S, V, residuals, info, u0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_rdp ), intent(out) :: U (:) Leading left singular vectors. real(kind=dp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_rdp ), intent(out) :: V (:) Leading right singular vectors. real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_rdp ), intent(in), optional :: u0 integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? private module subroutine svds_rsp(A, U, S, V, residuals, info, u0, kdim, tolerance, write_intermediate) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_rsp ), intent(out) :: U (:) Leading left singular vectors. real(kind=sp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_rsp ), intent(out) :: V (:) Leading right singular vectors. real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. class( abstract_vector_rsp ), intent(in), optional :: u0 integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: write_intermediate Write intermediate eigenvalues to file during iteration? Abstract Interfaces abstract interface public  subroutine abstract_linear_solver_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Abstract interface to use a user-defined linear solver in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(inout) :: A Linear operator to invert. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(inout), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. abstract interface public  subroutine abstract_linear_solver_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Abstract interface to use a user-defined linear solver in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(inout) :: A Linear operator to invert. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(inout), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. abstract interface public  subroutine abstract_linear_solver_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Abstract interface to use a user-defined linear solver in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(inout) :: A Linear operator to invert. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(inout), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. abstract interface public  subroutine abstract_linear_solver_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta) Abstract interface to use a user-defined linear solver in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(inout) :: A Linear operator to invert. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(inout), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. class( abstract_metadata ), intent(out), optional :: meta Metadata. Derived Types type, public, abstract :: abstract_precond_cdp Type-Bound Procedures procedure(abstract_apply_cdp), public, deferred, pass(self) :: apply type, public, abstract :: abstract_precond_csp Type-Bound Procedures procedure(abstract_apply_csp), public, deferred, pass(self) :: apply type, public, abstract :: abstract_precond_rdp Type-Bound Procedures procedure(abstract_apply_rdp), public, deferred, pass(self) :: apply type, public, abstract :: abstract_precond_rsp Type-Bound Procedures procedure(abstract_apply_rsp), public, deferred, pass(self) :: apply type, public, extends( abstract_metadata ) :: cg_dp_metadata Conjugate gradient metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag integer, public :: info = 0 Copy of the information flag for completeness integer, public :: n_iter = 0 Iteration counter real(kind=dp), public, dimension(:), allocatable :: res Residual history Type-Bound Procedures procedure, public, pass(self) :: print => print_cg_dp procedure, public, pass(self) :: reset => reset_cg_dp type, public, extends( abstract_opts ) :: cg_dp_opts Conjugate gradient options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print interation metadata on exit (default = .false.) integer, public :: maxiter = 100 Maximum number of cg iterations (default: 100). type, public, extends( abstract_metadata ) :: cg_sp_metadata Conjugate gradient metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag integer, public :: info = 0 Copy of the information flag for completeness integer, public :: n_iter = 0 Iteration counter real(kind=sp), public, dimension(:), allocatable :: res Residual history Type-Bound Procedures procedure, public, pass(self) :: print => print_cg_sp procedure, public, pass(self) :: reset => reset_cg_sp type, public, extends( abstract_opts ) :: cg_sp_opts Conjugate gradient options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print interation metadata on exit (default = .false.) integer, public :: maxiter = 100 Maximum number of cg iterations (default: 100). type, public, extends( abstract_metadata ) :: fgmres_dp_metadata FGMRES metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag. integer, public :: info = 0 Copy of the information flag for completeness. integer, public :: n_inner = 0 Number of inner iterations. integer, public :: n_iter = 0 Total iteration counter. integer, public :: n_outer = 0 Number of outer iterations (i.e. restarts) real(kind=dp), public, dimension(:), allocatable :: res Residual history. Type-Bound Procedures procedure, public, pass(self) :: print => print_fgmres_dp procedure, public, pass(self) :: reset => reset_fgmres_dp type, public, extends( abstract_opts ) :: fgmres_dp_opts FGMRES options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print iteration metadata on exit (default: .false.). integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of fgmres restarts (default: 10). logical, public :: sanity_check = .true. Performs extra matrix-vector product for sanity check. type, public, extends( abstract_metadata ) :: fgmres_sp_metadata FGMRES metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag. integer, public :: info = 0 Copy of the information flag for completeness. integer, public :: n_inner = 0 Number of inner iterations. integer, public :: n_iter = 0 Total iteration counter. integer, public :: n_outer = 0 Number of outer iterations (i.e. restarts) real(kind=sp), public, dimension(:), allocatable :: res Residual history. Type-Bound Procedures procedure, public, pass(self) :: print => print_fgmres_sp procedure, public, pass(self) :: reset => reset_fgmres_sp type, public, extends( abstract_opts ) :: fgmres_sp_opts FGMRES options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print iteration metadata on exit (default: .false.). integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of fgmres restarts (default: 10). logical, public :: sanity_check = .true. Performs extra matrix-vector product for sanity check. type, public, extends( abstract_metadata ) :: gmres_dp_metadata GMRES metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag. integer, public :: info = 0 Copy of the information flag for completeness. integer, public :: n_inner = 0 Number of inner iterations. integer, public :: n_iter = 0 Total iteration counter. integer, public :: n_outer = 0 Number of outer iterations (i.e. restarts) real(kind=dp), public, dimension(:), allocatable :: res Residual history. Type-Bound Procedures procedure, public, pass(self) :: print => print_gmres_dp procedure, public, pass(self) :: reset => reset_gmres_dp type, public, extends( abstract_opts ) :: gmres_dp_opts GMRES options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print iteration metadata on exit (default: .false.). integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of gmres restarts (default: 10). logical, public :: sanity_check = .true. Performs extra matrix-vector product for sanity check. type, public, extends( abstract_metadata ) :: gmres_sp_metadata GMRES metadata. Components Type Visibility Attributes Name Initial logical, public :: converged = .false. Convergence flag. integer, public :: info = 0 Copy of the information flag for completeness. integer, public :: n_inner = 0 Number of inner iterations. integer, public :: n_iter = 0 Total iteration counter. integer, public :: n_outer = 0 Number of outer iterations (i.e. restarts) real(kind=sp), public, dimension(:), allocatable :: res Residual history. Type-Bound Procedures procedure, public, pass(self) :: print => print_gmres_sp procedure, public, pass(self) :: reset => reset_gmres_sp type, public, extends( abstract_opts ) :: gmres_sp_opts GMRES options. Components Type Visibility Attributes Name Initial logical, public :: if_print_metadata = .false. Print iteration metadata on exit (default: .false.). integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of gmres restarts (default: 10). logical, public :: sanity_check = .true. Performs extra matrix-vector product for sanity check. Subroutines public  subroutine write_results_cdp (filename, vals, res, tol) Prints the intermediate results of iterative eigenvalue/singular value decompositions Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Output filename. This file will be overwritten complex(kind=dp), intent(in) :: vals (:) Intermediate values real(kind=dp), intent(inout) :: res (:) Residuals real(kind=dp), intent(in) :: tol Convergence tolerance public  subroutine write_results_csp (filename, vals, res, tol) Prints the intermediate results of iterative eigenvalue/singular value decompositions Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Output filename. This file will be overwritten complex(kind=sp), intent(in) :: vals (:) Intermediate values real(kind=sp), intent(inout) :: res (:) Residuals real(kind=sp), intent(in) :: tol Convergence tolerance public  subroutine write_results_rdp (filename, vals, res, tol) Prints the intermediate results of iterative eigenvalue/singular value decompositions Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Output filename. This file will be overwritten real(kind=dp), intent(in) :: vals (:) Intermediate values real(kind=dp), intent(inout) :: res (:) Residuals real(kind=dp), intent(in) :: tol Convergence tolerance public  subroutine write_results_rsp (filename, vals, res, tol) Prints the intermediate results of iterative eigenvalue/singular value decompositions Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Output filename. This file will be overwritten real(kind=sp), intent(in) :: vals (:) Intermediate values real(kind=sp), intent(inout) :: res (:) Residuals real(kind=sp), intent(in) :: tol Convergence tolerance Module Procedures module procedure /github/workspace/API-doc/module/lightkrylov_iterativesolvers.html save_eigenspectrum_cdp private module subroutine save_eigenspectrum_cdp(lambda, residuals, fname) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: lambda (:) Eigenalues. real(kind=dp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. module procedure /github/workspace/API-doc/module/lightkrylov_iterativesolvers.html save_eigenspectrum_csp private module subroutine save_eigenspectrum_csp(lambda, residuals, fname) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: lambda (:) Eigenalues. real(kind=sp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. module procedure /github/workspace/API-doc/module/lightkrylov_iterativesolvers.html save_eigenspectrum_rdp private module subroutine save_eigenspectrum_rdp(lambda, residuals, fname) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda (:) Eigenalues. real(kind=dp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. module procedure /github/workspace/API-doc/module/lightkrylov_iterativesolvers.html save_eigenspectrum_rsp private module subroutine save_eigenspectrum_rsp(lambda, residuals, fname) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: lambda (:) Eigenalues. real(kind=sp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file.","tags":"","url":"module/lightkrylov_iterativesolvers.html"},{"title":"LightKrylov_AbstractSystems – LightKrylov","text":"This module provides the abstract types necessary to define an algebraic system of\nnonlinear equations to be solved using the Newton method. Uses LightKrylov_Logger LightKrylov_Timer_Utils LightKrylov_AbstractLinops stdlib_optval LightKrylov_AbstractVectors LightKrylov_Constants Derived Types type, public, abstract, extends( abstract_linop_cdp ) :: abstract_jacobian_linop_cdp Abstract type for the local linearization of the system around the state X.\nThis type is intended for use within the abstract_system type. Components Type Visibility Attributes Name Initial class( abstract_vector_cdp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_csp ) :: abstract_jacobian_linop_csp Abstract type for the local linearization of the system around the state X.\nThis type is intended for use within the abstract_system type. Components Type Visibility Attributes Name Initial class( abstract_vector_csp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_rdp ) :: abstract_jacobian_linop_rdp Abstract type for the local linearization of the system around the state X.\nThis type is intended for use within the abstract_system type. Components Type Visibility Attributes Name Initial class( abstract_vector_rdp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_rsp ) :: abstract_jacobian_linop_rsp Abstract type for the local linearization of the system around the state X.\nThis type is intended for use within the abstract_system type. Components Type Visibility Attributes Name Initial class( abstract_vector_rsp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract :: abstract_system Base type to define an abstract system. All other system types defined\nin LightKrylov derive from this fundamental one. Read more… Type-Bound Procedures procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history procedure, public, pass(self) :: get_eval_counter Return eval counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_eval_counter Reset eval counter procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data type, public, abstract, extends( abstract_system ) :: abstract_system_cdp Base type to extend in order to define a complex(dp)-valued system for\nNewton fixed-point iteration via the Jacobian. Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_cdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_cdp Wrapper for response including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history procedure, public, pass(self) :: get_eval_counter Return eval counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_eval_counter Reset eval counter procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data procedure(abstract_eval_cdp), public, deferred, pass(self) :: response Procedure to evaluate the system response . type, public, abstract, extends( abstract_system ) :: abstract_system_csp Base type to extend in order to define a complex(sp)-valued system for\nNewton fixed-point iteration via the Jacobian. Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_csp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_csp Wrapper for response including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history procedure, public, pass(self) :: get_eval_counter Return eval counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_eval_counter Reset eval counter procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data procedure(abstract_eval_csp), public, deferred, pass(self) :: response Procedure to evaluate the system response . type, public, abstract, extends( abstract_system ) :: abstract_system_rdp Base type to extend in order to define a real(dp)-valued system for\nNewton fixed-point iteration via the Jacobian. Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_rdp Wrapper for response including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history procedure, public, pass(self) :: get_eval_counter Return eval counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_eval_counter Reset eval counter procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data procedure(abstract_eval_rdp), public, deferred, pass(self) :: response Procedure to evaluate the system response . type, public, abstract, extends( abstract_system ) :: abstract_system_rsp Base type to extend in order to define a real(sp)-valued system for\nNewton fixed-point iteration via the Jacobian. Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rsp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_rsp Wrapper for response including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history procedure, public, pass(self) :: get_eval_counter Return eval counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_eval_counter Reset eval counter procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data procedure(abstract_eval_rsp), public, deferred, pass(self) :: response Procedure to evaluate the system response .","tags":"","url":"module/lightkrylov_abstractsystems.html"},{"title":"LightKrylov_AbstractLinops – LightKrylov","text":"This module provides the base classes abtract_linop_rsp , abstract_linop_rdp , abstract_linop_csp and abstract_linop_cdp which can be used to define your own\nlinear operators. To do so, you simply need to provide two type-bound procedures: matvec(self, vec_in, vec_out) :   Computes the matrix-vector product. `rmatvec(self, vec_in, vec_out)   :   Computes the transpose matrix-vector product. It also provides extended types to define the identity operator, symmetric linear\noperators, scalar-multiplication of a linear multiplication, as well as addition\nof two linear operators. Uses LightKrylov_Logger stdlib_linalg_blas LightKrylov_Utils LightKrylov_Timer_Utils stdlib_optval LightKrylov_AbstractVectors LightKrylov_Constants Interfaces public        interface adjoint private  function initialize_adjoint_rsp(A) result(B) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Return Value class( adjoint_linop_rsp ), allocatable private  function initialize_adjoint_rdp(A) result(B) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Return Value class( adjoint_linop_rdp ), allocatable private  function initialize_adjoint_csp(A) result(B) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Return Value class( adjoint_linop_csp ), allocatable private  function initialize_adjoint_cdp(A) result(B) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Return Value class( adjoint_linop_cdp ), allocatable public        interface dense_linop private  function initialize_dense_linop_from_array_rsp(A) result(linop) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value type( dense_linop_rsp ) private  function initialize_dense_linop_from_array_rdp(A) result(linop) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value type( dense_linop_rdp ) private  function initialize_dense_linop_from_array_csp(A) result(linop) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value type( dense_linop_csp ) private  function initialize_dense_linop_from_array_cdp(A) result(linop) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value type( dense_linop_cdp ) Derived Types type, public, extends( abstract_linop_cdp ) :: Id_cdp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => id_matvec_cdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => id_matvec_cdp type, public, extends( abstract_linop_csp ) :: Id_csp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => id_matvec_csp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => id_matvec_csp type, public, extends( abstract_linop_rdp ) :: Id_rdp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => id_matvec_rdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => id_matvec_rdp type, public, extends( abstract_linop_rsp ) :: Id_rsp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => id_matvec_rsp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => id_matvec_rsp type, public, abstract, extends( abstract_linop_cdp ) :: abstract_exptA_linop_cdp Utility type to define the exponential propagator which is the linear map \ncorresponding to the matrix exponential of the (possibly time-dependent) system Jacobian over a time horizon as: Read more… Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=dp), public :: tau Time horizon for the temporal integration. This variable must be set when the operator is instantiated. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_csp ) :: abstract_exptA_linop_csp Utility type to define the exponential propagator which is the linear map \ncorresponding to the matrix exponential of the (possibly time-dependent) system Jacobian over a time horizon as: Read more… Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=sp), public :: tau Time horizon for the temporal integration. This variable must be set when the operator is instantiated. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_rdp ) :: abstract_exptA_linop_rdp Utility type to define the exponential propagator which is the linear map \ncorresponding to the matrix exponential of the (possibly time-dependent) system Jacobian over a time horizon as: Read more… Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=dp), public :: tau Time horizon for the temporal integration. This variable must be set when the operator is instantiated. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_rsp ) :: abstract_exptA_linop_rsp Utility type to define the exponential propagator which is the linear map \ncorresponding to the matrix exponential of the (possibly time-dependent) system Jacobian over a time horizon as: Read more… Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=sp), public :: tau Time horizon for the temporal integration. This variable must be set when the operator is instantiated. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_sym_linop ) :: abstract_hermitian_linop_cdp Abstract representation of an abstract hermitian (complex-valued) linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_herm_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_herm_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data type, public, abstract, extends( abstract_sym_linop ) :: abstract_hermitian_linop_csp Abstract representation of an abstract hermitian (complex-valued) linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_herm_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_herm_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data type, public, abstract :: abstract_linop Base type to define an abstract linear operator. All other operator types defined\nin LightKrylov derive from this fundamental one. Read more… Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data type, public, abstract, extends( abstract_linop ) :: abstract_linop_cdp Base type to extend in order to define a complex(dp)-valued linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop ) :: abstract_linop_csp Base type to extend in order to define a complex(sp)-valued linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop ) :: abstract_linop_rdp Base type to extend in order to define a real(dp)-valued linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop ) :: abstract_linop_rsp Base type to extend in order to define a real(sp)-valued linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop ) :: abstract_sym_linop Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data type, public, abstract, extends( abstract_sym_linop ) :: abstract_sym_linop_rdp Abstract representation of an abstract symmetric (real valued) linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_sym_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_sym_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data type, public, abstract, extends( abstract_sym_linop ) :: abstract_sym_linop_rsp Abstract representation of an abstract symmetric (real valued) linear operator. Components Type Visibility Attributes Name Initial type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_sym_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure(abstract_sym_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data type, public, extends( abstract_linop_cdp ) :: adjoint_linop_cdp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec switched. Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => adjoint_matvec_cdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_cdp type, public, extends( abstract_linop_csp ) :: adjoint_linop_csp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec switched. Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => adjoint_matvec_csp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_csp type, public, extends( abstract_linop_rdp ) :: adjoint_linop_rdp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec switched. Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => adjoint_matvec_rdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_rdp type, public, extends( abstract_linop_rsp ) :: adjoint_linop_rsp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec switched. Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => adjoint_matvec_rsp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_rsp type, public, extends( abstract_linop_cdp ) :: axpby_linop_cdp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to define A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_cdp ), public, allocatable :: B Underlying linear operators. complex(kind=dp), public :: alpha Scaling factors. complex(kind=dp), public :: beta Scaling factors. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => axpby_matvec_cdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => axpby_rmatvec_cdp type, public, extends( abstract_linop_csp ) :: axpby_linop_csp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to define A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_csp ), public, allocatable :: B Underlying linear operators. complex(kind=sp), public :: alpha Scaling factors. complex(kind=sp), public :: beta Scaling factors. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => axpby_matvec_csp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => axpby_rmatvec_csp type, public, extends( abstract_linop_rdp ) :: axpby_linop_rdp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to define A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_rdp ), public, allocatable :: B Underlying linear operators. real(kind=dp), public :: alpha Scaling factors. real(kind=dp), public :: beta Scaling factors. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => axpby_matvec_rdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => axpby_rmatvec_rdp type, public, extends( abstract_linop_rsp ) :: axpby_linop_rsp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to define A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_rsp ), public, allocatable :: B Underlying linear operators. real(kind=sp), public :: alpha Scaling factors. real(kind=sp), public :: beta Scaling factors. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => axpby_matvec_rsp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => axpby_rmatvec_rsp type, public, extends( abstract_linop_cdp ) :: dense_linop_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: data (:,:) type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => dense_matvec_cdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => dense_rmatvec_cdp type, public, extends( abstract_linop_csp ) :: dense_linop_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public, allocatable :: data (:,:) type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => dense_matvec_csp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => dense_rmatvec_csp type, public, extends( abstract_linop_rdp ) :: dense_linop_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: data (:,:) type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => dense_matvec_rdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => dense_rmatvec_rdp type, public, extends( abstract_linop_rsp ) :: dense_linop_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public, allocatable :: data (:,:) type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => dense_matvec_rsp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => dense_rmatvec_rsp type, public, extends( abstract_linop_cdp ) :: scaled_linop_cdp Defines a scaled linear operator with a complex(dp)-valued operator\nand . Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Base linear operator to be scaled. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') complex(kind=dp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => scaled_matvec_cdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => scaled_rmatvec_cdp type, public, extends( abstract_linop_csp ) :: scaled_linop_csp Defines a scaled linear operator with a complex(sp)-valued operator\nand . Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Base linear operator to be scaled. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') complex(kind=sp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => scaled_matvec_csp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => scaled_rmatvec_csp type, public, extends( abstract_linop_rdp ) :: scaled_linop_rdp Defines a scaled linear operator with a real-valued operator and . The definitions of matvec and rmatvec are directly inherited from those used to define A and do not have to be defined by the user. Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Base linear operator to be scaled. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=dp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => scaled_matvec_rdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => scaled_rmatvec_rdp type, public, extends( abstract_linop_rsp ) :: scaled_linop_rsp Defines a scaled linear operator with a real-valued operator and . The definitions of matvec and rmatvec are directly inherited from those used to define A and do not have to be defined by the user. Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Base linear operator to be scaled. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') real(kind=sp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => scaled_matvec_rsp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => scaled_rmatvec_rsp","tags":"","url":"module/lightkrylov_abstractlinops.html"},{"title":"LightKrylov_Utils – LightKrylov","text":"This module provides a set of utility functions used throughout LightKrylov .\nIt includes: assert_shape : Assert that the shape of the argument is the expected shape. eig : Compute the eigenvalue decomposition of a general matrix. sqrtm : Compute the non-negative square root of a symmetric positive definite matrix using its SVD. ordschur : Re-order the Schur factorization to have the selected eigenvalues in the upper left block. Note that as the development of stdlib progresses, some of these functions\nwill be deprecated in favor of the stdlib implementations. Uses LightKrylov_Logger iso_fortran_env LightKrylov_Constants Used by Descendants: utility_functions Interfaces public        interface apply_givens_rotation private pure module subroutine apply_givens_rotation_cdp(h, c, s) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout), target, contiguous :: h (:) k-th column of the Hessenberg matrix. complex(kind=dp), intent(inout) :: c (:) Cosine components of the Givens rotations. complex(kind=dp), intent(inout) :: s (:) Sine components of the Givens rotations. private pure module subroutine apply_givens_rotation_csp(h, c, s) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout), target, contiguous :: h (:) k-th column of the Hessenberg matrix. complex(kind=sp), intent(inout) :: c (:) Cosine components of the Givens rotations. complex(kind=sp), intent(inout) :: s (:) Sine components of the Givens rotations. private pure module subroutine apply_givens_rotation_rdp(h, c, s) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), target, contiguous :: h (:) k-th column of the Hessenberg matrix. real(kind=dp), intent(inout) :: c (:) Cosine components of the Givens rotations. real(kind=dp), intent(inout) :: s (:) Sine components of the Givens rotations. private pure module subroutine apply_givens_rotation_rsp(h, c, s) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), target, contiguous :: h (:) k-th column of the Hessenberg matrix. real(kind=sp), intent(inout) :: c (:) Cosine components of the Givens rotations. real(kind=sp), intent(inout) :: s (:) Sine components of the Givens rotations. public        interface assert_shape This interface provides methods to assert tha thte shape of its input vector or\nmatrix is as expected. It throws an error if not. private module subroutine assert_shape_matrix_cdp(A, size, matname, module, procedure) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: size (:) character(len=*), intent(in) :: matname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_matrix_csp(A, size, matname, module, procedure) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: size (:) character(len=*), intent(in) :: matname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_matrix_rdp(A, size, matname, module, procedure) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: size (:) character(len=*), intent(in) :: matname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_matrix_rsp(A, size, matname, module, procedure) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: size (:) character(len=*), intent(in) :: matname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_vector_cdp(v, size, vecname, module, procedure) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) integer, intent(in) :: size (:) character(len=*), intent(in) :: vecname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_vector_csp(v, size, vecname, module, procedure) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) integer, intent(in) :: size (:) character(len=*), intent(in) :: vecname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_vector_rdp(v, size, vecname, module, procedure) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) integer, intent(in) :: size (:) character(len=*), intent(in) :: vecname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure private module subroutine assert_shape_vector_rsp(v, size, vecname, module, procedure) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) integer, intent(in) :: size (:) character(len=*), intent(in) :: vecname character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure interface public module subroutine check_allocation(iostat, msg, module, procedure) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iostat character(len=*), intent(in) :: msg character(len=*), intent(in) :: module character(len=*), intent(in) :: procedure public        interface eig Computes the eigenvalue decomposition of a general square matrix. Description This interface provides methods to compute the solution to the eigenproblem , where $\\mathbf{A}$ is a square real or complex matrix. Result array lambda returns the eigenvalues of , while vecs returns the corresponding eigenvectors. Note that it follows the LAPACK convention\nwhen is real . The solver is based on LAPACK's *GEEV backends. Syntax call eig(A, vecs, lambda) Arguments A : real or complex square array containing the coefficient matrix. It is an intent(in) argument. vecs : Square array of the same size, type, and kind as A containing the eigenvectors\n(following LAPACK's convention for real matrices). It is an intent(out) argument. lambda : complex rank-1 array of the same kind as A containing the eigenvalues.\nIt is an intent(out) argument. Note Due to the abstrct nature of the vector types defined in LightKrylov , it is unlikely\nthat this implementation will be superseeded in favor of the stdlib one as the latter\ndoes not follow the LAPACK's convention. private module subroutine eig_cdp(A, vecs, vals) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) complex(kind=dp), intent(out) :: vecs (:,:) complex(kind=dp), intent(out) :: vals (:) private module subroutine eig_csp(A, vecs, vals) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) complex(kind=sp), intent(out) :: vecs (:,:) complex(kind=sp), intent(out) :: vals (:) private module subroutine eig_rdp(A, vecs, vals) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: vecs (:,:) complex(kind=dp), intent(out) :: vals (:) private module subroutine eig_rsp(A, vecs, vals) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(out) :: vecs (:,:) complex(kind=sp), intent(out) :: vals (:) public        interface givens_rotation private pure module function givens_rotation_cdp(x) result(g) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (2) Vector whose second entry needs to be eliminated. Return Value complex(kind=dp), (2) Entries of the Givens rotation matrix. private pure module function givens_rotation_csp(x) result(g) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (2) Vector whose second entry needs to be eliminated. Return Value complex(kind=sp), (2) Entries of the Givens rotation matrix. private pure module function givens_rotation_rdp(x) result(g) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (2) Vector whose second entry needs to be eliminated. Return Value real(kind=dp), (2) Entries of the Givens rotation matrix. private pure module function givens_rotation_rsp(x) result(g) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (2) Vector whose second entry needs to be eliminated. Return Value real(kind=sp), (2) Entries of the Givens rotation matrix. public        interface log2 Utility function to compute the base-2 logarithm of a real number. private elemental module function log2_rdp(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private elemental module function log2_rsp(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) public        interface ordschur Given the Schur factorization and basis of a matrix, reorders it to have the selected\neigenvalues in the upper left block. Description This interface provides methods to re-order the Schur factorization of a real or complex square matrix. Note that, if is real , it returns the\nreal Schur form. Syntax call ordschur(T, Q, selected) Arguments T : real or complex square array containing the Schur factorization of a matrix. \nOn exit, it is overwritten with its re-ordered counterpart. It is an intent(inout) argument. Q : Two-dimensional square array of the same size, type and kind as A . It contains\nthe original Schur basis on entry and the re-ordered one on exit.\nIt is an intent(inout) argument. selected : logical rank-1 array selecting which eigenvalues need to be moved in the\nupper left block of the Schur factorization. It is an intent(in) arguement. private module subroutine ordschur_cdp(T, Q, selected) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: T (:,:) complex(kind=dp), intent(inout) :: Q (:,:) logical, intent(in) :: selected (:) private module subroutine ordschur_csp(T, Q, selected) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: T (:,:) complex(kind=sp), intent(inout) :: Q (:,:) logical, intent(in) :: selected (:) private module subroutine ordschur_rdp(T, Q, selected) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: T (:,:) real(kind=dp), intent(inout) :: Q (:,:) logical, intent(in) :: selected (:) private module subroutine ordschur_rsp(T, Q, selected) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: T (:,:) real(kind=sp), intent(inout) :: Q (:,:) logical, intent(in) :: selected (:) public        interface sqrtm Computes the non-negative square root of a symmetric positive definite matrix\nusing its singular value decomposition. Description This interface provides methods to compute the non-negative square root of a symmetric\n(hermitian) positive definite matrix . Syntax call sqrtm(A, sqrtmA, info) Arguments A : Symmetric (hermitian) positive definite matrix whose non-negative square root\nneeds to be computed. It is an intent(in) argument. sqrtmA : Non-negative square root of A . It has the same size, kind and type as A .\nIt is an intent(out) argument. info : Information flag. It is an intent(out) argument. private module subroutine sqrtm_cdp(A, sqrtA, info) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: A (:,:) complex(kind=dp), intent(out) :: sqrtA (:,:) integer, intent(out) :: info private module subroutine sqrtm_csp(A, sqrtA, info) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: A (:,:) complex(kind=sp), intent(out) :: sqrtA (:,:) integer, intent(out) :: info private module subroutine sqrtm_rdp(A, sqrtA, info) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (:,:) real(kind=dp), intent(out) :: sqrtA (:,:) integer, intent(out) :: info private module subroutine sqrtm_rsp(A, sqrtA, info) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: A (:,:) real(kind=sp), intent(out) :: sqrtA (:,:) integer, intent(out) :: info Derived Types type, public, abstract :: abstract_metadata Abstract type for solver metadata from which all others are extended. Type-Bound Procedures procedure(abstract_print_metadata), public, deferred, pass(self) :: print procedure(abstract_reset_metadata), public, deferred, pass(self) :: reset type, public, abstract :: abstract_opts Abstract type for options from which all others are extended.","tags":"","url":"module/lightkrylov_utils.html"},{"title":"LightKrylov_TestUtils – LightKrylov","text":"Uses LightKrylov_Logger stdlib_linalg LightKrylov stdlib_optval stdlib_stats_distribution_normal LightKrylov_Constants Variables Type Visibility Attributes Name Initial integer, public, parameter :: test_size = 128 Interfaces public        interface get_data private  subroutine get_data_vec_rsp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: vec_out (:) type( vector_rsp ), intent(in) :: vec_in private  subroutine get_data_vec_basis_rsp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: basis_out (:,:) type( vector_rsp ), intent(in) :: basis_in (:) private  subroutine get_data_linop_rsp(mat_out, linop_in) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: mat_out (:,:) type( linop_rsp ), intent(in) :: linop_in private  subroutine get_data_vec_rdp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: vec_out (:) type( vector_rdp ), intent(in) :: vec_in private  subroutine get_data_vec_basis_rdp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: basis_out (:,:) type( vector_rdp ), intent(in) :: basis_in (:) private  subroutine get_data_linop_rdp(mat_out, linop_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: mat_out (:,:) type( linop_rdp ), intent(in) :: linop_in private  subroutine get_data_vec_csp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(out) :: vec_out (:) type( vector_csp ), intent(in) :: vec_in private  subroutine get_data_vec_basis_csp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(out) :: basis_out (:,:) type( vector_csp ), intent(in) :: basis_in (:) private  subroutine get_data_linop_csp(mat_out, linop_in) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(out) :: mat_out (:,:) type( linop_csp ), intent(in) :: linop_in private  subroutine get_data_vec_cdp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out) :: vec_out (:) type( vector_cdp ), intent(in) :: vec_in private  subroutine get_data_vec_basis_cdp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out) :: basis_out (:,:) type( vector_cdp ), intent(in) :: basis_in (:) private  subroutine get_data_linop_cdp(mat_out, linop_in) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out) :: mat_out (:,:) type( linop_cdp ), intent(in) :: linop_in public        interface get_err_str private  subroutine get_err_str_sp(msg, info, err) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: msg character(len=*), intent(in) :: info real(kind=sp), intent(in) :: err private  subroutine get_err_str_dp(msg, info, err) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: msg character(len=*), intent(in) :: info real(kind=dp), intent(in) :: err public        interface hermitian_linop_cdp private module function construct_hermitian_linop_cdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( hermitian_linop_cdp ) public        interface hermitian_linop_csp private module function construct_hermitian_linop_csp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( hermitian_linop_csp ) public        interface init_rand private  subroutine init_rand_vec_rsp(x) Arguments Type Intent Optional Attributes Name type( vector_rsp ), intent(inout) :: x private  subroutine init_rand_basis_rsp(X) Arguments Type Intent Optional Attributes Name type( vector_rsp ), intent(inout) :: X (:) private  subroutine init_rand_linop_rsp(linop) Arguments Type Intent Optional Attributes Name type( linop_rsp ), intent(inout) :: linop private  subroutine init_rand_spd_linop_rsp(linop) Arguments Type Intent Optional Attributes Name type( spd_linop_rsp ), intent(inout) :: linop private  subroutine init_rand_vec_rdp(x) Arguments Type Intent Optional Attributes Name type( vector_rdp ), intent(inout) :: x private  subroutine init_rand_basis_rdp(X) Arguments Type Intent Optional Attributes Name type( vector_rdp ), intent(inout) :: X (:) private  subroutine init_rand_linop_rdp(linop) Arguments Type Intent Optional Attributes Name type( linop_rdp ), intent(inout) :: linop private  subroutine init_rand_spd_linop_rdp(linop) Arguments Type Intent Optional Attributes Name type( spd_linop_rdp ), intent(inout) :: linop private  subroutine init_rand_vec_csp(x) Arguments Type Intent Optional Attributes Name type( vector_csp ), intent(inout) :: x private  subroutine init_rand_basis_csp(X) Arguments Type Intent Optional Attributes Name type( vector_csp ), intent(inout) :: X (:) private  subroutine init_rand_linop_csp(linop) Arguments Type Intent Optional Attributes Name type( linop_csp ), intent(inout) :: linop private  subroutine init_rand_hermitian_linop_csp(linop) Arguments Type Intent Optional Attributes Name type( hermitian_linop_csp ), intent(inout) :: linop private  subroutine init_rand_vec_cdp(x) Arguments Type Intent Optional Attributes Name type( vector_cdp ), intent(inout) :: x private  subroutine init_rand_basis_cdp(X) Arguments Type Intent Optional Attributes Name type( vector_cdp ), intent(inout) :: X (:) private  subroutine init_rand_linop_cdp(linop) Arguments Type Intent Optional Attributes Name type( linop_cdp ), intent(inout) :: linop private  subroutine init_rand_hermitian_linop_cdp(linop) Arguments Type Intent Optional Attributes Name type( hermitian_linop_cdp ), intent(inout) :: linop public        interface linop_cdp private module function construct_linop_cdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_cdp ) public        interface linop_csp private module function construct_linop_csp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_csp ) public        interface linop_rdp private module function construct_linop_rdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_rdp ) public        interface linop_rsp private module function construct_linop_rsp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_rsp ) public        interface put_data private  subroutine put_data_vec_rsp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name type( vector_rsp ), intent(out) :: vec_out real(kind=sp), intent(in) :: vec_in private  subroutine put_data_vec_basis_rsp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name type( vector_rsp ), intent(out) :: basis_out (:) real(kind=sp), intent(in) :: basis_in (:,:) private  subroutine put_data_linop_rsp(linop_out, mat_in) Arguments Type Intent Optional Attributes Name type( linop_rsp ), intent(out) :: linop_out real(kind=sp), intent(in) :: mat_in (:,:) private  subroutine put_data_vec_rdp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name type( vector_rdp ), intent(out) :: vec_out real(kind=dp), intent(in) :: vec_in private  subroutine put_data_vec_basis_rdp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name type( vector_rdp ), intent(out) :: basis_out (:) real(kind=dp), intent(in) :: basis_in (:,:) private  subroutine put_data_linop_rdp(linop_out, mat_in) Arguments Type Intent Optional Attributes Name type( linop_rdp ), intent(out) :: linop_out real(kind=dp), intent(in) :: mat_in (:,:) private  subroutine put_data_vec_csp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name type( vector_csp ), intent(out) :: vec_out complex(kind=sp), intent(in) :: vec_in private  subroutine put_data_vec_basis_csp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name type( vector_csp ), intent(out) :: basis_out (:) complex(kind=sp), intent(in) :: basis_in (:,:) private  subroutine put_data_linop_csp(linop_out, mat_in) Arguments Type Intent Optional Attributes Name type( linop_csp ), intent(out) :: linop_out complex(kind=sp), intent(in) :: mat_in (:,:) private  subroutine put_data_vec_cdp(vec_out, vec_in) Arguments Type Intent Optional Attributes Name type( vector_cdp ), intent(out) :: vec_out complex(kind=dp), intent(in) :: vec_in private  subroutine put_data_vec_basis_cdp(basis_out, basis_in) Arguments Type Intent Optional Attributes Name type( vector_cdp ), intent(out) :: basis_out (:) complex(kind=dp), intent(in) :: basis_in (:,:) private  subroutine put_data_linop_cdp(linop_out, mat_in) Arguments Type Intent Optional Attributes Name type( linop_cdp ), intent(out) :: linop_out complex(kind=dp), intent(in) :: mat_in (:,:) public        interface spd_linop_rdp private module function construct_spd_linop_rdp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( spd_linop_rdp ) public        interface spd_linop_rsp private module function construct_spd_linop_rsp(data) result(A) Implementation → Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( spd_linop_rsp ) Derived Types type, public, extends( abstract_hermitian_linop_cdp ) :: hermitian_linop_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public, dimension(test_size, test_size) :: data = zero_cdp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor private\n\n                    module\n                    function construct_hermitian_linop_cdp (data) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_herm_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => hermitian_matvec_cdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => hermitian_matvec_cdp type, public, extends( abstract_hermitian_linop_csp ) :: hermitian_linop_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public, dimension(test_size, test_size) :: data = zero_csp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor private\n\n                    module\n                    function construct_hermitian_linop_csp (data) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_herm_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => hermitian_matvec_csp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => hermitian_matvec_csp type, public, extends( abstract_jacobian_linop_cdp ) :: jacobian_cdp Components Type Visibility Attributes Name Initial class( abstract_vector_cdp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => lin_roessler_cdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => adj_lin_roessler_cdp type, public, extends( abstract_jacobian_linop_csp ) :: jacobian_csp Components Type Visibility Attributes Name Initial class( abstract_vector_csp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => lin_roessler_csp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => adj_lin_roessler_csp type, public, extends( abstract_jacobian_linop_rdp ) :: jacobian_rdp Components Type Visibility Attributes Name Initial class( abstract_vector_rdp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => lin_roessler_rdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => adj_lin_roessler_rdp type, public, extends( abstract_jacobian_linop_rsp ) :: jacobian_rsp Components Type Visibility Attributes Name Initial class( abstract_vector_rsp ), public, allocatable :: X System state around which the equatons are linearized. type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => lin_roessler_rsp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => adj_lin_roessler_rsp type, public, extends( abstract_linop_cdp ) :: linop_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public, dimension(test_size, test_size) :: data = zero_cdp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor private\n\n                    module\n                    function construct_linop_cdp (data) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_cdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_cdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => matvec_cdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => rmatvec_cdp type, public, extends( abstract_linop_csp ) :: linop_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public, dimension(test_size, test_size) :: data = zero_csp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor private\n\n                    module\n                    function construct_linop_csp (data) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_csp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_csp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => matvec_csp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => rmatvec_csp type, public, extends( abstract_linop_rdp ) :: linop_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(test_size, test_size) :: data = 0.0_dp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor private\n\n                    module\n                    function construct_linop_rdp (data) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rdp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => matvec_rdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => rmatvec_rdp type, public, extends( abstract_linop_rsp ) :: linop_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public, dimension(test_size, test_size) :: data = 0.0_sp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor private\n\n                    module\n                    function construct_linop_rsp (data) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: apply_rmatvec => apply_rmatvec_rsp Wrapper for rmatvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => matvec_rsp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => rmatvec_rsp type, public, extends( abstract_system_cdp ) :: roessler_cdp Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_cdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_cdp Wrapper for response including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history procedure, public, pass(self) :: get_eval_counter Return eval counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_eval_counter Reset eval counter procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data procedure, public, pass(self) :: response => eval_roessler_cdp type, public, extends( abstract_system_csp ) :: roessler_csp Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_csp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_csp Wrapper for response including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history procedure, public, pass(self) :: get_eval_counter Return eval counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_eval_counter Reset eval counter procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data procedure, public, pass(self) :: response => eval_roessler_csp type, public, extends( abstract_system_rdp ) :: roessler_rdp Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_rdp Wrapper for response including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history procedure, public, pass(self) :: get_eval_counter Return eval counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_eval_counter Reset eval counter procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data procedure, public, pass(self) :: response => eval_roessler_rdp type, public, extends( abstract_system_rsp ) :: roessler_rsp Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rsp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure, public, pass(self) :: eval => eval_rsp Wrapper for response including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_eval_timer Finalize timer and print complete history procedure, public, pass(self) :: get_eval_counter Return eval counter value procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_eval_counter Reset eval counter procedure, public, pass(self) :: reset_timer => reset_eval_timer Reset current timing data procedure, public, pass(self) :: response => eval_roessler_rsp type, public, extends( abstract_sym_linop_rdp ) :: spd_linop_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(test_size, test_size) :: data = 0.0_dp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor private\n\n                    module\n                    function construct_spd_linop_rdp (data) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_sym_matvec_rdp Wrapper for matvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => sdp_matvec_rdp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => sdp_matvec_rdp type, public, extends( abstract_sym_linop_rsp ) :: spd_linop_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public, dimension(test_size, test_size) :: data = 0.0_sp type( lightkrylov_timer ), public :: matvec_timer = lightkrylov_timer('matvec timer') type( lightkrylov_timer ), public :: rmatvec_timer = lightkrylov_timer('rmatvec timer') Constructor private\n\n                    module\n                    function construct_spd_linop_rsp (data) Type-Bound Procedures procedure, public, pass(self) :: apply_matvec => apply_sym_matvec_rsp Wrapper for matvec including the counter increment procedure, public, pass(self) :: finalize_timer => finalize_linop_timer Finalize timers and print complete history_info procedure, public, pass(self) :: get_counter Return matvec/rmatvec counter value procedure, public, pass(self) :: matvec => sdp_matvec_rsp procedure, public, pass(self) :: print_timer_info Print current timing data procedure, public, pass(self) :: reset_counter Reset matvec/rmatvec counter procedure, public, pass(self) :: reset_timer => reset_linop_timer Reset current timing data procedure, public, pass(self) :: rmatvec => sdp_matvec_rsp type, public, extends( abstract_vector_cdp ) :: state_vector_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public :: x = cmplx(0.0_dp, 0.0_dp, kind=dp) complex(kind=dp), public :: y = cmplx(0.0_dp, 0.0_dp, kind=dp) complex(kind=dp), public :: z = cmplx(0.0_dp, 0.0_dp, kind=dp) Type-Bound Procedures procedure, public, pass(self) :: add => add_cdp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => axpby_state_cdp procedure, public, pass(self) :: chsgn => chsgn_cdp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dot_state_cdp procedure, public, pass(self) :: get_size => get_size_state_cdp procedure, public, pass(self) :: norm => norm_cdp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => rand_state_cdp procedure, public, pass(self) :: scal => scal_state_cdp procedure, public, pass(self) :: sub => sub_cdp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => zero_state_cdp type, public, extends( abstract_vector_csp ) :: state_vector_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public :: x = cmplx(0.0_sp, 0.0_sp, kind=sp) complex(kind=sp), public :: y = cmplx(0.0_sp, 0.0_sp, kind=sp) complex(kind=sp), public :: z = cmplx(0.0_sp, 0.0_sp, kind=sp) Type-Bound Procedures procedure, public, pass(self) :: add => add_csp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => axpby_state_csp procedure, public, pass(self) :: chsgn => chsgn_csp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dot_state_csp procedure, public, pass(self) :: get_size => get_size_state_csp procedure, public, pass(self) :: norm => norm_csp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => rand_state_csp procedure, public, pass(self) :: scal => scal_state_csp procedure, public, pass(self) :: sub => sub_csp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => zero_state_csp type, public, extends( abstract_vector_rdp ) :: state_vector_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public :: x = 0.0_dp real(kind=dp), public :: y = 0.0_dp real(kind=dp), public :: z = 0.0_dp Type-Bound Procedures procedure, public, pass(self) :: add => add_rdp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => axpby_state_rdp procedure, public, pass(self) :: chsgn => chsgn_rdp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dot_state_rdp procedure, public, pass(self) :: get_size => get_size_state_rdp procedure, public, pass(self) :: norm => norm_rdp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => rand_state_rdp procedure, public, pass(self) :: scal => scal_state_rdp procedure, public, pass(self) :: sub => sub_rdp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => zero_state_rdp type, public, extends( abstract_vector_rsp ) :: state_vector_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public :: x = 0.0_sp real(kind=sp), public :: y = 0.0_sp real(kind=sp), public :: z = 0.0_sp Type-Bound Procedures procedure, public, pass(self) :: add => add_rsp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => axpby_state_rsp procedure, public, pass(self) :: chsgn => chsgn_rsp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dot_state_rsp procedure, public, pass(self) :: get_size => get_size_state_rsp procedure, public, pass(self) :: norm => norm_rsp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => rand_state_rsp procedure, public, pass(self) :: scal => scal_state_rsp procedure, public, pass(self) :: sub => sub_rsp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => zero_state_rsp type, public, extends( abstract_vector_cdp ) :: vector_cdp Components Type Visibility Attributes Name Initial complex(kind=dp), public, dimension(test_size) :: data = 0.0_dp Type-Bound Procedures procedure, public, pass(self) :: add => add_cdp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => axpby_cdp procedure, public, pass(self) :: chsgn => chsgn_cdp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dot_cdp procedure, public, pass(self) :: get_size => get_size_cdp procedure, public, pass(self) :: norm => norm_cdp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => rand_cdp procedure, public, pass(self) :: scal => scal_cdp procedure, public, pass(self) :: sub => sub_cdp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => init_zero_cdp type, public, extends( abstract_vector_csp ) :: vector_csp Components Type Visibility Attributes Name Initial complex(kind=sp), public, dimension(test_size) :: data = 0.0_sp Type-Bound Procedures procedure, public, pass(self) :: add => add_csp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => axpby_csp procedure, public, pass(self) :: chsgn => chsgn_csp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dot_csp procedure, public, pass(self) :: get_size => get_size_csp procedure, public, pass(self) :: norm => norm_csp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => rand_csp procedure, public, pass(self) :: scal => scal_csp procedure, public, pass(self) :: sub => sub_csp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => init_zero_csp type, public, extends( abstract_vector_rdp ) :: vector_rdp Components Type Visibility Attributes Name Initial real(kind=dp), public, dimension(test_size) :: data = 0.0_dp Type-Bound Procedures procedure, public, pass(self) :: add => add_rdp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => axpby_rdp procedure, public, pass(self) :: chsgn => chsgn_rdp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dot_rdp procedure, public, pass(self) :: get_size => get_size_rdp procedure, public, pass(self) :: norm => norm_rdp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => rand_rdp procedure, public, pass(self) :: scal => scal_rdp procedure, public, pass(self) :: sub => sub_rdp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => init_zero_rdp type, public, extends( abstract_vector_rsp ) :: vector_rsp Components Type Visibility Attributes Name Initial real(kind=sp), public, dimension(test_size) :: data = 0.0_sp Type-Bound Procedures procedure, public, pass(self) :: add => add_rsp Adds two abstract_vector , i.e. . procedure, public, pass(self) :: axpby => axpby_rsp procedure, public, pass(self) :: chsgn => chsgn_rsp Change the sign of a vector, i.e. . procedure, public, pass(self) :: dot => dot_rsp procedure, public, pass(self) :: get_size => get_size_rsp procedure, public, pass(self) :: norm => norm_rsp Computes the norm of the abstract_vector . procedure, public, pass(self) :: rand => rand_rsp procedure, public, pass(self) :: scal => scal_rsp procedure, public, pass(self) :: sub => sub_rsp Subtracts two abstract_vector , i.e. . procedure, public, pass(self) :: zero => init_zero_rsp Subroutines public  subroutine get_state_cdp (state, X, Y, z) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: state real(kind=dp), intent(out) :: X real(kind=dp), intent(out) :: Y real(kind=dp), intent(out) :: z public  subroutine get_state_csp (state, X, Y, z) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: state real(kind=sp), intent(out) :: X real(kind=sp), intent(out) :: Y real(kind=sp), intent(out) :: z public  subroutine get_state_rdp (state, X, Y, z) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: state real(kind=dp), intent(out) :: X real(kind=dp), intent(out) :: Y real(kind=dp), intent(out) :: z public  subroutine get_state_rsp (state, X, Y, z) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: state real(kind=sp), intent(out) :: X real(kind=sp), intent(out) :: Y real(kind=sp), intent(out) :: z public  subroutine roessler_analytical_fp_cdp (fp1, fp2) Arguments Type Intent Optional Attributes Name class( state_vector_cdp ), intent(out) :: fp1 class( state_vector_cdp ), intent(out) :: fp2 public  subroutine roessler_analytical_fp_csp (fp1, fp2) Arguments Type Intent Optional Attributes Name class( state_vector_csp ), intent(out) :: fp1 class( state_vector_csp ), intent(out) :: fp2 public  subroutine roessler_analytical_fp_rdp (fp1, fp2) Arguments Type Intent Optional Attributes Name class( state_vector_rdp ), intent(out) :: fp1 class( state_vector_rdp ), intent(out) :: fp2 public  subroutine roessler_analytical_fp_rsp (fp1, fp2) Arguments Type Intent Optional Attributes Name class( state_vector_rsp ), intent(out) :: fp1 class( state_vector_rsp ), intent(out) :: fp2 Module Procedures module procedure /github/workspace/API-doc/module/lightkrylov_testutils.html construct_hermitian_linop_cdp private module function construct_hermitian_linop_cdp(data) result(A) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( hermitian_linop_cdp ) module procedure /github/workspace/API-doc/module/lightkrylov_testutils.html construct_hermitian_linop_csp private module function construct_hermitian_linop_csp(data) result(A) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( hermitian_linop_csp ) module procedure /github/workspace/API-doc/module/lightkrylov_testutils.html construct_linop_cdp private module function construct_linop_cdp(data) result(A) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_cdp ) module procedure /github/workspace/API-doc/module/lightkrylov_testutils.html construct_linop_csp private module function construct_linop_csp(data) result(A) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_csp ) module procedure /github/workspace/API-doc/module/lightkrylov_testutils.html construct_linop_rdp private module function construct_linop_rdp(data) result(A) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_rdp ) module procedure /github/workspace/API-doc/module/lightkrylov_testutils.html construct_linop_rsp private module function construct_linop_rsp(data) result(A) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( linop_rsp ) module procedure /github/workspace/API-doc/module/lightkrylov_testutils.html construct_spd_linop_rdp private module function construct_spd_linop_rdp(data) result(A) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(test_size, test_size) :: data Return Value type( spd_linop_rdp ) module procedure /github/workspace/API-doc/module/lightkrylov_testutils.html construct_spd_linop_rsp private module function construct_spd_linop_rsp(data) result(A) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(test_size, test_size) :: data Return Value type( spd_linop_rsp )","tags":"","url":"module/lightkrylov_testutils.html"},{"title":"LightKrylov_Timing – LightKrylov","text":"This module provides a set of utility functions to define default timers within LightKrylov . Uses LightKrylov_Logger stdlib_ascii LightKrylov_Timer_Utils stdlib_optval Variables Type Visibility Attributes Name Initial type( lightkrylov_watch ), public :: global_lightkrylov_timer Derived Types type, public, extends( abstract_watch ) :: lightkrylov_watch Global timing structure to contain all timers within Lightkrylov Type-Bound Procedures procedure, public, pass(self) :: add_group Add new timer group to the watch. procedure, public, pass(self) :: add_timer Add new timer to the watch. procedure, public, pass(self) :: enumerate Print summary of registered timers and their current status. procedure, public, pass(self) :: finalize Gather timing information and print it to screen/logfile. procedure, public, pass(self) :: get_called Get the number and names of timer called (locally or globally) procedure, public, pass(self) :: get_data => get_timer_data_by_name procedure, public, pass(self) :: get_data_save => get_timer_data_save_by_name procedure, public, pass(self) :: get_group_id procedure, public, pass(self) :: get_time => get_timer_etime_by_name procedure, public, pass(self) :: get_timer_id procedure, public, pass(self) :: initialize Set up private timers, flags and counters. Switch on timing. procedure, public, pass(self) :: pause => pause_timer_by_name procedure, public, pass(self) :: print_info => print_timer_info_by_name procedure, public, pass(self) :: remove_timer Remove existing timer from the watch. procedure, public, pass(self) :: reset => reset_timer_by_name procedure, public, pass(self) :: reset_all Reset all timers in watch. procedure, public, pass(self) :: set_private_timers_and_name => set_lightkrylov_timers procedure, public, pass(self) :: set_watch_name procedure, public, pass(self) :: start => start_timer_by_name procedure, public, pass(self) :: stop => stop_timer_by_name Functions public pure function time_lightkrylov () result(if_time_lightkrylov) Arguments None Return Value logical","tags":"","url":"module/lightkrylov_timing.html"},{"title":"LightKrylov_ExpmLib – LightKrylov","text":"This module implements the evaluation of the \"matrix-exponential times vector\" procedure\nusing Krylov methods. Uses LightKrylov_Logger LightKrylov_Utils stdlib_linalg iso_fortran_env LightKrylov_AbstractLinops LightKrylov_BaseKrylov stdlib_optval LightKrylov_AbstractVectors LightKrylov_Constants Interfaces public        interface kexpm Description This interface provides methods to evaluate the matrix-vector product based on the Arnoldi method. Syntax call kexpm ( c , A , b , tau , tol , info [, trans ] [, kdim ]) Arguments c :   Output vector (or vectors). It is an intent(out) argument. A :   Linear operator to be exponentiated. It is an intent(inout) argument. b :   Vector to be multiplied by . It is an intent(in) argument. tau : real (singe or double) time over which the matrix exponential needs to\n            be computed. It is an intent(in) argument. info : integer Information flag. trans (optional)    :   Whether or is being used.\n                            (default trans=.false. ) kdim (optional)     :   Dimension of the Krylov subspace used in the Arnoldi method. private  subroutine kexpm_vec_rsp(c, A, b, tau, tol, info, trans, kdim) Best approximation of in the computed Krylov subspace Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: c class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: b Input vector on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_rsp(C, A, B, tau, tol, info, trans, kdim) Best Krylov approximation of in the computed Krylov subspace. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: C (:) class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_rdp(c, A, b, tau, tol, info, trans, kdim) Best approximation of in the computed Krylov subspace Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: c class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: b Input vector on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_rdp(C, A, B, tau, tol, info, trans, kdim) Best Krylov approximation of in the computed Krylov subspace. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: C (:) class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_csp(c, A, b, tau, tol, info, trans, kdim) Best approximation of in the computed Krylov subspace Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: c class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: b Input vector on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_csp(C, A, B, tau, tol, info, trans, kdim) Best Krylov approximation of in the computed Krylov subspace. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: C (:) class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_cdp(c, A, b, tau, tol, info, trans, kdim) Best approximation of in the computed Krylov subspace Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: c class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: b Input vector on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_cdp(C, A, B, tau, tol, info, trans, kdim) Best Krylov approximation of in the computed Krylov subspace. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: C (:) class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. public        interface krylov_exptA Description Utility function to evaluate the matrix-exponential times vector. Syntax call k_exptA ( vec_out , A , vec_in , tau , info , trans ) Arguments vec_out :   Output vector. A :   Matrix to be exponentiated. vec_in :   Input vector. tau :   Integration time. info :   Information flag. trans :   Whether or is being used. public  subroutine krylov_exptA_rsp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_rsp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? public  subroutine krylov_exptA_rdp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_rdp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? public  subroutine krylov_exptA_csp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_csp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: vec_out Solution vector. class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? public  subroutine krylov_exptA_cdp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_cdp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? Abstract Interfaces abstract interface public  subroutine abstract_exptA_cdp(vec_out, A, vec_in, tau, info, trans) Abstract interface to define the matrix exponential-vector product. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: vec_in Input vector. real(kind=dp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? abstract interface public  subroutine abstract_exptA_csp(vec_out, A, vec_in, tau, info, trans) Abstract interface to define the matrix exponential-vector product. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: vec_out Solution vector. class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: vec_in Input vector. real(kind=sp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? abstract interface public  subroutine abstract_exptA_rdp(vec_out, A, vec_in, tau, info, trans) Abstract interface to define the matrix exponential-vector product. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: vec_in Input vector. real(kind=dp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? abstract interface public  subroutine abstract_exptA_rsp(vec_out, A, vec_in, tau, info, trans) Abstract interface to define the matrix exponential-vector product. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: vec_in Input vector. real(kind=sp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? Subroutines public  subroutine krylov_exptA_cdp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_cdp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? public  subroutine krylov_exptA_csp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_csp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: vec_out Solution vector. class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? public  subroutine krylov_exptA_rdp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_rdp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? public  subroutine krylov_exptA_rsp (vec_out, A, vec_in, tau, info, trans) Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator \non a vector that conforms to the abstract_exptA_rsp interface. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ?","tags":"","url":"module/lightkrylov_expmlib.html"},{"title":"krylov_utilities – LightKrylov","text":"Uses Ancestors: LightKrylov_BaseKrylov","tags":"","url":"module/krylov_utilities.html"},{"title":"svds_solver – LightKrylov","text":"Uses stdlib_linalg Ancestors: LightKrylov_IterativeSolvers","tags":"","url":"module/svds_solver.html"},{"title":"arnoldi_method – LightKrylov","text":"Uses Ancestors: LightKrylov_BaseKrylov","tags":"","url":"module/arnoldi_method.html"},{"title":"gram_schmidt_process – LightKrylov","text":"Uses Ancestors: LightKrylov_BaseKrylov","tags":"","url":"module/gram_schmidt_process.html"},{"title":"lanczos_methods – LightKrylov","text":"Uses Ancestors: LightKrylov_BaseKrylov","tags":"","url":"module/lanczos_methods.html"},{"title":"cg_solver – LightKrylov","text":"Uses stdlib_strings Ancestors: LightKrylov_IterativeSolvers","tags":"","url":"module/cg_solver.html"},{"title":"fgmres_solver – LightKrylov","text":"Uses stdlib_linalg_lapack stdlib_linalg stdlib_strings Ancestors: LightKrylov_IterativeSolvers","tags":"","url":"module/fgmres_solver.html"},{"title":"qr_solvers – LightKrylov","text":"Uses Ancestors: LightKrylov_BaseKrylov","tags":"","url":"module/qr_solvers.html"},{"title":"utility_functions – LightKrylov","text":"Uses LightKrylov_Timing stdlib_linalg_lapack stdlib_linalg stdlib_linalg_constants stdlib_optval Ancestors: LightKrylov_Utils","tags":"","url":"module/utility_functions.html"},{"title":"golub_kahan_methods – LightKrylov","text":"Uses Ancestors: LightKrylov_BaseKrylov","tags":"","url":"module/golub_kahan_methods.html"},{"title":"gmres_solver – LightKrylov","text":"Uses stdlib_linalg_lapack stdlib_strings Ancestors: LightKrylov_IterativeSolvers","tags":"","url":"module/gmres_solver.html"},{"title":"hermitian_eigensolvers – LightKrylov","text":"Uses stdlib_linalg stdlib_strings Ancestors: LightKrylov_IterativeSolvers","tags":"","url":"module/hermitian_eigensolvers.html"},{"title":"utilities.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_basekrylov ) krylov_utilities implicit none ( type , external ) contains !---------------------------------------- !-----     Permutation matrices     ----- !---------------------------------------- module procedure permcols_basis_rsp call copy ( Q , Q ( perm )) end procedure permcols_basis_rsp module procedure permcols_array_rsp Q = Q (:, perm ) end procedure permcols_array_rsp module procedure permcols_basis_rdp call copy ( Q , Q ( perm )) end procedure permcols_basis_rdp module procedure permcols_array_rdp Q = Q (:, perm ) end procedure permcols_array_rdp module procedure permcols_basis_csp call copy ( Q , Q ( perm )) end procedure permcols_basis_csp module procedure permcols_array_csp Q = Q (:, perm ) end procedure permcols_array_csp module procedure permcols_basis_cdp call copy ( Q , Q ( perm )) end procedure permcols_basis_cdp module procedure permcols_array_cdp Q = Q (:, perm ) end procedure permcols_array_cdp module procedure invperm integer :: i , iostat character ( len = 100 ) :: errmsg allocate ( inv_perm ( size ( perm )), source = 0 , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"invperm\" ) inv_perm ( perm ) = [( i , i = 1 , size ( perm ))] end procedure invperm !---------------------------------------------- !-----     Initialize Krylov subspace     ----- !---------------------------------------------- module procedure initialize_krylov_subspace_rsp integer :: p ! Zero-out X. call zero_basis ( X ) ! Deals with optional args. if ( present ( X0 )) then p = size ( X0 ) ! Initialize. call copy ( X (: p ), X0 ) ! Orthonormalize. call orthonormalize_basis ( X (: p )) endif end procedure initialize_krylov_subspace_rsp module procedure initialize_krylov_subspace_rdp integer :: p ! Zero-out X. call zero_basis ( X ) ! Deals with optional args. if ( present ( X0 )) then p = size ( X0 ) ! Initialize. call copy ( X (: p ), X0 ) ! Orthonormalize. call orthonormalize_basis ( X (: p )) endif end procedure initialize_krylov_subspace_rdp module procedure initialize_krylov_subspace_csp integer :: p ! Zero-out X. call zero_basis ( X ) ! Deals with optional args. if ( present ( X0 )) then p = size ( X0 ) ! Initialize. call copy ( X (: p ), X0 ) ! Orthonormalize. call orthonormalize_basis ( X (: p )) endif end procedure initialize_krylov_subspace_csp module procedure initialize_krylov_subspace_cdp integer :: p ! Zero-out X. call zero_basis ( X ) ! Deals with optional args. if ( present ( X0 )) then p = size ( X0 ) ! Initialize. call copy ( X (: p ), X0 ) ! Orthonormalize. call orthonormalize_basis ( X (: p )) endif end procedure initialize_krylov_subspace_cdp !------------------------------------------------------- !-----     Initialize random orthonormal basis     ----- !------------------------------------------------------- module procedure initialize_random_orthonormal_basis_rsp integer :: p ! Fill with random data call rand_basis ( X ) ! Orthonormalize call orthonormalize_basis ( X ) end procedure initialize_random_orthonormal_basis_rsp module procedure initialize_random_orthonormal_basis_rdp integer :: p ! Fill with random data call rand_basis ( X ) ! Orthonormalize call orthonormalize_basis ( X ) end procedure initialize_random_orthonormal_basis_rdp module procedure initialize_random_orthonormal_basis_csp integer :: p ! Fill with random data call rand_basis ( X ) ! Orthonormalize call orthonormalize_basis ( X ) end procedure initialize_random_orthonormal_basis_csp module procedure initialize_random_orthonormal_basis_cdp integer :: p ! Fill with random data call rand_basis ( X ) ! Orthonormalize call orthonormalize_basis ( X ) end procedure initialize_random_orthonormal_basis_cdp !---------------------------------------- !-----     Orthonormalize basis     ----- !---------------------------------------- module procedure orthonormalize_basis_rsp character ( len =* ), parameter :: this_procedure = 'orthonormalize_basis_rsp' real ( sp ) :: R ( size ( X ), size ( X )) integer :: info if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! internals call qr ( X , R , info ) call check_info ( info , 'qr' , this_module , this_procedure ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthonormalize_basis_rsp module procedure orthonormalize_basis_rdp character ( len =* ), parameter :: this_procedure = 'orthonormalize_basis_rdp' real ( dp ) :: R ( size ( X ), size ( X )) integer :: info if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! internals call qr ( X , R , info ) call check_info ( info , 'qr' , this_module , this_procedure ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthonormalize_basis_rdp module procedure orthonormalize_basis_csp character ( len =* ), parameter :: this_procedure = 'orthonormalize_basis_csp' complex ( sp ) :: R ( size ( X ), size ( X )) integer :: info if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! internals call qr ( X , R , info ) call check_info ( info , 'qr' , this_module , this_procedure ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthonormalize_basis_csp module procedure orthonormalize_basis_cdp character ( len =* ), parameter :: this_procedure = 'orthonormalize_basis_cdp' complex ( dp ) :: R ( size ( X ), size ( X )) integer :: info if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! internals call qr ( X , R , info ) call check_info ( info , 'qr' , this_module , this_procedure ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthonormalize_basis_cdp !--------------------------------------------------- !-----     Check orthonormality of a basis     ----- !--------------------------------------------------- module procedure is_orthonormal_rsp real ( sp ), dimension ( size ( X ), size ( X )) :: G ortho = . true . G = Gram ( X ) if ( mnorm ( G - eye ( size ( X )), \"Fro\" ) > rtol_sp ) then ! The basis is not orthonormal. ortho = . false . end if end procedure is_orthonormal_rsp module procedure is_orthonormal_rdp real ( dp ), dimension ( size ( X ), size ( X )) :: G ortho = . true . G = Gram ( X ) if ( mnorm ( G - eye ( size ( X )), \"Fro\" ) > rtol_sp ) then ! The basis is not orthonormal. ortho = . false . end if end procedure is_orthonormal_rdp module procedure is_orthonormal_csp complex ( sp ), dimension ( size ( X ), size ( X )) :: G ortho = . true . G = Gram ( X ) if ( mnorm ( G - eye ( size ( X )), \"Fro\" ) > rtol_sp ) then ! The basis is not orthonormal. ortho = . false . end if end procedure is_orthonormal_csp module procedure is_orthonormal_cdp complex ( dp ), dimension ( size ( X ), size ( X )) :: G ortho = . true . G = Gram ( X ) if ( mnorm ( G - eye ( size ( X )), \"Fro\" ) > rtol_sp ) then ! The basis is not orthonormal. ortho = . false . end if end procedure is_orthonormal_cdp end submodule krylov_utilities","tags":"","url":"sourcefile/utilities.f90.html"},{"title":"NewtonKrylov.f90 – LightKrylov","text":"Source Code module LightKrylov_NewtonKrylov use stdlib_optval , only : optval use stdlib_strings , only : padr use LightKrylov_Constants use LightKrylov_Logger use LightKrylov_Timing , only : timer => global_lightkrylov_timer , time_lightkrylov use LightKrylov_AbstractVectors use LightKrylov_AbstractLinops use LightKrylov_AbstractSystems use LightKrylov_IterativeSolvers use LightKrylov_Utils implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_NwtKryl' character ( len =* ), parameter :: this_module_long = 'LightKrylov_NewtonKrylov' public :: newton public :: constant_tol_sp public :: dynamic_tol_sp public :: constant_tol_dp public :: dynamic_tol_dp type , extends ( abstract_opts ), public :: newton_sp_opts !! Options for Newton-Krylov fixed-point iteration. integer :: maxiter = 100 !! Maximum number of Newton iterations (default = 100) logical :: ifbisect = . false . !! Bisection toggle to enforce residual reduction (default = .false.) integer :: maxstep_bisection = 5 !! Maximum number of bisections (evaluations of F) for step selection (default = 5) !! Ignored if ifbisect = .false. logical :: if_print_metadata = . false . !! Print interation metadata on exit (default = .false.) end type newton_sp_opts type , extends ( abstract_opts ), public :: newton_dp_opts !! Options for Newton-Krylov fixed-point iteration. integer :: maxiter = 100 !! Maximum number of Newton iterations (default = 100) logical :: ifbisect = . false . !! Bisection toggle to enforce residual reduction (default = .false.) integer :: maxstep_bisection = 5 !! Maximum number of bisections (evaluations of F) for step selection (default = 5) !! Ignored if ifbisect = .false. logical :: if_print_metadata = . false . !! Print interation metadata on exit (default = .false.) end type newton_dp_opts type , extends ( abstract_metadata ), public :: newton_sp_metadata !! Metadata for Newton-Krylov fixed-point iteration. integer :: n_iter = 0 !! Iteration counter integer :: eval_counter_record = 0 !! System response evaluation counter: !! N.B.: For each of these evals the current residual and tolerance are recorded. real ( sp ), dimension (:), allocatable :: res !! Residual history real ( sp ), dimension (:), allocatable :: tol !! Tolerance history logical :: converged = . false . !! Convergence flag logical :: input_is_fixed_point = . false . !! Flag indicating lucky convergence (Newton is not run and no solution is computed) integer :: info = 0 !! Copy of the information flag for completeness contains procedure , pass ( self ), public :: print => print_newton_sp procedure , pass ( self ), public :: reset => reset_newton_sp procedure , pass ( self ), public :: record => record_data_sp end type newton_sp_metadata type , extends ( abstract_metadata ), public :: newton_dp_metadata !! Metadata for Newton-Krylov fixed-point iteration. integer :: n_iter = 0 !! Iteration counter integer :: eval_counter_record = 0 !! System response evaluation counter: !! N.B.: For each of these evals the current residual and tolerance are recorded. real ( dp ), dimension (:), allocatable :: res !! Residual history real ( dp ), dimension (:), allocatable :: tol !! Tolerance history logical :: converged = . false . !! Convergence flag logical :: input_is_fixed_point = . false . !! Flag indicating lucky convergence (Newton is not run and no solution is computed) integer :: info = 0 !! Copy of the information flag for completeness contains procedure , pass ( self ), public :: print => print_newton_dp procedure , pass ( self ), public :: reset => reset_newton_dp procedure , pass ( self ), public :: record => record_data_dp end type newton_dp_metadata interface newton !! Implements the simple Newton-Krylov method for finding roots (fixed points) of a !! nonlinear vector-valued function  F(\\mathbf{X}) , i.e. solutions  \\mathbf{X}&#94;*  !! such that  F(\\mathbf{X}&#94;*) - \\mathbf{X}&#94;* = \\mathbf{0}  starting from an !! initial guess via successive solution increments based on local linearization !!  \\mathbf{J}_\\mathbf{X}  (the Jacobian) of the nonlinear function in the !! vicinity of the current solution. !! !! **Algorthmic Features** !! !! - At iteration k, the standard Newton step  \\mathbf{\\delta x}_k is !!   computed as the solution of the linear system !! !!  \\mathbf{J}_\\mathbf{X_k} \\mathbf{\\delta x}_k = \\mathbf{r}_k  !! !!   where  \\mathbf{r}_k = -F(\\mathbf{X}_k)  is the residual of the nonlinear !!   function. The new guess for the fixed point is then given by: !! !!  \\mathbf{X}_{k+1} = \\mathbf{X}_k + \\alpha \\mathbf{\\delta x}_k !! !!   where  \\alpha \\in \\left( 0, 1 \\right]  parametrizes the step length. The !!   standard Newton algorithm sets  \\alpha = 1 . !! !! - The Jacobian is never assembled and the linear system is solved using one of !!   the available iterative solvers. !! - When the residual norm does not decrease during iteration indicating that the !!   linearization is not a very accurate model of the function's behaviour, which !!   often happens during the initial iterations, a 1D step bisection method based !!   on the golden ratio is implemented to dampen the step and improve convergence !!   of the method. !! - The implementation allows for dynamic tolerances (also known as inexact Newton), !!   where the approximation for the residual and the linear system can be solved !!   with relaxed tolerances to reduce overall time to solution. !! - The method is suitable to both fixed points and periodic orbits via the choice !!   of residual and corresponding Jacobian matrix. In the case of unforced periodic !!   orbits, the period is itself an unknown that must be included in the iteration. !! !! **Advantages** !! !! - The iterative solution of the linear systems has a comparatively low storage !!   footprint. !! - If the Newton iteration converges, the convergence is formally asymptotically !!   of second order. Using dynamic tolerances and line searches slightly reduce !!   this convergence rate in exchange for a larger convergence region. !! !! **Limitations** !! !! - The method is not guaranteed to converge if the initial guess is too far from !!   the fixed point. If the Newton iteration diverges even with step bisection, !!   the best suggestion is to find a better initial guess. If this is not feasible, !!   some alternatives to improve the convergence of the Newton iteration are possible !!   (but not implemented to date), including various line search algorithms and trust !!   region methods (doglog, double dogleg, hookstep, ...). !! !! **References** !! !! - Sánchez, J., Net, M., Garcıa-Archilla, B., & Simó, C. (2004). \"Newton–Krylov !!   continuation of periodic orbits for Navier–Stokes flows\". Journal of Computational !!   Physics, 201(1), 13-33. !! - Viswanath, D. (2007). \"Recurrent motions within plane Couette turbulence\". !!   Journal of Fluid Mechanics, 580, 339-358. !! - Duguet, Y., Pringle, C. C. T., Kerswell, R. R. (2008). \"Relative periodic orbits !!   in transitional pipe flow\". Physics  of Fluids, 20(11), 114102. !! - Frantz, R. A., Loiseau, J. C., & Robinet, J. C. (2023). \"Krylov methods for !!   large-scale dynamical systems: Application in fluid dynamics\". Applied Mechanics !!   Reviews, 75(3), 030802. module procedure newton_rsp module procedure newton_rdp module procedure newton_csp module procedure newton_cdp end interface abstract interface subroutine abstract_scheduler_sp ( tol , target_tol , rnorm , iter , info ) !! Abstract interface to define a tolerance scheduler for the Newton iteration import sp implicit none ( type , external ) real ( sp ), intent ( out ) :: tol !! Tolerance to be used real ( sp ), intent ( in ) :: target_tol !! Target tolerance real ( sp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag end subroutine abstract_scheduler_sp subroutine abstract_scheduler_dp ( tol , target_tol , rnorm , iter , info ) !! Abstract interface to define a tolerance scheduler for the Newton iteration import dp implicit none ( type , external ) real ( dp ), intent ( out ) :: tol !! Tolerance to be used real ( dp ), intent ( in ) :: target_tol !! Target tolerance real ( dp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag end subroutine abstract_scheduler_dp end interface contains !------------------------------------------------------ !-----     TYPE BOUND PROCEDURES FOR METADATA     ----- !------------------------------------------------------ subroutine print_newton_sp ( self , reset_counters , verbose ) implicit none ( type , external ) character ( len =* ), parameter :: this_procedure = 'print_newton_sp' class ( newton_sp_metadata ), intent ( inout ) :: self logical , optional , intent ( in ) :: reset_counters !! Reset all counters to zero after printing? logical , optional , intent ( in ) :: verbose !! Print the residual full residual history? ! internals integer :: i logical :: ifreset , ifverbose character ( len = 128 ) :: msg ifreset = optval ( reset_counters , . false .) ifverbose = optval ( verbose , . false .) write ( msg , '(A30,I20)' ) padr ( 'Iterations: ' , 30 ), self % n_iter call log_message ( msg , this_module , this_procedure ) if ( ifverbose ) then write ( msg , '(14X,A15,2X,A15)' ) 'Residual' , 'Tolerance' call log_message ( msg , this_module , this_procedure ) write ( msg , '(A14,E15.8,2X,E15.8)' ) '   INIT:' , self % res ( 1 ), self % tol ( 1 ) call log_message ( msg , this_module , this_procedure ) do i = 2 , size ( self % res ) - 1 write ( msg , '(A,I4,A,E15.8,2X,E15.8)' ) '   Step ' , i - 1 , ': ' , self % res ( i ), self % tol ( i ) call log_message ( msg , this_module , this_procedure ) end do i = size ( self % res ) write ( msg , '(A14,E15.8,2X,E15.8)' ) '   FINAL:' , self % res ( i ), self % tol ( i ) call log_message ( msg , this_module , this_procedure ) else write ( msg , '(A30,E20.8)' ) padr ( 'Residual: ' , 30 ), self % res ( size ( self % res )) call log_message ( msg , this_module , this_procedure ) end if if ( self % converged ) then call log_message ( 'Status: CONVERGED' , this_module , this_procedure ) else call log_message ( 'Status: NOT CONVERGED' , this_module , this_procedure ) end if if ( ifreset ) call self % reset () end subroutine print_newton_sp subroutine reset_newton_sp ( self ) class ( newton_sp_metadata ), intent ( inout ) :: self self % n_iter = 0 self % eval_counter_record = 0 self % converged = . false . self % info = 0 if ( allocated ( self % res )) deallocate ( self % res ) if ( allocated ( self % tol )) deallocate ( self % tol ) end subroutine reset_newton_sp subroutine record_data_sp ( self , res , tol ) class ( newton_sp_metadata ), intent ( inout ) :: self real ( sp ), intent ( in ) :: res !! Residual of the current evaluation real ( sp ), intent ( in ) :: tol !! Tolerance of the current evaluation integer :: iostat character ( len = 100 ) :: msg if (. not . allocated ( self % res )) then allocate ( self % res ( 1 ), source = res , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , \"record_data_sp\" ) else self % res = [ self % res , res ] end if if (. not . allocated ( self % tol )) then allocate ( self % tol ( 1 ), source = tol , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , \"record_data_sp\" ) else self % tol = [ self % tol , tol ] end if self % eval_counter_record = self % eval_counter_record + 1 end subroutine record_data_sp subroutine print_newton_dp ( self , reset_counters , verbose ) implicit none ( type , external ) character ( len =* ), parameter :: this_procedure = 'print_newton_dp' class ( newton_dp_metadata ), intent ( inout ) :: self logical , optional , intent ( in ) :: reset_counters !! Reset all counters to zero after printing? logical , optional , intent ( in ) :: verbose !! Print the residual full residual history? ! internals integer :: i logical :: ifreset , ifverbose character ( len = 128 ) :: msg ifreset = optval ( reset_counters , . false .) ifverbose = optval ( verbose , . false .) write ( msg , '(A30,I20)' ) padr ( 'Iterations: ' , 30 ), self % n_iter call log_message ( msg , this_module , this_procedure ) if ( ifverbose ) then write ( msg , '(14X,A15,2X,A15)' ) 'Residual' , 'Tolerance' call log_message ( msg , this_module , this_procedure ) write ( msg , '(A14,E15.8,2X,E15.8)' ) '   INIT:' , self % res ( 1 ), self % tol ( 1 ) call log_message ( msg , this_module , this_procedure ) do i = 2 , size ( self % res ) - 1 write ( msg , '(A,I4,A,E15.8,2X,E15.8)' ) '   Step ' , i - 1 , ': ' , self % res ( i ), self % tol ( i ) call log_message ( msg , this_module , this_procedure ) end do i = size ( self % res ) write ( msg , '(A14,E15.8,2X,E15.8)' ) '   FINAL:' , self % res ( i ), self % tol ( i ) call log_message ( msg , this_module , this_procedure ) else write ( msg , '(A30,E20.8)' ) padr ( 'Residual: ' , 30 ), self % res ( size ( self % res )) call log_message ( msg , this_module , this_procedure ) end if if ( self % converged ) then call log_message ( 'Status: CONVERGED' , this_module , this_procedure ) else call log_message ( 'Status: NOT CONVERGED' , this_module , this_procedure ) end if if ( ifreset ) call self % reset () end subroutine print_newton_dp subroutine reset_newton_dp ( self ) class ( newton_dp_metadata ), intent ( inout ) :: self self % n_iter = 0 self % eval_counter_record = 0 self % converged = . false . self % info = 0 if ( allocated ( self % res )) deallocate ( self % res ) if ( allocated ( self % tol )) deallocate ( self % tol ) end subroutine reset_newton_dp subroutine record_data_dp ( self , res , tol ) class ( newton_dp_metadata ), intent ( inout ) :: self real ( dp ), intent ( in ) :: res !! Residual of the current evaluation real ( dp ), intent ( in ) :: tol !! Tolerance of the current evaluation integer :: iostat character ( len = 100 ) :: msg if (. not . allocated ( self % res )) then allocate ( self % res ( 1 ), source = res , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , \"record_data_dp\" ) else self % res = [ self % res , res ] end if if (. not . allocated ( self % tol )) then allocate ( self % tol ( 1 ), source = tol , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , \"record_data_dp\" ) else self % tol = [ self % tol , tol ] end if self % eval_counter_record = self % eval_counter_record + 1 end subroutine record_data_dp subroutine newton_rsp ( sys , X , solver , info , rtol , atol , options , linear_solver_options , preconditioner , scheduler , meta ) class ( abstract_system_rsp ), intent ( inout ) :: sys !! Dynamical system for which we wish to compute a fixed point class ( abstract_vector_rsp ), intent ( inout ) :: X !! Initial guess for the fixed point, will be overwritten with solution procedure ( abstract_linear_solver_rsp ) :: solver !! Linear solver to be used to find Newton step integer , intent ( out ) :: info !! Information flag real ( sp ), optional , intent ( in ) :: rtol real ( sp ) :: target_rtol real ( sp ), optional , intent ( in ) :: atol real ( sp ) :: target_atol !! Target absolute solver tolerance type ( newton_sp_opts ), optional , intent ( in ) :: options type ( newton_sp_opts ) :: opts !! Options for the Newton-Krylov iteration class ( abstract_opts ), optional , intent ( in ) :: linear_solver_options !! Options for the linear solver class ( abstract_precond_rsp ), optional , intent ( inout ) :: preconditioner !! Preconditioner for the linear solver procedure ( abstract_scheduler_sp ), optional :: scheduler class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- character ( len =* ), parameter :: this_procedure = 'newton_rsp' procedure ( abstract_scheduler_sp ), pointer :: tolerance_scheduler => null () class ( abstract_vector_rsp ), allocatable :: residual , increment real ( sp ) :: rnorm , tol , target_tol integer :: i , maxiter , maxstep_bisection , iostat type ( newton_sp_metadata ) :: newton_meta character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Newton-solver tolerance target_rtol = optval ( rtol , rtol_sp ) target_atol = optval ( atol , atol_sp ) ! Newton-Krylov options if ( present ( options )) then opts = options else opts = newton_sp_opts () end if ! Scheduler if ( present ( scheduler )) then tolerance_scheduler => scheduler else tolerance_scheduler => constant_tol_sp endif ! Initialisation info = 0 maxiter = opts % maxiter maxstep_bisection = opts % maxstep_bisection allocate ( residual , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call residual % zero () allocate ( increment , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call increment % zero () ! Initialize metadata & reset eval counter newton_meta = newton_sp_metadata () call sys % reset_eval_counter ( 'newton%init' ) ! Get initial residual. call sys % eval ( X , residual , target_atol ) rnorm = residual % norm () target_tol = target_rtol * rnorm + target_atol ! Save metadata. call newton_meta % record ( rnorm , target_tol ) ! Check for lucky convergence. if ( rnorm < target_tol ) then write ( msg , '(2(A,E11.4))' ) 'rnorm= ' , rnorm , ', target= ' , target_tol call log_warning ( msg , this_module , this_procedure ) write ( msg , '(A)' ) 'Initial guess is a fixed point to tolerance!' call log_warning ( msg , this_module , this_procedure ) newton_meta % converged = . true . newton_meta % input_is_fixed_point = . true . else call log_information ( 'Starting Newton iteration ...' , this_module , this_procedure ) ! Newton iteration newton : do i = 1 , maxiter ! Set dynamic tolerances for Newton iteration and linear solves. call tolerance_scheduler ( tol , target_tol , rnorm , i , info ) write ( msg , \"(A,I0,3(A,E11.4))\" ) 'Start step ' , i , ': rnorm= ' , rnorm , ', tol= ' , tol , ', target= ' , target_tol call log_message ( msg , this_module , this_procedure ) ! Define the Jacobian sys % jacobian % X = X ! Solve the linear system using GMRES. call residual % chsgn (); call increment % zero () call solver ( sys % jacobian , residual , increment , info , atol = tol , & & preconditioner = preconditioner , options = linear_solver_options , transpose = . false .) call check_info ( info , 'linear_solver' , this_module , this_procedure ) ! Update the solution and overwrite X0 if ( opts % ifbisect ) then call increment_bisection_rsp ( X , sys , increment , rnorm , tol , maxstep_bisection ) else call X % add ( increment ) endif ! Evaluate new residual call sys % eval ( X , residual , tol ) rnorm = residual % norm () ! Save metadata. newton_meta % n_iter = newton_meta % n_iter + 1 call newton_meta % record ( rnorm , tol ) ! Check for convergence. if ( rnorm < tol ) then if ( tol >= target_tol . and . tol < 10 0.0_sp * target_tol ) then ! the tolerances are not at the target, check the accurate residual call sys % eval ( X , residual , target_tol ) rnorm = residual % norm () if ( rnorm < target_tol ) then write ( msg , '(A,I0,A)' ) 'Newton iteration converged after ' , i , ' iterations.' call log_message ( msg , this_module , this_procedure ) ! Save metadata call newton_meta % record ( rnorm , target_tol ) newton_meta % converged = . true . exit newton else write ( msg , '(A)' ) 'Dynamic tolerance but not target tolerance reached. Continue.' call log_warning ( msg , this_module , this_procedure ) end if end if end if enddo newton end if ! lucky convergence if (. not . newton_meta % converged ) then write ( msg , '(A,I0,A)' ) 'Newton iteration did not converge within' , maxiter , 'steps.' call log_warning ( msg , this_module , this_procedure ) info = - 1 endif ! Finalize metadata newton_meta % info = info if ( opts % if_print_metadata ) call newton_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( newton_sp_metadata ) meta = newton_meta class default call type_error ( 'meta' , 'newton_sp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call sys % reset_eval_counter ( 'newton%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end subroutine newton_rsp subroutine newton_rdp ( sys , X , solver , info , rtol , atol , options , linear_solver_options , preconditioner , scheduler , meta ) class ( abstract_system_rdp ), intent ( inout ) :: sys !! Dynamical system for which we wish to compute a fixed point class ( abstract_vector_rdp ), intent ( inout ) :: X !! Initial guess for the fixed point, will be overwritten with solution procedure ( abstract_linear_solver_rdp ) :: solver !! Linear solver to be used to find Newton step integer , intent ( out ) :: info !! Information flag real ( dp ), optional , intent ( in ) :: rtol real ( dp ) :: target_rtol real ( dp ), optional , intent ( in ) :: atol real ( dp ) :: target_atol !! Target absolute solver tolerance type ( newton_dp_opts ), optional , intent ( in ) :: options type ( newton_dp_opts ) :: opts !! Options for the Newton-Krylov iteration class ( abstract_opts ), optional , intent ( in ) :: linear_solver_options !! Options for the linear solver class ( abstract_precond_rdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner for the linear solver procedure ( abstract_scheduler_dp ), optional :: scheduler class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- character ( len =* ), parameter :: this_procedure = 'newton_rdp' procedure ( abstract_scheduler_dp ), pointer :: tolerance_scheduler => null () class ( abstract_vector_rdp ), allocatable :: residual , increment real ( dp ) :: rnorm , tol , target_tol integer :: i , maxiter , maxstep_bisection , iostat type ( newton_dp_metadata ) :: newton_meta character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Newton-solver tolerance target_rtol = optval ( rtol , rtol_dp ) target_atol = optval ( atol , atol_dp ) ! Newton-Krylov options if ( present ( options )) then opts = options else opts = newton_dp_opts () end if ! Scheduler if ( present ( scheduler )) then tolerance_scheduler => scheduler else tolerance_scheduler => constant_tol_dp endif ! Initialisation info = 0 maxiter = opts % maxiter maxstep_bisection = opts % maxstep_bisection allocate ( residual , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call residual % zero () allocate ( increment , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call increment % zero () ! Initialize metadata & reset eval counter newton_meta = newton_dp_metadata () call sys % reset_eval_counter ( 'newton%init' ) ! Get initial residual. call sys % eval ( X , residual , target_atol ) rnorm = residual % norm () target_tol = target_rtol * rnorm + target_atol ! Save metadata. call newton_meta % record ( rnorm , target_tol ) ! Check for lucky convergence. if ( rnorm < target_tol ) then write ( msg , '(2(A,E11.4))' ) 'rnorm= ' , rnorm , ', target= ' , target_tol call log_warning ( msg , this_module , this_procedure ) write ( msg , '(A)' ) 'Initial guess is a fixed point to tolerance!' call log_warning ( msg , this_module , this_procedure ) newton_meta % converged = . true . newton_meta % input_is_fixed_point = . true . else call log_information ( 'Starting Newton iteration ...' , this_module , this_procedure ) ! Newton iteration newton : do i = 1 , maxiter ! Set dynamic tolerances for Newton iteration and linear solves. call tolerance_scheduler ( tol , target_tol , rnorm , i , info ) write ( msg , \"(A,I0,3(A,E11.4))\" ) 'Start step ' , i , ': rnorm= ' , rnorm , ', tol= ' , tol , ', target= ' , target_tol call log_message ( msg , this_module , this_procedure ) ! Define the Jacobian sys % jacobian % X = X ! Solve the linear system using GMRES. call residual % chsgn (); call increment % zero () call solver ( sys % jacobian , residual , increment , info , atol = tol , & & preconditioner = preconditioner , options = linear_solver_options , transpose = . false .) call check_info ( info , 'linear_solver' , this_module , this_procedure ) ! Update the solution and overwrite X0 if ( opts % ifbisect ) then call increment_bisection_rdp ( X , sys , increment , rnorm , tol , maxstep_bisection ) else call X % add ( increment ) endif ! Evaluate new residual call sys % eval ( X , residual , tol ) rnorm = residual % norm () ! Save metadata. newton_meta % n_iter = newton_meta % n_iter + 1 call newton_meta % record ( rnorm , tol ) ! Check for convergence. if ( rnorm < tol ) then if ( tol >= target_tol . and . tol < 10 0.0_dp * target_tol ) then ! the tolerances are not at the target, check the accurate residual call sys % eval ( X , residual , target_tol ) rnorm = residual % norm () if ( rnorm < target_tol ) then write ( msg , '(A,I0,A)' ) 'Newton iteration converged after ' , i , ' iterations.' call log_message ( msg , this_module , this_procedure ) ! Save metadata call newton_meta % record ( rnorm , target_tol ) newton_meta % converged = . true . exit newton else write ( msg , '(A)' ) 'Dynamic tolerance but not target tolerance reached. Continue.' call log_warning ( msg , this_module , this_procedure ) end if end if end if enddo newton end if ! lucky convergence if (. not . newton_meta % converged ) then write ( msg , '(A,I0,A)' ) 'Newton iteration did not converge within' , maxiter , 'steps.' call log_warning ( msg , this_module , this_procedure ) info = - 1 endif ! Finalize metadata newton_meta % info = info if ( opts % if_print_metadata ) call newton_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( newton_dp_metadata ) meta = newton_meta class default call type_error ( 'meta' , 'newton_dp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call sys % reset_eval_counter ( 'newton%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end subroutine newton_rdp subroutine newton_csp ( sys , X , solver , info , rtol , atol , options , linear_solver_options , preconditioner , scheduler , meta ) class ( abstract_system_csp ), intent ( inout ) :: sys !! Dynamical system for which we wish to compute a fixed point class ( abstract_vector_csp ), intent ( inout ) :: X !! Initial guess for the fixed point, will be overwritten with solution procedure ( abstract_linear_solver_csp ) :: solver !! Linear solver to be used to find Newton step integer , intent ( out ) :: info !! Information flag real ( sp ), optional , intent ( in ) :: rtol real ( sp ) :: target_rtol real ( sp ), optional , intent ( in ) :: atol real ( sp ) :: target_atol !! Target absolute solver tolerance type ( newton_sp_opts ), optional , intent ( in ) :: options type ( newton_sp_opts ) :: opts !! Options for the Newton-Krylov iteration class ( abstract_opts ), optional , intent ( in ) :: linear_solver_options !! Options for the linear solver class ( abstract_precond_csp ), optional , intent ( inout ) :: preconditioner !! Preconditioner for the linear solver procedure ( abstract_scheduler_sp ), optional :: scheduler class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- character ( len =* ), parameter :: this_procedure = 'newton_csp' procedure ( abstract_scheduler_sp ), pointer :: tolerance_scheduler => null () class ( abstract_vector_csp ), allocatable :: residual , increment real ( sp ) :: rnorm , tol , target_tol integer :: i , maxiter , maxstep_bisection , iostat type ( newton_sp_metadata ) :: newton_meta character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Newton-solver tolerance target_rtol = optval ( rtol , rtol_sp ) target_atol = optval ( atol , atol_sp ) ! Newton-Krylov options if ( present ( options )) then opts = options else opts = newton_sp_opts () end if ! Scheduler if ( present ( scheduler )) then tolerance_scheduler => scheduler else tolerance_scheduler => constant_tol_sp endif ! Initialisation info = 0 maxiter = opts % maxiter maxstep_bisection = opts % maxstep_bisection allocate ( residual , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call residual % zero () allocate ( increment , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call increment % zero () ! Initialize metadata & reset eval counter newton_meta = newton_sp_metadata () call sys % reset_eval_counter ( 'newton%init' ) ! Get initial residual. call sys % eval ( X , residual , target_atol ) rnorm = residual % norm () target_tol = target_rtol * rnorm + target_atol ! Save metadata. call newton_meta % record ( rnorm , target_tol ) ! Check for lucky convergence. if ( rnorm < target_tol ) then write ( msg , '(2(A,E11.4))' ) 'rnorm= ' , rnorm , ', target= ' , target_tol call log_warning ( msg , this_module , this_procedure ) write ( msg , '(A)' ) 'Initial guess is a fixed point to tolerance!' call log_warning ( msg , this_module , this_procedure ) newton_meta % converged = . true . newton_meta % input_is_fixed_point = . true . else call log_information ( 'Starting Newton iteration ...' , this_module , this_procedure ) ! Newton iteration newton : do i = 1 , maxiter ! Set dynamic tolerances for Newton iteration and linear solves. call tolerance_scheduler ( tol , target_tol , rnorm , i , info ) write ( msg , \"(A,I0,3(A,E11.4))\" ) 'Start step ' , i , ': rnorm= ' , rnorm , ', tol= ' , tol , ', target= ' , target_tol call log_message ( msg , this_module , this_procedure ) ! Define the Jacobian sys % jacobian % X = X ! Solve the linear system using GMRES. call residual % chsgn (); call increment % zero () call solver ( sys % jacobian , residual , increment , info , atol = tol , & & preconditioner = preconditioner , options = linear_solver_options , transpose = . false .) call check_info ( info , 'linear_solver' , this_module , this_procedure ) ! Update the solution and overwrite X0 if ( opts % ifbisect ) then call increment_bisection_csp ( X , sys , increment , rnorm , tol , maxstep_bisection ) else call X % add ( increment ) endif ! Evaluate new residual call sys % eval ( X , residual , tol ) rnorm = residual % norm () ! Save metadata. newton_meta % n_iter = newton_meta % n_iter + 1 call newton_meta % record ( rnorm , tol ) ! Check for convergence. if ( rnorm < tol ) then if ( tol >= target_tol . and . tol < 10 0.0_sp * target_tol ) then ! the tolerances are not at the target, check the accurate residual call sys % eval ( X , residual , target_tol ) rnorm = residual % norm () if ( rnorm < target_tol ) then write ( msg , '(A,I0,A)' ) 'Newton iteration converged after ' , i , ' iterations.' call log_message ( msg , this_module , this_procedure ) ! Save metadata call newton_meta % record ( rnorm , target_tol ) newton_meta % converged = . true . exit newton else write ( msg , '(A)' ) 'Dynamic tolerance but not target tolerance reached. Continue.' call log_warning ( msg , this_module , this_procedure ) end if end if end if enddo newton end if ! lucky convergence if (. not . newton_meta % converged ) then write ( msg , '(A,I0,A)' ) 'Newton iteration did not converge within' , maxiter , 'steps.' call log_warning ( msg , this_module , this_procedure ) info = - 1 endif ! Finalize metadata newton_meta % info = info if ( opts % if_print_metadata ) call newton_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( newton_sp_metadata ) meta = newton_meta class default call type_error ( 'meta' , 'newton_sp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call sys % reset_eval_counter ( 'newton%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end subroutine newton_csp subroutine newton_cdp ( sys , X , solver , info , rtol , atol , options , linear_solver_options , preconditioner , scheduler , meta ) class ( abstract_system_cdp ), intent ( inout ) :: sys !! Dynamical system for which we wish to compute a fixed point class ( abstract_vector_cdp ), intent ( inout ) :: X !! Initial guess for the fixed point, will be overwritten with solution procedure ( abstract_linear_solver_cdp ) :: solver !! Linear solver to be used to find Newton step integer , intent ( out ) :: info !! Information flag real ( dp ), optional , intent ( in ) :: rtol real ( dp ) :: target_rtol real ( dp ), optional , intent ( in ) :: atol real ( dp ) :: target_atol !! Target absolute solver tolerance type ( newton_dp_opts ), optional , intent ( in ) :: options type ( newton_dp_opts ) :: opts !! Options for the Newton-Krylov iteration class ( abstract_opts ), optional , intent ( in ) :: linear_solver_options !! Options for the linear solver class ( abstract_precond_cdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner for the linear solver procedure ( abstract_scheduler_dp ), optional :: scheduler class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- character ( len =* ), parameter :: this_procedure = 'newton_cdp' procedure ( abstract_scheduler_dp ), pointer :: tolerance_scheduler => null () class ( abstract_vector_cdp ), allocatable :: residual , increment real ( dp ) :: rnorm , tol , target_tol integer :: i , maxiter , maxstep_bisection , iostat type ( newton_dp_metadata ) :: newton_meta character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Newton-solver tolerance target_rtol = optval ( rtol , rtol_dp ) target_atol = optval ( atol , atol_dp ) ! Newton-Krylov options if ( present ( options )) then opts = options else opts = newton_dp_opts () end if ! Scheduler if ( present ( scheduler )) then tolerance_scheduler => scheduler else tolerance_scheduler => constant_tol_dp endif ! Initialisation info = 0 maxiter = opts % maxiter maxstep_bisection = opts % maxstep_bisection allocate ( residual , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call residual % zero () allocate ( increment , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call increment % zero () ! Initialize metadata & reset eval counter newton_meta = newton_dp_metadata () call sys % reset_eval_counter ( 'newton%init' ) ! Get initial residual. call sys % eval ( X , residual , target_atol ) rnorm = residual % norm () target_tol = target_rtol * rnorm + target_atol ! Save metadata. call newton_meta % record ( rnorm , target_tol ) ! Check for lucky convergence. if ( rnorm < target_tol ) then write ( msg , '(2(A,E11.4))' ) 'rnorm= ' , rnorm , ', target= ' , target_tol call log_warning ( msg , this_module , this_procedure ) write ( msg , '(A)' ) 'Initial guess is a fixed point to tolerance!' call log_warning ( msg , this_module , this_procedure ) newton_meta % converged = . true . newton_meta % input_is_fixed_point = . true . else call log_information ( 'Starting Newton iteration ...' , this_module , this_procedure ) ! Newton iteration newton : do i = 1 , maxiter ! Set dynamic tolerances for Newton iteration and linear solves. call tolerance_scheduler ( tol , target_tol , rnorm , i , info ) write ( msg , \"(A,I0,3(A,E11.4))\" ) 'Start step ' , i , ': rnorm= ' , rnorm , ', tol= ' , tol , ', target= ' , target_tol call log_message ( msg , this_module , this_procedure ) ! Define the Jacobian sys % jacobian % X = X ! Solve the linear system using GMRES. call residual % chsgn (); call increment % zero () call solver ( sys % jacobian , residual , increment , info , atol = tol , & & preconditioner = preconditioner , options = linear_solver_options , transpose = . false .) call check_info ( info , 'linear_solver' , this_module , this_procedure ) ! Update the solution and overwrite X0 if ( opts % ifbisect ) then call increment_bisection_cdp ( X , sys , increment , rnorm , tol , maxstep_bisection ) else call X % add ( increment ) endif ! Evaluate new residual call sys % eval ( X , residual , tol ) rnorm = residual % norm () ! Save metadata. newton_meta % n_iter = newton_meta % n_iter + 1 call newton_meta % record ( rnorm , tol ) ! Check for convergence. if ( rnorm < tol ) then if ( tol >= target_tol . and . tol < 10 0.0_dp * target_tol ) then ! the tolerances are not at the target, check the accurate residual call sys % eval ( X , residual , target_tol ) rnorm = residual % norm () if ( rnorm < target_tol ) then write ( msg , '(A,I0,A)' ) 'Newton iteration converged after ' , i , ' iterations.' call log_message ( msg , this_module , this_procedure ) ! Save metadata call newton_meta % record ( rnorm , target_tol ) newton_meta % converged = . true . exit newton else write ( msg , '(A)' ) 'Dynamic tolerance but not target tolerance reached. Continue.' call log_warning ( msg , this_module , this_procedure ) end if end if end if enddo newton end if ! lucky convergence if (. not . newton_meta % converged ) then write ( msg , '(A,I0,A)' ) 'Newton iteration did not converge within' , maxiter , 'steps.' call log_warning ( msg , this_module , this_procedure ) info = - 1 endif ! Finalize metadata newton_meta % info = info if ( opts % if_print_metadata ) call newton_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( newton_dp_metadata ) meta = newton_meta class default call type_error ( 'meta' , 'newton_dp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call sys % reset_eval_counter ( 'newton%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end subroutine newton_cdp subroutine increment_bisection_rsp ( X , sys , increment , rold , tol , maxstep ) !! Classic 1D bisection method based on the golden ratio to damped the Newton step in !! order to maximally reduce the residual at each iteration. class ( abstract_vector_rsp ), intent ( inout ) :: X !! Current system state to be updated class ( abstract_system_rsp ), intent ( inout ) :: sys !! Dynamical system for which the residual is minimized class ( abstract_vector_rsp ), intent ( in ) :: increment !! Newton step computed from the standard method real ( sp ), intent ( in ) :: rold !! Residual of the current system state to determine improvement real ( sp ), intent ( in ) :: tol integer , intent ( in ) :: maxstep !! Maximum number of bisection steps. Each additional bisection step requires an evaluation of the nonlinear function ! internals character ( len =* ), parameter :: this_procedure = 'increment_bisection_rsp' integer :: i , j , idx ( 1 ), iostat real ( sp ) :: invphi , invphi2 real ( sp ) :: alpha ( 4 ), step real ( sp ) :: res ( 4 ) class ( abstract_vector_rsp ), allocatable :: Xin , residual character ( len = 256 ) :: msg allocate ( Xin , residual , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call residual % zero () step = one_rsp invphi = ( sqrt ( 5.0_sp ) - 1.0_sp ) / 2.0_sp ! 1 / phi invphi2 = ( 3.0_sp - sqrt ( 5.0_sp )) / 2.0_sp ! 1 / phi**2 alpha = [ zero_rsp , invphi2 * one_rsp , invphi * one_rsp , one_rsp ] res = [ rold , zero_rsp , zero_rsp , zero_rsp ] call X % add ( increment ) ! evaluate residual norm call sys % eval ( X , residual , tol ) res ( 4 ) = residual % norm () write ( msg , '(*(A,E11.4),A)' ) 'res_old= ' , res ( 1 ), ', res_new= ' , res ( 4 ), ' (full step)' call log_information ( msg , this_module , this_procedure ) if ( res ( 4 ) > rold ) then write ( msg , '(A)' ) 'Start Newton step bisection ... ' call log_information ( msg , this_module , this_procedure ) ! compute new trial solutions do j = 2 , 3 call copy ( X , Xin ) call X % axpby ( one_rsp , increment , alpha ( j )) call sys % eval ( X , residual , tol ) res ( j ) = residual % norm () end do do i = 1 , maxstep step = step * invphi write ( msg , '(4X,I0,A,4(1X,F6.4),A,4(1X,E11.4))' ) i , ': alpha=' , alpha , ': res=' , res call log_information ( msg , this_module , this_procedure ) if ( res ( 2 ) < res ( 3 )) then ! alphas ! a1 is kept alpha ( 3 : 4 ) = alpha ( 2 : 3 ) ! residuals ! r1 is kept res ( 3 : 4 ) = res ( 2 : 3 ) ! new point --> a2, r2 alpha ( 2 ) = alpha ( 1 ) + step * invphi2 call copy ( X , Xin ) call X % axpby ( one_rsp , increment , alpha ( 2 )) call sys % eval ( X , residual , tol ) res ( 2 ) = residual % norm () else ! alphas alpha ( 1 : 2 ) = alpha ( 2 : 3 ) ! a4 is kept ! residuals res ( 1 : 2 ) = res ( 2 : 3 ) ! r4 is kept ! new point --> a3, r3 alpha ( 3 ) = alpha ( 1 ) + step * invphi call copy ( X , Xin ) call X % axpby ( one_rsp , increment , alpha ( 3 )) call sys % eval ( X , residual , tol ) res ( 3 ) = residual % norm () end if write ( msg , '(4X,I0,2(A,F6.4))' ) i , ': New interval: ' , alpha ( 1 ), ' <= alpha <= ' , alpha ( 4 ) call log_information ( msg , this_module , this_procedure ) end do ! set new vector to optimal step idx = minloc ( res ) if ( abs ( alpha ( idx ( 1 ))) < rtol_dp ) then call stop_error ( 'Residual does not decrease!' , this_module , this_procedure ) end if write ( msg , '(A,F6.4)' ) 'Optimal damping: alpha= ' , alpha ( idx ( 1 )) call log_information ( msg , this_module , this_procedure ) call copy ( X , Xin ) call X % axpby ( one_rsp , increment , alpha ( idx ( 1 ))) else write ( msg , '(A)' ) 'Full Newton step reduces the residual. Skip bisection.' call log_information ( msg , this_module , this_procedure ) end if end subroutine increment_bisection_rsp subroutine increment_bisection_rdp ( X , sys , increment , rold , tol , maxstep ) !! Classic 1D bisection method based on the golden ratio to damped the Newton step in !! order to maximally reduce the residual at each iteration. class ( abstract_vector_rdp ), intent ( inout ) :: X !! Current system state to be updated class ( abstract_system_rdp ), intent ( inout ) :: sys !! Dynamical system for which the residual is minimized class ( abstract_vector_rdp ), intent ( in ) :: increment !! Newton step computed from the standard method real ( dp ), intent ( in ) :: rold !! Residual of the current system state to determine improvement real ( dp ), intent ( in ) :: tol integer , intent ( in ) :: maxstep !! Maximum number of bisection steps. Each additional bisection step requires an evaluation of the nonlinear function ! internals character ( len =* ), parameter :: this_procedure = 'increment_bisection_rdp' integer :: i , j , idx ( 1 ), iostat real ( dp ) :: invphi , invphi2 real ( dp ) :: alpha ( 4 ), step real ( dp ) :: res ( 4 ) class ( abstract_vector_rdp ), allocatable :: Xin , residual character ( len = 256 ) :: msg allocate ( Xin , residual , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call residual % zero () step = one_rdp invphi = ( sqrt ( 5.0_dp ) - 1.0_dp ) / 2.0_dp ! 1 / phi invphi2 = ( 3.0_dp - sqrt ( 5.0_dp )) / 2.0_dp ! 1 / phi**2 alpha = [ zero_rdp , invphi2 * one_rdp , invphi * one_rdp , one_rdp ] res = [ rold , zero_rdp , zero_rdp , zero_rdp ] call X % add ( increment ) ! evaluate residual norm call sys % eval ( X , residual , tol ) res ( 4 ) = residual % norm () write ( msg , '(*(A,E11.4),A)' ) 'res_old= ' , res ( 1 ), ', res_new= ' , res ( 4 ), ' (full step)' call log_information ( msg , this_module , this_procedure ) if ( res ( 4 ) > rold ) then write ( msg , '(A)' ) 'Start Newton step bisection ... ' call log_information ( msg , this_module , this_procedure ) ! compute new trial solutions do j = 2 , 3 call copy ( X , Xin ) call X % axpby ( one_rdp , increment , alpha ( j )) call sys % eval ( X , residual , tol ) res ( j ) = residual % norm () end do do i = 1 , maxstep step = step * invphi write ( msg , '(4X,I0,A,4(1X,F6.4),A,4(1X,E11.4))' ) i , ': alpha=' , alpha , ': res=' , res call log_information ( msg , this_module , this_procedure ) if ( res ( 2 ) < res ( 3 )) then ! alphas ! a1 is kept alpha ( 3 : 4 ) = alpha ( 2 : 3 ) ! residuals ! r1 is kept res ( 3 : 4 ) = res ( 2 : 3 ) ! new point --> a2, r2 alpha ( 2 ) = alpha ( 1 ) + step * invphi2 call copy ( X , Xin ) call X % axpby ( one_rdp , increment , alpha ( 2 )) call sys % eval ( X , residual , tol ) res ( 2 ) = residual % norm () else ! alphas alpha ( 1 : 2 ) = alpha ( 2 : 3 ) ! a4 is kept ! residuals res ( 1 : 2 ) = res ( 2 : 3 ) ! r4 is kept ! new point --> a3, r3 alpha ( 3 ) = alpha ( 1 ) + step * invphi call copy ( X , Xin ) call X % axpby ( one_rdp , increment , alpha ( 3 )) call sys % eval ( X , residual , tol ) res ( 3 ) = residual % norm () end if write ( msg , '(4X,I0,2(A,F6.4))' ) i , ': New interval: ' , alpha ( 1 ), ' <= alpha <= ' , alpha ( 4 ) call log_information ( msg , this_module , this_procedure ) end do ! set new vector to optimal step idx = minloc ( res ) if ( abs ( alpha ( idx ( 1 ))) < rtol_dp ) then call stop_error ( 'Residual does not decrease!' , this_module , this_procedure ) end if write ( msg , '(A,F6.4)' ) 'Optimal damping: alpha= ' , alpha ( idx ( 1 )) call log_information ( msg , this_module , this_procedure ) call copy ( X , Xin ) call X % axpby ( one_rdp , increment , alpha ( idx ( 1 ))) else write ( msg , '(A)' ) 'Full Newton step reduces the residual. Skip bisection.' call log_information ( msg , this_module , this_procedure ) end if end subroutine increment_bisection_rdp subroutine increment_bisection_csp ( X , sys , increment , rold , tol , maxstep ) !! Classic 1D bisection method based on the golden ratio to damped the Newton step in !! order to maximally reduce the residual at each iteration. class ( abstract_vector_csp ), intent ( inout ) :: X !! Current system state to be updated class ( abstract_system_csp ), intent ( inout ) :: sys !! Dynamical system for which the residual is minimized class ( abstract_vector_csp ), intent ( in ) :: increment !! Newton step computed from the standard method real ( sp ), intent ( in ) :: rold !! Residual of the current system state to determine improvement real ( sp ), intent ( in ) :: tol integer , intent ( in ) :: maxstep !! Maximum number of bisection steps. Each additional bisection step requires an evaluation of the nonlinear function ! internals character ( len =* ), parameter :: this_procedure = 'increment_bisection_csp' integer :: i , j , idx ( 1 ), iostat real ( sp ) :: invphi , invphi2 complex ( sp ) :: alpha ( 4 ), step real ( sp ) :: res ( 4 ) class ( abstract_vector_csp ), allocatable :: Xin , residual character ( len = 256 ) :: msg allocate ( Xin , residual , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call residual % zero () step = one_csp invphi = ( sqrt ( 5.0_sp ) - 1.0_sp ) / 2.0_sp ! 1 / phi invphi2 = ( 3.0_sp - sqrt ( 5.0_sp )) / 2.0_sp ! 1 / phi**2 alpha = [ zero_csp , invphi2 * one_csp , invphi * one_csp , one_csp ] res = [ rold , zero_rsp , zero_rsp , zero_rsp ] call X % add ( increment ) ! evaluate residual norm call sys % eval ( X , residual , tol ) res ( 4 ) = residual % norm () write ( msg , '(*(A,E11.4),A)' ) 'res_old= ' , res ( 1 ), ', res_new= ' , res ( 4 ), ' (full step)' call log_information ( msg , this_module , this_procedure ) if ( res ( 4 ) > rold ) then write ( msg , '(A)' ) 'Start Newton step bisection ... ' call log_information ( msg , this_module , this_procedure ) ! compute new trial solutions do j = 2 , 3 call copy ( X , Xin ) call X % axpby ( one_csp , increment , alpha ( j )) call sys % eval ( X , residual , tol ) res ( j ) = residual % norm () end do do i = 1 , maxstep step = step * invphi write ( msg , '(4X,I0,A,4(1X,F6.4),A,4(1X,E11.4))' ) i , ': alpha=' , alpha , ': res=' , res call log_information ( msg , this_module , this_procedure ) if ( res ( 2 ) < res ( 3 )) then ! alphas ! a1 is kept alpha ( 3 : 4 ) = alpha ( 2 : 3 ) ! residuals ! r1 is kept res ( 3 : 4 ) = res ( 2 : 3 ) ! new point --> a2, r2 alpha ( 2 ) = alpha ( 1 ) + step * invphi2 call copy ( X , Xin ) call X % axpby ( one_csp , increment , alpha ( 2 )) call sys % eval ( X , residual , tol ) res ( 2 ) = residual % norm () else ! alphas alpha ( 1 : 2 ) = alpha ( 2 : 3 ) ! a4 is kept ! residuals res ( 1 : 2 ) = res ( 2 : 3 ) ! r4 is kept ! new point --> a3, r3 alpha ( 3 ) = alpha ( 1 ) + step * invphi call copy ( X , Xin ) call X % axpby ( one_csp , increment , alpha ( 3 )) call sys % eval ( X , residual , tol ) res ( 3 ) = residual % norm () end if write ( msg , '(4X,I0,2(A,F6.4))' ) i , ': New interval: ' , alpha ( 1 ), ' <= alpha <= ' , alpha ( 4 ) call log_information ( msg , this_module , this_procedure ) end do ! set new vector to optimal step idx = minloc ( res ) if ( abs ( alpha ( idx ( 1 ))) < rtol_dp ) then call stop_error ( 'Residual does not decrease!' , this_module , this_procedure ) end if write ( msg , '(A,F6.4)' ) 'Optimal damping: alpha= ' , alpha ( idx ( 1 )) call log_information ( msg , this_module , this_procedure ) call copy ( X , Xin ) call X % axpby ( one_csp , increment , alpha ( idx ( 1 ))) else write ( msg , '(A)' ) 'Full Newton step reduces the residual. Skip bisection.' call log_information ( msg , this_module , this_procedure ) end if end subroutine increment_bisection_csp subroutine increment_bisection_cdp ( X , sys , increment , rold , tol , maxstep ) !! Classic 1D bisection method based on the golden ratio to damped the Newton step in !! order to maximally reduce the residual at each iteration. class ( abstract_vector_cdp ), intent ( inout ) :: X !! Current system state to be updated class ( abstract_system_cdp ), intent ( inout ) :: sys !! Dynamical system for which the residual is minimized class ( abstract_vector_cdp ), intent ( in ) :: increment !! Newton step computed from the standard method real ( dp ), intent ( in ) :: rold !! Residual of the current system state to determine improvement real ( dp ), intent ( in ) :: tol integer , intent ( in ) :: maxstep !! Maximum number of bisection steps. Each additional bisection step requires an evaluation of the nonlinear function ! internals character ( len =* ), parameter :: this_procedure = 'increment_bisection_cdp' integer :: i , j , idx ( 1 ), iostat real ( dp ) :: invphi , invphi2 complex ( dp ) :: alpha ( 4 ), step real ( dp ) :: res ( 4 ) class ( abstract_vector_cdp ), allocatable :: Xin , residual character ( len = 256 ) :: msg allocate ( Xin , residual , source = X , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call residual % zero () step = one_cdp invphi = ( sqrt ( 5.0_dp ) - 1.0_dp ) / 2.0_dp ! 1 / phi invphi2 = ( 3.0_dp - sqrt ( 5.0_dp )) / 2.0_dp ! 1 / phi**2 alpha = [ zero_cdp , invphi2 * one_cdp , invphi * one_cdp , one_cdp ] res = [ rold , zero_rdp , zero_rdp , zero_rdp ] call X % add ( increment ) ! evaluate residual norm call sys % eval ( X , residual , tol ) res ( 4 ) = residual % norm () write ( msg , '(*(A,E11.4),A)' ) 'res_old= ' , res ( 1 ), ', res_new= ' , res ( 4 ), ' (full step)' call log_information ( msg , this_module , this_procedure ) if ( res ( 4 ) > rold ) then write ( msg , '(A)' ) 'Start Newton step bisection ... ' call log_information ( msg , this_module , this_procedure ) ! compute new trial solutions do j = 2 , 3 call copy ( X , Xin ) call X % axpby ( one_cdp , increment , alpha ( j )) call sys % eval ( X , residual , tol ) res ( j ) = residual % norm () end do do i = 1 , maxstep step = step * invphi write ( msg , '(4X,I0,A,4(1X,F6.4),A,4(1X,E11.4))' ) i , ': alpha=' , alpha , ': res=' , res call log_information ( msg , this_module , this_procedure ) if ( res ( 2 ) < res ( 3 )) then ! alphas ! a1 is kept alpha ( 3 : 4 ) = alpha ( 2 : 3 ) ! residuals ! r1 is kept res ( 3 : 4 ) = res ( 2 : 3 ) ! new point --> a2, r2 alpha ( 2 ) = alpha ( 1 ) + step * invphi2 call copy ( X , Xin ) call X % axpby ( one_cdp , increment , alpha ( 2 )) call sys % eval ( X , residual , tol ) res ( 2 ) = residual % norm () else ! alphas alpha ( 1 : 2 ) = alpha ( 2 : 3 ) ! a4 is kept ! residuals res ( 1 : 2 ) = res ( 2 : 3 ) ! r4 is kept ! new point --> a3, r3 alpha ( 3 ) = alpha ( 1 ) + step * invphi call copy ( X , Xin ) call X % axpby ( one_cdp , increment , alpha ( 3 )) call sys % eval ( X , residual , tol ) res ( 3 ) = residual % norm () end if write ( msg , '(4X,I0,2(A,F6.4))' ) i , ': New interval: ' , alpha ( 1 ), ' <= alpha <= ' , alpha ( 4 ) call log_information ( msg , this_module , this_procedure ) end do ! set new vector to optimal step idx = minloc ( res ) if ( abs ( alpha ( idx ( 1 ))) < rtol_dp ) then call stop_error ( 'Residual does not decrease!' , this_module , this_procedure ) end if write ( msg , '(A,F6.4)' ) 'Optimal damping: alpha= ' , alpha ( idx ( 1 )) call log_information ( msg , this_module , this_procedure ) call copy ( X , Xin ) call X % axpby ( one_cdp , increment , alpha ( idx ( 1 ))) else write ( msg , '(A)' ) 'Full Newton step reduces the residual. Skip bisection.' call log_information ( msg , this_module , this_procedure ) end if end subroutine increment_bisection_cdp !-------------------------------------------------------------------- !-----     Definition of two basic tolerance schedulers (sp)    ----- !-------------------------------------------------------------------- subroutine constant_tol_sp ( tol , target_tol , rnorm , iter , info ) !! Constant tolerance scheduler for the Newton iteration real ( sp ), intent ( out ) :: tol !! Tolerance to be used real ( sp ), intent ( in ) :: target_tol !! Target tolerance real ( sp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals character ( len =* ), parameter :: this_procedure = 'constant_tol_sp' character ( len = 256 ) :: msg tol = target_tol if ( target_tol < atol_sp ) then tol = atol_sp write ( msg , '(A,E9.2)' ) 'Input tolerance below atol! Resetting solver tolerance to atol= ' , tol call log_warning ( msg , this_module , this_procedure ) else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if end subroutine constant_tol_sp subroutine dynamic_tol_sp ( tol , target_tol , rnorm , iter , info ) !! Dynamic tolerance scheduler for the Newton iteration setting tol based on the current residual tol real ( sp ), intent ( out ) :: tol !! Tolerance to be used real ( sp ), intent ( in ) :: target_tol !! Target tolerance real ( sp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals character ( len =* ), parameter :: this_procedure = 'dynamic_tol_sp' real ( sp ) :: tol_old , target_tol_ character ( len = 256 ) :: msg target_tol_ = max ( target_tol , atol_sp ) if ( target_tol < atol_sp ) then write ( msg , '(A,E9.2)' ) 'Input target tolerance below atol! Resetting target to atol= ' , target_tol_ call log_warning ( msg , this_module , this_procedure ) end if tol_old = tol tol = max ( 0.1 * rnorm , target_tol_ ) if ( tol /= tol_old ) then if ( tol == target_tol_ ) then write ( msg , '(A,E9.2)' ) 'Solver tolerance set to input target. tol= ' , tol else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol end if call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,E9.2)' ) 'solver tolerances unchanged at tol= ' , tol_old call log_information ( msg , this_module , this_procedure ) end if end subroutine dynamic_tol_sp !-------------------------------------------------------------------- !-----     Definition of two basic tolerance schedulers (dp)    ----- !-------------------------------------------------------------------- subroutine constant_tol_dp ( tol , target_tol , rnorm , iter , info ) !! Constant tolerance scheduler for the Newton iteration real ( dp ), intent ( out ) :: tol !! Tolerance to be used real ( dp ), intent ( in ) :: target_tol !! Target tolerance real ( dp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals character ( len =* ), parameter :: this_procedure = 'constant_tol_dp' character ( len = 256 ) :: msg tol = target_tol if ( target_tol < atol_dp ) then tol = atol_dp write ( msg , '(A,E9.2)' ) 'Input tolerance below atol! Resetting solver tolerance to atol= ' , tol call log_warning ( msg , this_module , this_procedure ) else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if end subroutine constant_tol_dp subroutine dynamic_tol_dp ( tol , target_tol , rnorm , iter , info ) !! Dynamic tolerance scheduler for the Newton iteration setting tol based on the current residual tol real ( dp ), intent ( out ) :: tol !! Tolerance to be used real ( dp ), intent ( in ) :: target_tol !! Target tolerance real ( dp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals character ( len =* ), parameter :: this_procedure = 'dynamic_tol_dp' real ( dp ) :: tol_old , target_tol_ character ( len = 256 ) :: msg target_tol_ = max ( target_tol , atol_dp ) if ( target_tol < atol_dp ) then write ( msg , '(A,E9.2)' ) 'Input target tolerance below atol! Resetting target to atol= ' , target_tol_ call log_warning ( msg , this_module , this_procedure ) end if tol_old = tol tol = max ( 0.1 * rnorm , target_tol_ ) if ( tol /= tol_old ) then if ( tol == target_tol_ ) then write ( msg , '(A,E9.2)' ) 'Solver tolerance set to input target. tol= ' , tol else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol end if call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,E9.2)' ) 'solver tolerances unchanged at tol= ' , tol_old call log_information ( msg , this_module , this_procedure ) end if end subroutine dynamic_tol_dp end module LightKrylov_NewtonKrylov","tags":"","url":"sourcefile/newtonkrylov.f90.html"},{"title":"svd_solvers.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_iterativesolvers ) svds_solver use stdlib_linalg , only : hermitian , svd implicit none ( type , external ) character ( len =* ), parameter :: svds_output = 'svds_output.txt' contains !----- Utility functions ----- elemental pure function svd_residual_rsp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. real ( sp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. real ( sp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( sp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function svd_residual_rsp elemental pure function svd_residual_rdp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. real ( dp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. real ( dp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( dp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function svd_residual_rdp elemental pure function svd_residual_csp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. complex ( sp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. complex ( sp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( sp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function svd_residual_csp elemental pure function svd_residual_cdp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. complex ( dp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. complex ( dp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( dp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function svd_residual_cdp !---------------------------------------- !-----     ITERATIVE SVD SOLVER     ----- !---------------------------------------- module procedure svds_rsp ! Left and right Krylov subspaces. integer :: kdim_ class ( abstract_vector_rsp ), allocatable :: Uwrk (:), Vwrk (:) ! Bidiagonal matrix. real ( sp ), allocatable :: B (:, :) ! Working arrays for the singular vectors and singular values. real ( sp ), allocatable :: svdvals_wrk (:) real ( sp ), allocatable :: umat (:, :), vmat (:, :) real ( sp ), allocatable :: residuals_wrk (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'svds_rsp' integer :: nsv , conv integer :: i , j , k , iostat real ( sp ) :: tol , u0_norm logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional arguments. nsv = size ( U ) kdim_ = optval ( kdim , 4 * nsv ) tol = optval ( tolerance , rtol_sp ) outpost = optval ( write_intermediate , . false .) ! Allocate working variables. allocate ( Uwrk ( kdim_ + 1 ), mold = U ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Uwrk ) if ( present ( u0 )) then call copy ( Uwrk ( 1 ), u0 ) u0_norm = u0 % norm (); call Uwrk ( 1 )% scal ( one_rsp / u0_norm ) else call Uwrk ( 1 )% rand (. true .) endif allocate ( Vwrk ( kdim_ + 1 ), mold = V ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Vwrk ) allocate ( svdvals_wrk ( kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( umat ( kdim_ , kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( vmat ( kdim_ , kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( B ( kdim_ + 1 , kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) info = 0 ! Ritz singular triplets computation. lanczos_iter : do k = 1 , kdim_ ! Lanczos bidiag. step. call bidiagonalization ( A , Uwrk , Vwrk , B , info , kstart = k , kend = k , tol = tol ) call check_info ( info , 'bidiagonalization' , this_module , this_procedure ) ! SVD of the k x k bidiagonal matrix and residual computation. svdvals_wrk = 0.0_sp ; umat = 0.0_sp ; vmat = 0.0_sp if ( time_lightkrylov ()) call timer % start ( 'svd' ) call svd ( B (: k , : k ), svdvals_wrk (: k ), umat (: k , : k ), vmat (: k , : k )) if ( time_lightkrylov ()) call timer % stop ( 'svd' ) vmat (: k , : k ) = hermitian ( vmat (: k , : k )) residuals_wrk (: k ) = svd_residual_rsp ( B ( k + 1 , k ), vmat ( k , : k )) ! Check for convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nsv , ' singular values converged after ' , k , & & ' iterations of the Lanczos process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_rsp ( svds_output , svdvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nsv ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- ! Singular values. S = svdvals_wrk (: nsv ) ; residuals = residuals_wrk (: nsv ) ! Singular vectors. k = min ( k , kdim_ ) ; info = k call zero_basis ( U ) ; call zero_basis ( V ) do i = 1 , nsv do j = 1 , k call U ( i )% axpby ( umat ( j , i ), Uwrk ( j ), one_rsp ) call V ( i )% axpby ( vmat ( j , i ), Vwrk ( j ), one_rsp ) enddo enddo if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure svds_rdp ! Left and right Krylov subspaces. integer :: kdim_ class ( abstract_vector_rdp ), allocatable :: Uwrk (:), Vwrk (:) ! Bidiagonal matrix. real ( dp ), allocatable :: B (:, :) ! Working arrays for the singular vectors and singular values. real ( dp ), allocatable :: svdvals_wrk (:) real ( dp ), allocatable :: umat (:, :), vmat (:, :) real ( dp ), allocatable :: residuals_wrk (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'svds_rdp' integer :: nsv , conv integer :: i , j , k , iostat real ( dp ) :: tol , u0_norm logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional arguments. nsv = size ( U ) kdim_ = optval ( kdim , 4 * nsv ) tol = optval ( tolerance , rtol_dp ) outpost = optval ( write_intermediate , . false .) ! Allocate working variables. allocate ( Uwrk ( kdim_ + 1 ), mold = U ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Uwrk ) if ( present ( u0 )) then call copy ( Uwrk ( 1 ), u0 ) u0_norm = u0 % norm (); call Uwrk ( 1 )% scal ( one_rdp / u0_norm ) else call Uwrk ( 1 )% rand (. true .) endif allocate ( Vwrk ( kdim_ + 1 ), mold = V ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Vwrk ) allocate ( svdvals_wrk ( kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( umat ( kdim_ , kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( vmat ( kdim_ , kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( B ( kdim_ + 1 , kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) info = 0 ! Ritz singular triplets computation. lanczos_iter : do k = 1 , kdim_ ! Lanczos bidiag. step. call bidiagonalization ( A , Uwrk , Vwrk , B , info , kstart = k , kend = k , tol = tol ) call check_info ( info , 'bidiagonalization' , this_module , this_procedure ) ! SVD of the k x k bidiagonal matrix and residual computation. svdvals_wrk = 0.0_dp ; umat = 0.0_dp ; vmat = 0.0_dp if ( time_lightkrylov ()) call timer % start ( 'svd' ) call svd ( B (: k , : k ), svdvals_wrk (: k ), umat (: k , : k ), vmat (: k , : k )) if ( time_lightkrylov ()) call timer % stop ( 'svd' ) vmat (: k , : k ) = hermitian ( vmat (: k , : k )) residuals_wrk (: k ) = svd_residual_rdp ( B ( k + 1 , k ), vmat ( k , : k )) ! Check for convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nsv , ' singular values converged after ' , k , & & ' iterations of the Lanczos process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_rdp ( svds_output , svdvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nsv ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- ! Singular values. S = svdvals_wrk (: nsv ) ; residuals = residuals_wrk (: nsv ) ! Singular vectors. k = min ( k , kdim_ ) ; info = k call zero_basis ( U ) ; call zero_basis ( V ) do i = 1 , nsv do j = 1 , k call U ( i )% axpby ( umat ( j , i ), Uwrk ( j ), one_rdp ) call V ( i )% axpby ( vmat ( j , i ), Vwrk ( j ), one_rdp ) enddo enddo if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure svds_csp ! Left and right Krylov subspaces. integer :: kdim_ class ( abstract_vector_csp ), allocatable :: Uwrk (:), Vwrk (:) ! Bidiagonal matrix. complex ( sp ), allocatable :: B (:, :) ! Working arrays for the singular vectors and singular values. real ( sp ), allocatable :: svdvals_wrk (:) complex ( sp ), allocatable :: umat (:, :), vmat (:, :) real ( sp ), allocatable :: residuals_wrk (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'svds_csp' integer :: nsv , conv integer :: i , j , k , iostat real ( sp ) :: tol , u0_norm logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional arguments. nsv = size ( U ) kdim_ = optval ( kdim , 4 * nsv ) tol = optval ( tolerance , rtol_sp ) outpost = optval ( write_intermediate , . false .) ! Allocate working variables. allocate ( Uwrk ( kdim_ + 1 ), mold = U ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Uwrk ) if ( present ( u0 )) then call copy ( Uwrk ( 1 ), u0 ) u0_norm = u0 % norm (); call Uwrk ( 1 )% scal ( one_csp / u0_norm ) else call Uwrk ( 1 )% rand (. true .) endif allocate ( Vwrk ( kdim_ + 1 ), mold = V ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Vwrk ) allocate ( svdvals_wrk ( kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( umat ( kdim_ , kdim_ ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( vmat ( kdim_ , kdim_ ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( B ( kdim_ + 1 , kdim_ ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) info = 0 ! Ritz singular triplets computation. lanczos_iter : do k = 1 , kdim_ ! Lanczos bidiag. step. call bidiagonalization ( A , Uwrk , Vwrk , B , info , kstart = k , kend = k , tol = tol ) call check_info ( info , 'bidiagonalization' , this_module , this_procedure ) ! SVD of the k x k bidiagonal matrix and residual computation. svdvals_wrk = 0.0_sp ; umat = 0.0_sp ; vmat = 0.0_sp if ( time_lightkrylov ()) call timer % start ( 'svd' ) call svd ( B (: k , : k ), svdvals_wrk (: k ), umat (: k , : k ), vmat (: k , : k )) if ( time_lightkrylov ()) call timer % stop ( 'svd' ) vmat (: k , : k ) = hermitian ( vmat (: k , : k )) residuals_wrk (: k ) = svd_residual_csp ( B ( k + 1 , k ), vmat ( k , : k )) ! Check for convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nsv , ' singular values converged after ' , k , & & ' iterations of the Lanczos process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_rsp ( svds_output , svdvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nsv ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- ! Singular values. S = svdvals_wrk (: nsv ) ; residuals = residuals_wrk (: nsv ) ! Singular vectors. k = min ( k , kdim_ ) ; info = k call zero_basis ( U ) ; call zero_basis ( V ) do i = 1 , nsv do j = 1 , k call U ( i )% axpby ( umat ( j , i ), Uwrk ( j ), one_csp ) call V ( i )% axpby ( vmat ( j , i ), Vwrk ( j ), one_csp ) enddo enddo if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure svds_cdp ! Left and right Krylov subspaces. integer :: kdim_ class ( abstract_vector_cdp ), allocatable :: Uwrk (:), Vwrk (:) ! Bidiagonal matrix. complex ( dp ), allocatable :: B (:, :) ! Working arrays for the singular vectors and singular values. real ( dp ), allocatable :: svdvals_wrk (:) complex ( dp ), allocatable :: umat (:, :), vmat (:, :) real ( dp ), allocatable :: residuals_wrk (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'svds_cdp' integer :: nsv , conv integer :: i , j , k , iostat real ( dp ) :: tol , u0_norm logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional arguments. nsv = size ( U ) kdim_ = optval ( kdim , 4 * nsv ) tol = optval ( tolerance , rtol_dp ) outpost = optval ( write_intermediate , . false .) ! Allocate working variables. allocate ( Uwrk ( kdim_ + 1 ), mold = U ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Uwrk ) if ( present ( u0 )) then call copy ( Uwrk ( 1 ), u0 ) u0_norm = u0 % norm (); call Uwrk ( 1 )% scal ( one_cdp / u0_norm ) else call Uwrk ( 1 )% rand (. true .) endif allocate ( Vwrk ( kdim_ + 1 ), mold = V ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Vwrk ) allocate ( svdvals_wrk ( kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( umat ( kdim_ , kdim_ ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( vmat ( kdim_ , kdim_ ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( B ( kdim_ + 1 , kdim_ ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) info = 0 ! Ritz singular triplets computation. lanczos_iter : do k = 1 , kdim_ ! Lanczos bidiag. step. call bidiagonalization ( A , Uwrk , Vwrk , B , info , kstart = k , kend = k , tol = tol ) call check_info ( info , 'bidiagonalization' , this_module , this_procedure ) ! SVD of the k x k bidiagonal matrix and residual computation. svdvals_wrk = 0.0_dp ; umat = 0.0_dp ; vmat = 0.0_dp if ( time_lightkrylov ()) call timer % start ( 'svd' ) call svd ( B (: k , : k ), svdvals_wrk (: k ), umat (: k , : k ), vmat (: k , : k )) if ( time_lightkrylov ()) call timer % stop ( 'svd' ) vmat (: k , : k ) = hermitian ( vmat (: k , : k )) residuals_wrk (: k ) = svd_residual_cdp ( B ( k + 1 , k ), vmat ( k , : k )) ! Check for convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nsv , ' singular values converged after ' , k , & & ' iterations of the Lanczos process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_rdp ( svds_output , svdvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nsv ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- ! Singular values. S = svdvals_wrk (: nsv ) ; residuals = residuals_wrk (: nsv ) ! Singular vectors. k = min ( k , kdim_ ) ; info = k call zero_basis ( U ) ; call zero_basis ( V ) do i = 1 , nsv do j = 1 , k call U ( i )% axpby ( umat ( j , i ), Uwrk ( j ), one_cdp ) call V ( i )% axpby ( vmat ( j , i ), Vwrk ( j ), one_cdp ) enddo enddo if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure end submodule","tags":"","url":"sourcefile/svd_solvers.f90.html"},{"title":"arnoldi.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_basekrylov ) arnoldi_method implicit none ( type , external ) contains module procedure arnoldi_rsp character ( len =* ), parameter :: this_procedure = 'arnoldi_rsp' integer :: k_start , k_end , p logical :: trans real ( sp ) :: tolerance real ( sp ) :: beta real ( sp ), allocatable :: res (:) integer :: k , i , kdim , kpm , kp , kpp , iostat character ( len = 100 ) :: errmsg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with optional non-unity blksize and allocations. p = optval ( blksize , 1 ) ; info = 0 allocate ( res ( p ), source = zero_rsp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"arnoldi_rsp\" ) ! Check dimensions. kdim = ( size ( X ) - p ) / p ! Deal with the other optional args. k_start = optval ( kstart , 1 ) ; k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) trans = optval ( transpose , . false .) ! Arnoldi factorization. blk_arnoldi : do k = k_start , k_end ! Counters kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Matrix-vector product. if ( trans ) then do i = 1 , p call A % apply_rmatvec ( X ( kpm + i ), X ( kp + i )) enddo else do i = 1 , p call A % apply_matvec ( X ( kpm + i ), X ( kp + i )) enddo endif ! Update Hessenberg matrix via batch double Gram-Schmidt step. call double_gram_schmidt_step ( X ( kp + 1 : kpp ), X (: kp ), info , if_chk_orthonormal = . false ., beta = H (: kp , kpm + 1 : kp )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) ! Orthogonalize current blk vectors. call qr ( X ( kp + 1 : kpp ), H ( kp + 1 : kpp , kpm + 1 : kp ), info ) call check_info ( info , 'qr' , this_module , this_procedure ) ! Extract residual norm (smallest diagonal element of H matrix). res = zero_rsp do i = 1 , p res ( i ) = H ( kp + i , kpm + i ) enddo beta = minval ( abs ( res )) ! Exit Arnoldi loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = kp ! Exit the Arnoldi iteration. exit blk_arnoldi endif enddo blk_arnoldi if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure arnoldi_rsp module procedure arnoldi_rdp character ( len =* ), parameter :: this_procedure = 'arnoldi_rdp' integer :: k_start , k_end , p logical :: trans real ( dp ) :: tolerance real ( dp ) :: beta real ( dp ), allocatable :: res (:) integer :: k , i , kdim , kpm , kp , kpp , iostat character ( len = 100 ) :: errmsg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with optional non-unity blksize and allocations. p = optval ( blksize , 1 ) ; info = 0 allocate ( res ( p ), source = zero_rdp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"arnoldi_rdp\" ) ! Check dimensions. kdim = ( size ( X ) - p ) / p ! Deal with the other optional args. k_start = optval ( kstart , 1 ) ; k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) trans = optval ( transpose , . false .) ! Arnoldi factorization. blk_arnoldi : do k = k_start , k_end ! Counters kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Matrix-vector product. if ( trans ) then do i = 1 , p call A % apply_rmatvec ( X ( kpm + i ), X ( kp + i )) enddo else do i = 1 , p call A % apply_matvec ( X ( kpm + i ), X ( kp + i )) enddo endif ! Update Hessenberg matrix via batch double Gram-Schmidt step. call double_gram_schmidt_step ( X ( kp + 1 : kpp ), X (: kp ), info , if_chk_orthonormal = . false ., beta = H (: kp , kpm + 1 : kp )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) ! Orthogonalize current blk vectors. call qr ( X ( kp + 1 : kpp ), H ( kp + 1 : kpp , kpm + 1 : kp ), info ) call check_info ( info , 'qr' , this_module , this_procedure ) ! Extract residual norm (smallest diagonal element of H matrix). res = zero_rdp do i = 1 , p res ( i ) = H ( kp + i , kpm + i ) enddo beta = minval ( abs ( res )) ! Exit Arnoldi loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = kp ! Exit the Arnoldi iteration. exit blk_arnoldi endif enddo blk_arnoldi if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure arnoldi_rdp module procedure arnoldi_csp character ( len =* ), parameter :: this_procedure = 'arnoldi_csp' integer :: k_start , k_end , p logical :: trans real ( sp ) :: tolerance real ( sp ) :: beta real ( sp ), allocatable :: res (:) integer :: k , i , kdim , kpm , kp , kpp , iostat character ( len = 100 ) :: errmsg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with optional non-unity blksize and allocations. p = optval ( blksize , 1 ) ; info = 0 allocate ( res ( p ), source = zero_rsp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"arnoldi_csp\" ) ! Check dimensions. kdim = ( size ( X ) - p ) / p ! Deal with the other optional args. k_start = optval ( kstart , 1 ) ; k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) trans = optval ( transpose , . false .) ! Arnoldi factorization. blk_arnoldi : do k = k_start , k_end ! Counters kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Matrix-vector product. if ( trans ) then do i = 1 , p call A % apply_rmatvec ( X ( kpm + i ), X ( kp + i )) enddo else do i = 1 , p call A % apply_matvec ( X ( kpm + i ), X ( kp + i )) enddo endif ! Update Hessenberg matrix via batch double Gram-Schmidt step. call double_gram_schmidt_step ( X ( kp + 1 : kpp ), X (: kp ), info , if_chk_orthonormal = . false ., beta = H (: kp , kpm + 1 : kp )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) ! Orthogonalize current blk vectors. call qr ( X ( kp + 1 : kpp ), H ( kp + 1 : kpp , kpm + 1 : kp ), info ) call check_info ( info , 'qr' , this_module , this_procedure ) ! Extract residual norm (smallest diagonal element of H matrix). res = zero_rsp do i = 1 , p res ( i ) = H ( kp + i , kpm + i ) enddo beta = minval ( abs ( res )) ! Exit Arnoldi loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = kp ! Exit the Arnoldi iteration. exit blk_arnoldi endif enddo blk_arnoldi if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure arnoldi_csp module procedure arnoldi_cdp character ( len =* ), parameter :: this_procedure = 'arnoldi_cdp' integer :: k_start , k_end , p logical :: trans real ( dp ) :: tolerance real ( dp ) :: beta real ( dp ), allocatable :: res (:) integer :: k , i , kdim , kpm , kp , kpp , iostat character ( len = 100 ) :: errmsg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with optional non-unity blksize and allocations. p = optval ( blksize , 1 ) ; info = 0 allocate ( res ( p ), source = zero_rdp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"arnoldi_cdp\" ) ! Check dimensions. kdim = ( size ( X ) - p ) / p ! Deal with the other optional args. k_start = optval ( kstart , 1 ) ; k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) trans = optval ( transpose , . false .) ! Arnoldi factorization. blk_arnoldi : do k = k_start , k_end ! Counters kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Matrix-vector product. if ( trans ) then do i = 1 , p call A % apply_rmatvec ( X ( kpm + i ), X ( kp + i )) enddo else do i = 1 , p call A % apply_matvec ( X ( kpm + i ), X ( kp + i )) enddo endif ! Update Hessenberg matrix via batch double Gram-Schmidt step. call double_gram_schmidt_step ( X ( kp + 1 : kpp ), X (: kp ), info , if_chk_orthonormal = . false ., beta = H (: kp , kpm + 1 : kp )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) ! Orthogonalize current blk vectors. call qr ( X ( kp + 1 : kpp ), H ( kp + 1 : kpp , kpm + 1 : kp ), info ) call check_info ( info , 'qr' , this_module , this_procedure ) ! Extract residual norm (smallest diagonal element of H matrix). res = zero_rdp do i = 1 , p res ( i ) = H ( kp + i , kpm + i ) enddo beta = minval ( abs ( res )) ! Exit Arnoldi loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = kp ! Exit the Arnoldi iteration. exit blk_arnoldi endif enddo blk_arnoldi if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure arnoldi_cdp end submodule arnoldi_method","tags":"","url":"sourcefile/arnoldi.f90.html"},{"title":"gram_schmidt.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_basekrylov ) gram_schmidt_process implicit none ( type , external ) contains !-------------------------------------------- !-----     DOUBLE GRAM-SCHMIDT STEP     ----- !-------------------------------------------- module procedure DGS_vector_against_basis_rsp character ( len =* ), parameter :: this_procedure = 'DGS_vector_against_basis_rsp' real ( sp ), dimension ( size ( X )) :: proj_coefficients , wrk ! internal logical :: chk_X_orthonormality logical :: is_ortho ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_rsp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if proj_coefficients = zero_rsp ; wrk = zero_rsp ! Orthogonalize vector y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , this_procedure // ', pass 1' ) ! second pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , this_module , this_procedure // ', pass 2' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure DGS_vector_against_basis_rsp module procedure DGS_basis_against_basis_rsp character ( len =* ), parameter :: this_procedure = 'DGS_basis_against_basis_rsp' real ( sp ), dimension ( size ( X ), size ( Y )) :: proj_coefficients , wrk ! internal logical :: chk_X_orthonormality logical :: is_ortho ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_rsp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if proj_coefficients = zero_rsp ; wrk = zero_rsp ! Orthogonalize Krylov basis Y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , this_procedure // ', first pass' ) ! second pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , this_module , this_procedure // ', second pass' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure DGS_basis_against_basis_rsp module procedure DGS_vector_against_basis_rdp character ( len =* ), parameter :: this_procedure = 'DGS_vector_against_basis_rdp' real ( dp ), dimension ( size ( X )) :: proj_coefficients , wrk ! internal logical :: chk_X_orthonormality logical :: is_ortho ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_rdp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if proj_coefficients = zero_rdp ; wrk = zero_rdp ! Orthogonalize vector y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , this_procedure // ', pass 1' ) ! second pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , this_module , this_procedure // ', pass 2' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure DGS_vector_against_basis_rdp module procedure DGS_basis_against_basis_rdp character ( len =* ), parameter :: this_procedure = 'DGS_basis_against_basis_rdp' real ( dp ), dimension ( size ( X ), size ( Y )) :: proj_coefficients , wrk ! internal logical :: chk_X_orthonormality logical :: is_ortho ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_rdp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if proj_coefficients = zero_rdp ; wrk = zero_rdp ! Orthogonalize Krylov basis Y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , this_procedure // ', first pass' ) ! second pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , this_module , this_procedure // ', second pass' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure DGS_basis_against_basis_rdp module procedure DGS_vector_against_basis_csp character ( len =* ), parameter :: this_procedure = 'DGS_vector_against_basis_csp' complex ( sp ), dimension ( size ( X )) :: proj_coefficients , wrk ! internal logical :: chk_X_orthonormality logical :: is_ortho ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_csp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if proj_coefficients = zero_csp ; wrk = zero_csp ! Orthogonalize vector y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , this_procedure // ', pass 1' ) ! second pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , this_module , this_procedure // ', pass 2' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure DGS_vector_against_basis_csp module procedure DGS_basis_against_basis_csp character ( len =* ), parameter :: this_procedure = 'DGS_basis_against_basis_csp' complex ( sp ), dimension ( size ( X ), size ( Y )) :: proj_coefficients , wrk ! internal logical :: chk_X_orthonormality logical :: is_ortho ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_csp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if proj_coefficients = zero_csp ; wrk = zero_csp ! Orthogonalize Krylov basis Y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , this_procedure // ', first pass' ) ! second pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , this_module , this_procedure // ', second pass' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure DGS_basis_against_basis_csp module procedure DGS_vector_against_basis_cdp character ( len =* ), parameter :: this_procedure = 'DGS_vector_against_basis_cdp' complex ( dp ), dimension ( size ( X )) :: proj_coefficients , wrk ! internal logical :: chk_X_orthonormality logical :: is_ortho ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_cdp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if proj_coefficients = zero_cdp ; wrk = zero_cdp ! Orthogonalize vector y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , this_procedure // ', pass 1' ) ! second pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , this_module , this_procedure // ', pass 2' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure DGS_vector_against_basis_cdp module procedure DGS_basis_against_basis_cdp character ( len =* ), parameter :: this_procedure = 'DGS_basis_against_basis_cdp' complex ( dp ), dimension ( size ( X ), size ( Y )) :: proj_coefficients , wrk ! internal logical :: chk_X_orthonormality logical :: is_ortho ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_cdp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if proj_coefficients = zero_cdp ; wrk = zero_cdp ! Orthogonalize Krylov basis Y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , this_procedure // ', first pass' ) ! second pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , this_module , this_procedure // ', second pass' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure DGS_basis_against_basis_cdp !------------------------------------------------------------------------------- !-----     ORTHOGONALIZE VECTOR/BASIS AGAINST ALREADY ORTHOGONAL BASIS     ----- !------------------------------------------------------------------------------- module procedure orthogonalize_vector_against_basis_rsp character ( len =* ), parameter :: this_procedure = 'orthogonalize_vector_against_basis_rsp' real ( sp ) :: proj_coefficients ( size ( X )) ! internal logical :: chk_X_orthonormality logical :: is_ortho if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector if ( y % norm () < atol_sp ) info = 1 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_rsp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if ! orthogonalize proj_coefficients = innerprod ( X , y ) block class ( abstract_vector_rsp ), allocatable :: proj call linear_combination ( proj , X , proj_coefficients ) call y % sub ( proj ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthogonalize_vector_against_basis_rsp module procedure orthogonalize_basis_against_basis_rsp character ( len =* ), parameter :: this_procedure = 'orthogonalize_basis_against_basis_rsp' real ( sp ) :: proj_coefficients ( size ( X ), size ( Y )) ! internal integer :: i logical :: chk_X_orthonormality logical :: is_ortho if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector do i = 1 , size ( Y ) if ( Y ( i )% norm () < atol_sp ) info = i end do ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_rsp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if ! orthogonalize proj_coefficients = innerprod ( X , Y ) block class ( abstract_vector_rsp ), allocatable :: proj (:) call linear_combination ( proj , X , proj_coefficients ) call axpby_basis ( - one_rsp , proj , one_rsp , Y ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthogonalize_basis_against_basis_rsp module procedure orthogonalize_vector_against_basis_rdp character ( len =* ), parameter :: this_procedure = 'orthogonalize_vector_against_basis_rdp' real ( dp ) :: proj_coefficients ( size ( X )) ! internal logical :: chk_X_orthonormality logical :: is_ortho if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector if ( y % norm () < atol_dp ) info = 1 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_rdp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if ! orthogonalize proj_coefficients = innerprod ( X , y ) block class ( abstract_vector_rdp ), allocatable :: proj call linear_combination ( proj , X , proj_coefficients ) call y % sub ( proj ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthogonalize_vector_against_basis_rdp module procedure orthogonalize_basis_against_basis_rdp character ( len =* ), parameter :: this_procedure = 'orthogonalize_basis_against_basis_rdp' real ( dp ) :: proj_coefficients ( size ( X ), size ( Y )) ! internal integer :: i logical :: chk_X_orthonormality logical :: is_ortho if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector do i = 1 , size ( Y ) if ( Y ( i )% norm () < atol_dp ) info = i end do ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_rdp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if ! orthogonalize proj_coefficients = innerprod ( X , Y ) block class ( abstract_vector_rdp ), allocatable :: proj (:) call linear_combination ( proj , X , proj_coefficients ) call axpby_basis ( - one_rdp , proj , one_rdp , Y ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthogonalize_basis_against_basis_rdp module procedure orthogonalize_vector_against_basis_csp character ( len =* ), parameter :: this_procedure = 'orthogonalize_vector_against_basis_csp' complex ( sp ) :: proj_coefficients ( size ( X )) ! internal logical :: chk_X_orthonormality logical :: is_ortho if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector if ( y % norm () < atol_sp ) info = 1 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_csp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if ! orthogonalize proj_coefficients = innerprod ( X , y ) block class ( abstract_vector_csp ), allocatable :: proj call linear_combination ( proj , X , proj_coefficients ) call y % sub ( proj ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthogonalize_vector_against_basis_csp module procedure orthogonalize_basis_against_basis_csp character ( len =* ), parameter :: this_procedure = 'orthogonalize_basis_against_basis_csp' complex ( sp ) :: proj_coefficients ( size ( X ), size ( Y )) ! internal integer :: i logical :: chk_X_orthonormality logical :: is_ortho if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector do i = 1 , size ( Y ) if ( Y ( i )% norm () < atol_sp ) info = i end do ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_csp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if ! orthogonalize proj_coefficients = innerprod ( X , Y ) block class ( abstract_vector_csp ), allocatable :: proj (:) call linear_combination ( proj , X , proj_coefficients ) call axpby_basis ( - one_csp , proj , one_csp , Y ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthogonalize_basis_against_basis_csp module procedure orthogonalize_vector_against_basis_cdp character ( len =* ), parameter :: this_procedure = 'orthogonalize_vector_against_basis_cdp' complex ( dp ) :: proj_coefficients ( size ( X )) ! internal logical :: chk_X_orthonormality logical :: is_ortho if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector if ( y % norm () < atol_dp ) info = 1 ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_cdp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if ! orthogonalize proj_coefficients = innerprod ( X , y ) block class ( abstract_vector_cdp ), allocatable :: proj call linear_combination ( proj , X , proj_coefficients ) call y % sub ( proj ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthogonalize_vector_against_basis_cdp module procedure orthogonalize_basis_against_basis_cdp character ( len =* ), parameter :: this_procedure = 'orthogonalize_basis_against_basis_cdp' complex ( dp ) :: proj_coefficients ( size ( X ), size ( Y )) ! internal integer :: i logical :: chk_X_orthonormality logical :: is_ortho if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector do i = 1 , size ( Y ) if ( Y ( i )% norm () < atol_dp ) info = i end do ! optional orthonormality check if ( chk_X_orthonormality ) then is_ortho = is_orthonormal_cdp ( X ) if ( is_ortho ) then call log_information ( \"Input basis orthonormal. Remove this check unless necessary for better performance\" , & & this_module , this_procedure ) else call stop_error ( \"Input basis not orthonormal.\" , this_module , this_procedure ) end if end if ! orthogonalize proj_coefficients = innerprod ( X , Y ) block class ( abstract_vector_cdp ), allocatable :: proj (:) call linear_combination ( proj , X , proj_coefficients ) call axpby_basis ( - one_cdp , proj , one_cdp , Y ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , this_procedure ) beta = proj_coefficients end if if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure orthogonalize_basis_against_basis_cdp end submodule gram_schmidt_process","tags":"","url":"sourcefile/gram_schmidt.f90.html"},{"title":"lanczos.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_basekrylov ) lanczos_methods implicit none ( type , external ) contains module procedure lanczos_tridiagonalization_rsp character ( len =* ), parameter :: this_procedure = 'lanczos_tridiagonalization_rsp' integer :: k_start , k_end real ( sp ) :: tolerance real ( sp ) :: beta integer :: k , kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deal with optional args. kdim = size ( X ) - 1 k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) info = 0 ! Lanczos tridiagonalization. lanczos : do k = k_start , k_end ! Matrix-vector product. call A % apply_matvec ( X ( k ), X ( k + 1 )) ! Update tridiagonal matrix. call update_tridiag_matrix_rsp ( T , X , k ) beta = X ( k + 1 )% norm () ; T ( k + 1 , k ) = beta ! Exit Lanczos loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = k ! Exit the Lanczos iteration. exit lanczos else ! Normalize the new Krylov vector. call X ( k + 1 )% scal ( one_rsp / beta ) endif enddo lanczos if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure lanczos_tridiagonalization_rsp subroutine update_tridiag_matrix_rsp ( T , X , k ) integer , intent ( in ) :: k real ( sp ), intent ( inout ) :: T (:, :) class ( abstract_vector_rsp ), intent ( inout ) :: X (:) ! Internal variables. integer :: i , info info = 0 ! Orthogonalize residual w.r.t. previously computed Krylov vectors to obtain coefficients in tridiag. matrix do i = max ( 1 , k - 1 ), k T ( i , k ) = X ( i )% dot ( X ( k + 1 )) ; call X ( k + 1 )% axpby ( - T ( i , k ), X ( i ), one_rsp ) enddo ! Full re-orthogonalization against existing basis call double_gram_schmidt_step ( X ( k + 1 ), X (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , 'update_tridiag_matrix_rsp' ) end subroutine update_tridiag_matrix_rsp module procedure lanczos_tridiagonalization_rdp character ( len =* ), parameter :: this_procedure = 'lanczos_tridiagonalization_rdp' integer :: k_start , k_end real ( dp ) :: tolerance real ( dp ) :: beta integer :: k , kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deal with optional args. kdim = size ( X ) - 1 k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) info = 0 ! Lanczos tridiagonalization. lanczos : do k = k_start , k_end ! Matrix-vector product. call A % apply_matvec ( X ( k ), X ( k + 1 )) ! Update tridiagonal matrix. call update_tridiag_matrix_rdp ( T , X , k ) beta = X ( k + 1 )% norm () ; T ( k + 1 , k ) = beta ! Exit Lanczos loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = k ! Exit the Lanczos iteration. exit lanczos else ! Normalize the new Krylov vector. call X ( k + 1 )% scal ( one_rdp / beta ) endif enddo lanczos if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure lanczos_tridiagonalization_rdp subroutine update_tridiag_matrix_rdp ( T , X , k ) integer , intent ( in ) :: k real ( dp ), intent ( inout ) :: T (:, :) class ( abstract_vector_rdp ), intent ( inout ) :: X (:) ! Internal variables. integer :: i , info info = 0 ! Orthogonalize residual w.r.t. previously computed Krylov vectors to obtain coefficients in tridiag. matrix do i = max ( 1 , k - 1 ), k T ( i , k ) = X ( i )% dot ( X ( k + 1 )) ; call X ( k + 1 )% axpby ( - T ( i , k ), X ( i ), one_rdp ) enddo ! Full re-orthogonalization against existing basis call double_gram_schmidt_step ( X ( k + 1 ), X (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , 'update_tridiag_matrix_rdp' ) end subroutine update_tridiag_matrix_rdp module procedure lanczos_tridiagonalization_csp character ( len =* ), parameter :: this_procedure = 'lanczos_tridiagonalization_csp' integer :: k_start , k_end real ( sp ) :: tolerance real ( sp ) :: beta integer :: k , kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deal with optional args. kdim = size ( X ) - 1 k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) info = 0 ! Lanczos tridiagonalization. lanczos : do k = k_start , k_end ! Matrix-vector product. call A % apply_matvec ( X ( k ), X ( k + 1 )) ! Update tridiagonal matrix. call update_tridiag_matrix_csp ( T , X , k ) beta = X ( k + 1 )% norm () ; T ( k + 1 , k ) = beta ! Exit Lanczos loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = k ! Exit the Lanczos iteration. exit lanczos else ! Normalize the new Krylov vector. call X ( k + 1 )% scal ( one_csp / beta ) endif enddo lanczos if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure lanczos_tridiagonalization_csp subroutine update_tridiag_matrix_csp ( T , X , k ) integer , intent ( in ) :: k complex ( sp ), intent ( inout ) :: T (:, :) class ( abstract_vector_csp ), intent ( inout ) :: X (:) ! Internal variables. integer :: i , info info = 0 ! Orthogonalize residual w.r.t. previously computed Krylov vectors to obtain coefficients in tridiag. matrix do i = max ( 1 , k - 1 ), k T ( i , k ) = X ( i )% dot ( X ( k + 1 )) ; call X ( k + 1 )% axpby ( - T ( i , k ), X ( i ), one_csp ) enddo ! Full re-orthogonalization against existing basis call double_gram_schmidt_step ( X ( k + 1 ), X (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , 'update_tridiag_matrix_csp' ) end subroutine update_tridiag_matrix_csp module procedure lanczos_tridiagonalization_cdp character ( len =* ), parameter :: this_procedure = 'lanczos_tridiagonalization_cdp' integer :: k_start , k_end real ( dp ) :: tolerance real ( dp ) :: beta integer :: k , kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deal with optional args. kdim = size ( X ) - 1 k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) info = 0 ! Lanczos tridiagonalization. lanczos : do k = k_start , k_end ! Matrix-vector product. call A % apply_matvec ( X ( k ), X ( k + 1 )) ! Update tridiagonal matrix. call update_tridiag_matrix_cdp ( T , X , k ) beta = X ( k + 1 )% norm () ; T ( k + 1 , k ) = beta ! Exit Lanczos loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = k ! Exit the Lanczos iteration. exit lanczos else ! Normalize the new Krylov vector. call X ( k + 1 )% scal ( one_cdp / beta ) endif enddo lanczos if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure lanczos_tridiagonalization_cdp subroutine update_tridiag_matrix_cdp ( T , X , k ) integer , intent ( in ) :: k complex ( dp ), intent ( inout ) :: T (:, :) class ( abstract_vector_cdp ), intent ( inout ) :: X (:) ! Internal variables. integer :: i , info info = 0 ! Orthogonalize residual w.r.t. previously computed Krylov vectors to obtain coefficients in tridiag. matrix do i = max ( 1 , k - 1 ), k T ( i , k ) = X ( i )% dot ( X ( k + 1 )) ; call X ( k + 1 )% axpby ( - T ( i , k ), X ( i ), one_cdp ) enddo ! Full re-orthogonalization against existing basis call double_gram_schmidt_step ( X ( k + 1 ), X (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'orthogonalize_against_basis_p1' , this_module , 'update_tridiag_matrix_cdp' ) end subroutine update_tridiag_matrix_cdp end submodule lanczos_methods","tags":"","url":"sourcefile/lanczos.f90.html"},{"title":"AbstractVectors.f90 – LightKrylov","text":"Source Code module LightKrylov_AbstractVectors !! This module provides the base class `absract_vector` from which all Krylov vectors !! needs to be derived. To use `LightKrylov`, you need to extend one of the !! followings: !! !! - `abstract_vector_rsp`  :   Real-valued vector with single precision arithmetic. !! - `abstract_vector_rdp`  :   Real-valued vector with double precision arithmetic. !! - `abstract_vector_csp`  :   Complex-valued vector with single precision arithmetic. !! - `abstract_vector_cdp`  :   Complex-valued vector with double precision arithmetic. !! !! To extend either of these abstract types, you need to provide an associated implementation !! for the following type-bound procedures: !! !! - `zero(self)`                   :   A subroutine zeroing-out the vector. !! - `rand(self, ifnorm)`           :   A subroutine creating a random vector, possibily normalized to have unit-norm (`ifnorm = .true.`). !! - `scal(self, alpha)`            :   A subroutine computing *in-place* the scalar multiplication  \\mathbf{x} \\leftarrow \\alpha \\mathbf{x} . !! - `axpby(alpha, vec, beta, self) :   A subroutine computing *in-place* the product  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . !! - `dot(self, vec)`               :   A function computing the inner product  \\alpha = \\langle \\mathbf{x} \\vert \\mathbf{y} \\rangle . !! - `get_size(self)`               :   A function returning the dimension  n  of the vector  \\mathbf{x} . !! !! Once these type-bound procedures have been implemented by the user, they will automatically !! be used to define: !! !! - vector addition    :   `add(self, vec) = axpby(1, vec, 1, self)` !! - vector subtraction :   `sub(self, vec) = axpby(-1, vec, 1, self)` !! - vector norm        :   `norm(self)     = sqrt(self%dot(self))` !! !! This module also provides the following utility subroutines: !! !! - `innerprod(X, Y)`                  : Function computing the product \\mathbf{X}&#94;H \\mathbf{y}  between a Krylov basis `X` and a Krylov vector  (resp. basis) `Y`. !! - `linear_combination(Y, X, V)`      : Subroutine computing the linear combination  \\mathbf{y}_j = \\sum_{i=1}&#94;n \\mathbf{x}_i v_{ij} . !! - `axpby_basis(alpha, X, beta, Y)`   : In-place computation of  \\mathbf{Y} \\leftarrow \\alpha \\mathbf{X} + \\beta \\mathbf{Y}  where `X` and `Y` are arrays of `abstract_vector`. !! - `zero_basis(X)`                    : Zero-out a collection of `abstract_vectors`. !! - `copy_basis(out, from)`            : Copy a collection of `abstract_vectors`. !! - `rand_basis(X, ifnorm)`            : Create a collection of random `abstract_vectors`. If `ifnorm = .true.`, the vectors are normalized to have unit-norm. !! @warning !! The resulting vectors do not form an orthonormal basis. For this purpose use the utility function `initialize_random_orthonormal_basis`. !! @endwarning use stdlib_optval , only : optval use stdlib_linalg_blas , only : scal , axpy , dot , dotc use LightKrylov_Constants use LightKrylov_Utils use LightKrylov_Logger implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_Vectors' character ( len =* ), parameter :: this_module_long = 'Lightkrylov_AbstractVectors' public :: innerprod , Gram public :: linear_combination public :: axpby_basis public :: zero_basis public :: copy public :: rand_basis interface innerprod !!  Compute the inner product vector  \\mathbf{v} = \\mathbf{X}&#94;H \\mathbf{y}  or matrix !!   \\mathbf{M} = \\mathbf{X}&#94;H \\mathbf{Y} . !! !!  ### Description !! !!  This interface provides methods for computing the inner products between a basis !!  of `real` or `complex` vectors  \\mathbf{X}  and a single vector !!   \\mathbf{y}  or another basis  \\mathbf{Y} . Depending on the case, it !!  returns a one-dimensional array  \\mathbf{v}  or a two-dimensional array !!   \\mathbf{M}  with the same type as  \\mathbf{X} . !! !!  ### Example !! !!  The example below assumes that you have already extended the `abstract_vector_rdp` !!  class to define your own `my_real_vector` type. !! !!  ```fortran !!      type(my_real_vector), dimension(10) :: X !!      type(my_real_vector)                :: y !!      real(dp), dimension(:), allocatable :: v !! !!      ! ... Part of your code where you initialize everything ... !! !!      v = innerprod(X, y) !! !!      ! ... Rest of your code ... !!  ``` !! !!  Similarly, for computing the matrix of inner products between two bases !! !!  ```fortran !!      type(my_real_vector), dimension(10) :: X !!      type(my_real_vector), dimension(10) :: Y !!      real(dp), dimension(:, :), allocatable :: M !! !!      ! ... Part of your code where you initialize everything ... !! !!      M = innerprod(X, Y) !! !!      ! ... Rest of your code ... !!  ``` module procedure innerprod_vector_rsp module procedure innerprod_matrix_rsp module procedure innerprod_vector_rdp module procedure innerprod_matrix_rdp module procedure innerprod_vector_csp module procedure innerprod_matrix_csp module procedure innerprod_vector_cdp module procedure innerprod_matrix_cdp end interface interface Gram !!  Compute the Gram matrix  \\mathbf{G} = \\mathbf{X}&#94;H \\mathbf{X} . !! !!  ### Description !! !!  This interface provides methods for computing the Gram matrix associated to a basis of !!  `abstract_vector`  \\mathbf{X} . !! !!  ### Example !! !!  The example below assumes that you have already extended the `abstract_vector_rdp` !!  class to define your own `my_real_vector` type. !! !!  ```fortran !!      type(my_real_vector), dimension(10) :: X !!      real(dp), dimension(:, :), allocatable :: G !! !!      ! ... Part of your code where you initialize everything ... !! !!      G = Gram(X) !! !!      ! ... Rest of your code ... !!  ``` module procedure gram_matrix_rsp module procedure gram_matrix_rdp module procedure gram_matrix_csp module procedure gram_matrix_cdp end interface interface linear_combination !!  Given a set of extended `abstract_vectors` and coefficients, return the corresponding !!  linear combinations. !! !!  ### Description !! !!  This interface provides methods for computing linear combinations of a set of !!  `abstract_vectors`. Depending on its input, it either computes !! !!   !!      \\mathbf{y} = \\sum_{i=1}&#94;n \\alpha_i \\mathbf{x}_i, !!   !! !!  i.e. a single vector, or !! !!   !!      \\mathbf{y}_j = \\sum_{i=1}&#94;n \\alpha_{ij} \\mathbf{x}_i, !!   !! !!  i.e. a set of vectors of the same type as  \\mathbf{X} . !! !!  ### Example !! !!  ```fortran !!      type(my_real_vector), dimension(10) :: X !!      real(dp), dimension(m, n)           :: B !!      type(my_real_vector)                :: Y !! !!      ! ... Whatever your code is doing ... !! !!      call linear_combination(Y, X, B) !! !!      ! ... Rest of your code ... !!  ``` module procedure linear_combination_vector_rsp module procedure linear_combination_matrix_rsp module procedure linear_combination_vector_rdp module procedure linear_combination_matrix_rdp module procedure linear_combination_vector_csp module procedure linear_combination_matrix_csp module procedure linear_combination_vector_cdp module procedure linear_combination_matrix_cdp end interface interface axpby_basis !!  In-place addition of two arrays of extended `abstract_vector`. !! !!  ### Description !! !!  This interface provides methods to add in-place two arrays of !!  extended `abstract_vector`, i.e. !! !!   !!      \\mathbf{Y}_i \\leftarrow \\alpha \\mathbf{X}_i + \\beta \\mathbf{Y}_i. !!   !! !!  No out-of-place alternative is currently available in `LightKrylov`. !!  If you do need an out-of-place version, you can combine `axpby_basis` !!  with `copy`. !! !!  ### Example !! !!  ```fortran !!      type(my_real_vector), dimension(10) :: X !!      type(my_real_vector), dimension(10) :: Y !!      real(dp), dimension(10)             :: alpha, beta !! !!      ! ... Whatever your code is doing ... !! !!      call axpby_basis(alpha, X, beta, Y) !! !!      ! ... Rest of your code ... !!  ``` module procedure axpby_basis_rsp module procedure axpby_basis_rdp module procedure axpby_basis_csp module procedure axpby_basis_cdp end interface interface zero_basis !!  This interface provides methods to zero-out a collection of `abstract_vector` `X`. !!  It is a simple wrapper around `X(i)%zero()`. !! !!  ### Example !! !!  ```fortran !!      type(my_real_vector), dimension(10) :: X !! !!      ! ... Your code ... !! !!      call zero_basis(X) !! !!      ! ... Your code ... !!  ``` module procedure zero_basis_rsp module procedure zero_basis_rdp module procedure zero_basis_csp module procedure zero_basis_cdp end interface interface copy !!  This interface provides methods to copy an array `X` of `abstract_vector` into !!  another array `Y`. Note that `Y` needs to be pre-allocated. !! !!  ### Example !! !!  ```fortran !!      type(my_real_vector), dimension(10) :: X !!      type(my_real_vector), dimension(10) :: Y !! !!      ! ... Your code ... !! !!      call copy(Y, X) !! !!      ! ... Your code ... !!  ``` module procedure copy_vector_rsp ! module procedure copy_basis_rsp module procedure copy_vector_rdp ! module procedure copy_basis_rdp module procedure copy_vector_csp ! module procedure copy_basis_csp module procedure copy_vector_cdp ! module procedure copy_basis_cdp end interface interface rand_basis !!  This interface provides methods to create an array `X` of random `abstract_vector`. !!  It is a simple wrapper around `X(i)%rand(ifnorm)`. !! !!  ### Example !! !!  ```fortran !!      type(my_real_vector), dimension(10) :: X !!      logical                             :: ifnorm = .true. !! !!      ! ... Your code ... !! !!      call rand_basis(X, ifnorm) !! !!      ! ... Your code ... !!  ``` module procedure rand_basis_rsp module procedure rand_basis_rdp module procedure rand_basis_csp module procedure rand_basis_cdp end interface type , abstract , public :: abstract_vector !!  Base abstract type from which all other types of vectors used in `LightKrylov` !!  are being derived from. !! !!  @warning !!  Users should not extend this abstract class to define their own types. !!  @endwarning end type abstract_vector !---------------------------------------------------------------------------- !-----     Definition of an abstract real(sp) vector with kind=sp     ----- !---------------------------------------------------------------------------- type , abstract , extends ( abstract_vector ), public :: abstract_vector_rsp !!  Abstract type to define real(sp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_rsp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_rsp` to zero. procedure ( abstract_rand_rsp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_rsp`. procedure ( abstract_scal_rsp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_rsp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_rsp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_rsp`. procedure ( abstract_get_size_rsp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_rsp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_rsp !! Adds two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{x} + \\mathbf{y}. procedure , pass ( self ), public :: sub => sub_rsp !! Subtracts two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{y} - \\mathbf{x} . procedure , pass ( self ), public :: chsgn => chsgn_rsp !! Change the sign of a vector, i.e.  \\mathbf{x} \\leftarrow -\\mathbf{x} . end type abstract_vector_rsp abstract interface subroutine abstract_zero_rsp ( self ) !! Abstract interface to zero-out a vector in-place. import abstract_vector_rsp implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: self !! Vector to be zeroed-out. end subroutine abstract_zero_rsp subroutine abstract_rand_rsp ( self , ifnorm ) !! Abstract interface to generate a random (normalized) vector. import abstract_vector_rsp implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: self !! Vector to be initialized. logical , optional , intent ( in ) :: ifnorm end subroutine abstract_rand_rsp subroutine abstract_scal_rsp ( self , alpha ) !! Abstract interface to scale a vector. import abstract_vector_rsp , sp implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: self !! Vector to be scaled. real ( sp ), intent ( in ) :: alpha !! Scaling factor. end subroutine abstract_scal_rsp subroutine abstract_axpby_rsp ( alpha , vec , beta , self ) !! Abstract interface to add/scale two vectors in-place. import abstract_vector_rsp , sp implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rsp ), intent ( in ) :: vec !! Vector to be added/subtracted. real ( sp ), intent ( in ) :: alpha , beta end subroutine abstract_axpby_rsp function abstract_dot_rsp ( self , vec ) result ( alpha ) !! Abstract interface to compute the dot product. import abstract_vector_rsp , sp implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( in ) :: self , vec !! Vectors whose dot product will be computed. real ( sp ) :: alpha !! Result of the dot product. end function abstract_dot_rsp function abstract_get_size_rsp ( self ) result ( N ) !! Abstract interface to return the size of the specific abstract vector. import abstract_vector_rsp implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( in ) :: self !! Vector for which to return the size. integer :: N !! Size of the vector end function abstract_get_size_rsp end interface !---------------------------------------------------------------------------- !-----     Definition of an abstract real(dp) vector with kind=dp     ----- !---------------------------------------------------------------------------- type , abstract , extends ( abstract_vector ), public :: abstract_vector_rdp !!  Abstract type to define real(dp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_rdp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_rdp` to zero. procedure ( abstract_rand_rdp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_rdp`. procedure ( abstract_scal_rdp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_rdp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_rdp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_rdp`. procedure ( abstract_get_size_rdp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_rdp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_rdp !! Adds two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{x} + \\mathbf{y}. procedure , pass ( self ), public :: sub => sub_rdp !! Subtracts two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{y} - \\mathbf{x} . procedure , pass ( self ), public :: chsgn => chsgn_rdp !! Change the sign of a vector, i.e.  \\mathbf{x} \\leftarrow -\\mathbf{x} . end type abstract_vector_rdp abstract interface subroutine abstract_zero_rdp ( self ) !! Abstract interface to zero-out a vector in-place. import abstract_vector_rdp implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: self !! Vector to be zeroed-out. end subroutine abstract_zero_rdp subroutine abstract_rand_rdp ( self , ifnorm ) !! Abstract interface to generate a random (normalized) vector. import abstract_vector_rdp implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: self !! Vector to be initialized. logical , optional , intent ( in ) :: ifnorm end subroutine abstract_rand_rdp subroutine abstract_scal_rdp ( self , alpha ) !! Abstract interface to scale a vector. import abstract_vector_rdp , dp implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: self !! Vector to be scaled. real ( dp ), intent ( in ) :: alpha !! Scaling factor. end subroutine abstract_scal_rdp subroutine abstract_axpby_rdp ( alpha , vec , beta , self ) !! Abstract interface to add/scale two vectors in-place. import abstract_vector_rdp , dp implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rdp ), intent ( in ) :: vec !! Vector to be added/subtracted. real ( dp ), intent ( in ) :: alpha , beta end subroutine abstract_axpby_rdp function abstract_dot_rdp ( self , vec ) result ( alpha ) !! Abstract interface to compute the dot product. import abstract_vector_rdp , dp implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( in ) :: self , vec !! Vectors whose dot product will be computed. real ( dp ) :: alpha !! Result of the dot product. end function abstract_dot_rdp function abstract_get_size_rdp ( self ) result ( N ) !! Abstract interface to return the size of the specific abstract vector. import abstract_vector_rdp implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( in ) :: self !! Vector for which to return the size. integer :: N !! Size of the vector end function abstract_get_size_rdp end interface !---------------------------------------------------------------------------- !-----     Definition of an abstract complex(sp) vector with kind=sp     ----- !---------------------------------------------------------------------------- type , abstract , extends ( abstract_vector ), public :: abstract_vector_csp !!  Abstract type to define complex(sp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_csp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_csp` to zero. procedure ( abstract_rand_csp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_csp`. procedure ( abstract_scal_csp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_csp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_csp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_csp`. procedure ( abstract_get_size_csp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_csp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_csp !! Adds two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{x} + \\mathbf{y}. procedure , pass ( self ), public :: sub => sub_csp !! Subtracts two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{y} - \\mathbf{x} . procedure , pass ( self ), public :: chsgn => chsgn_csp !! Change the sign of a vector, i.e.  \\mathbf{x} \\leftarrow -\\mathbf{x} . end type abstract_vector_csp abstract interface subroutine abstract_zero_csp ( self ) !! Abstract interface to zero-out a vector in-place. import abstract_vector_csp implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: self !! Vector to be zeroed-out. end subroutine abstract_zero_csp subroutine abstract_rand_csp ( self , ifnorm ) !! Abstract interface to generate a random (normalized) vector. import abstract_vector_csp implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: self !! Vector to be initialized. logical , optional , intent ( in ) :: ifnorm end subroutine abstract_rand_csp subroutine abstract_scal_csp ( self , alpha ) !! Abstract interface to scale a vector. import abstract_vector_csp , sp implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: self !! Vector to be scaled. complex ( sp ), intent ( in ) :: alpha !! Scaling factor. end subroutine abstract_scal_csp subroutine abstract_axpby_csp ( alpha , vec , beta , self ) !! Abstract interface to add/scale two vectors in-place. import abstract_vector_csp , sp implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_csp ), intent ( in ) :: vec !! Vector to be added/subtracted. complex ( sp ), intent ( in ) :: alpha , beta end subroutine abstract_axpby_csp function abstract_dot_csp ( self , vec ) result ( alpha ) !! Abstract interface to compute the dot product. import abstract_vector_csp , sp implicit none ( type , external ) class ( abstract_vector_csp ), intent ( in ) :: self , vec !! Vectors whose dot product will be computed. complex ( sp ) :: alpha !! Result of the dot product. end function abstract_dot_csp function abstract_get_size_csp ( self ) result ( N ) !! Abstract interface to return the size of the specific abstract vector. import abstract_vector_csp implicit none ( type , external ) class ( abstract_vector_csp ), intent ( in ) :: self !! Vector for which to return the size. integer :: N !! Size of the vector end function abstract_get_size_csp end interface !---------------------------------------------------------------------------- !-----     Definition of an abstract complex(dp) vector with kind=dp     ----- !---------------------------------------------------------------------------- type , abstract , extends ( abstract_vector ), public :: abstract_vector_cdp !!  Abstract type to define complex(dp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_cdp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_cdp` to zero. procedure ( abstract_rand_cdp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_cdp`. procedure ( abstract_scal_cdp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_cdp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_cdp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_cdp`. procedure ( abstract_get_size_cdp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_cdp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_cdp !! Adds two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{x} + \\mathbf{y}. procedure , pass ( self ), public :: sub => sub_cdp !! Subtracts two `abstract_vector`, i.e.  \\mathbf{y} \\leftarrow \\mathbf{y} - \\mathbf{x} . procedure , pass ( self ), public :: chsgn => chsgn_cdp !! Change the sign of a vector, i.e.  \\mathbf{x} \\leftarrow -\\mathbf{x} . end type abstract_vector_cdp abstract interface subroutine abstract_zero_cdp ( self ) !! Abstract interface to zero-out a vector in-place. import abstract_vector_cdp implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: self !! Vector to be zeroed-out. end subroutine abstract_zero_cdp subroutine abstract_rand_cdp ( self , ifnorm ) !! Abstract interface to generate a random (normalized) vector. import abstract_vector_cdp implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: self !! Vector to be initialized. logical , optional , intent ( in ) :: ifnorm end subroutine abstract_rand_cdp subroutine abstract_scal_cdp ( self , alpha ) !! Abstract interface to scale a vector. import abstract_vector_cdp , dp implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: self !! Vector to be scaled. complex ( dp ), intent ( in ) :: alpha !! Scaling factor. end subroutine abstract_scal_cdp subroutine abstract_axpby_cdp ( alpha , vec , beta , self ) !! Abstract interface to add/scale two vectors in-place. import abstract_vector_cdp , dp implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_cdp ), intent ( in ) :: vec !! Vector to be added/subtracted. complex ( dp ), intent ( in ) :: alpha , beta end subroutine abstract_axpby_cdp function abstract_dot_cdp ( self , vec ) result ( alpha ) !! Abstract interface to compute the dot product. import abstract_vector_cdp , dp implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( in ) :: self , vec !! Vectors whose dot product will be computed. complex ( dp ) :: alpha !! Result of the dot product. end function abstract_dot_cdp function abstract_get_size_cdp ( self ) result ( N ) !! Abstract interface to return the size of the specific abstract vector. import abstract_vector_cdp implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( in ) :: self !! Vector for which to return the size. integer :: N !! Size of the vector end function abstract_get_size_cdp end interface !---------------------------------------------------------------------------------- !-----     Convenience vector type to wrap standard Fortran rank-1 arrays     ----- !---------------------------------------------------------------------------------- type , extends ( abstract_vector_rsp ), public :: dense_vector_rsp integer :: n real ( sp ), allocatable :: data (:) contains private procedure , pass ( self ), public :: zero => dense_zero_rsp !! Sets an `abstract_vector_rsp` to zero. procedure , pass ( self ), public :: rand => dense_rand_rsp !! Creates a random `abstract_vector_rsp`. procedure , pass ( self ), public :: scal => dense_scal_rsp !! Compute the scalar-vector product. procedure , pass ( self ), public :: axpby => dense_axpby_rsp !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure , pass ( self ), public :: dot => dense_dot_rsp !! Computes the dot product between two `abstract_vector_rsp`. procedure , pass ( self ), public :: get_size => dense_get_size_rsp !! Return size of specific abstract vector end type dense_vector_rsp !---------------------------------------------------------------------------------- !-----     Convenience vector type to wrap standard Fortran rank-1 arrays     ----- !---------------------------------------------------------------------------------- type , extends ( abstract_vector_rdp ), public :: dense_vector_rdp integer :: n real ( dp ), allocatable :: data (:) contains private procedure , pass ( self ), public :: zero => dense_zero_rdp !! Sets an `abstract_vector_rdp` to zero. procedure , pass ( self ), public :: rand => dense_rand_rdp !! Creates a random `abstract_vector_rdp`. procedure , pass ( self ), public :: scal => dense_scal_rdp !! Compute the scalar-vector product. procedure , pass ( self ), public :: axpby => dense_axpby_rdp !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure , pass ( self ), public :: dot => dense_dot_rdp !! Computes the dot product between two `abstract_vector_rdp`. procedure , pass ( self ), public :: get_size => dense_get_size_rdp !! Return size of specific abstract vector end type dense_vector_rdp !---------------------------------------------------------------------------------- !-----     Convenience vector type to wrap standard Fortran rank-1 arrays     ----- !---------------------------------------------------------------------------------- type , extends ( abstract_vector_csp ), public :: dense_vector_csp integer :: n complex ( sp ), allocatable :: data (:) contains private procedure , pass ( self ), public :: zero => dense_zero_csp !! Sets an `abstract_vector_csp` to zero. procedure , pass ( self ), public :: rand => dense_rand_csp !! Creates a random `abstract_vector_csp`. procedure , pass ( self ), public :: scal => dense_scal_csp !! Compute the scalar-vector product. procedure , pass ( self ), public :: axpby => dense_axpby_csp !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure , pass ( self ), public :: dot => dense_dot_csp !! Computes the dot product between two `abstract_vector_csp`. procedure , pass ( self ), public :: get_size => dense_get_size_csp !! Return size of specific abstract vector end type dense_vector_csp !---------------------------------------------------------------------------------- !-----     Convenience vector type to wrap standard Fortran rank-1 arrays     ----- !---------------------------------------------------------------------------------- type , extends ( abstract_vector_cdp ), public :: dense_vector_cdp integer :: n complex ( dp ), allocatable :: data (:) contains private procedure , pass ( self ), public :: zero => dense_zero_cdp !! Sets an `abstract_vector_cdp` to zero. procedure , pass ( self ), public :: rand => dense_rand_cdp !! Creates a random `abstract_vector_cdp`. procedure , pass ( self ), public :: scal => dense_scal_cdp !! Compute the scalar-vector product. procedure , pass ( self ), public :: axpby => dense_axpby_cdp !! In-place computation of  \\mathbf{y} \\leftarrow \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure , pass ( self ), public :: dot => dense_dot_cdp !! Computes the dot product between two `abstract_vector_cdp`. procedure , pass ( self ), public :: get_size => dense_get_size_cdp !! Return size of specific abstract vector end type dense_vector_cdp interface dense_vector module procedure initialize_dense_vector_from_array_rsp module procedure initialize_dense_vector_from_array_rdp module procedure initialize_dense_vector_from_array_csp module procedure initialize_dense_vector_from_array_cdp end interface public :: dense_vector contains !----------------------------------------------------------------------- !-----     TYPE-BOUND PROCEDURES FOR THE ABSTRACT VECTOR TYPES     ----- !----------------------------------------------------------------------- function norm_rsp ( self ) result ( alpha ) implicit none ( type , external ) !! Compute the norm of an `abstract_vector`. class ( abstract_vector_rsp ), intent ( in ) :: self !! Vector whose norm needs to be computed. real ( sp ) :: alpha !! Norm of the vector. alpha = abs ( self % dot ( self )) ; alpha = sqrt ( alpha ) end function norm_rsp subroutine sub_rsp ( self , vec ) implicit none ( type , external ) !! Subtract two `abstract_vector` in-place. class ( abstract_vector_rsp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rsp ), intent ( in ) :: vec !! Vector to be subtracted. call self % axpby ( - one_rsp , vec , one_rsp ) end subroutine sub_rsp subroutine add_rsp ( self , vec ) implicit none ( type , external ) !! Add two `abstract_vector` in-place. class ( abstract_vector_rsp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rsp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_rsp , vec , one_rsp ) end subroutine add_rsp subroutine chsgn_rsp ( self ) implicit none ( type , external ) !! Changes the sign of the `abstract_vector`. class ( abstract_vector_rsp ), intent ( inout ) :: self !! Vector whose entries need to change sign. call self % scal ( - one_rsp ) end subroutine chsgn_rsp function norm_rdp ( self ) result ( alpha ) implicit none ( type , external ) !! Compute the norm of an `abstract_vector`. class ( abstract_vector_rdp ), intent ( in ) :: self !! Vector whose norm needs to be computed. real ( dp ) :: alpha !! Norm of the vector. alpha = abs ( self % dot ( self )) ; alpha = sqrt ( alpha ) end function norm_rdp subroutine sub_rdp ( self , vec ) implicit none ( type , external ) !! Subtract two `abstract_vector` in-place. class ( abstract_vector_rdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rdp ), intent ( in ) :: vec !! Vector to be subtracted. call self % axpby ( - one_rdp , vec , one_rdp ) end subroutine sub_rdp subroutine add_rdp ( self , vec ) implicit none ( type , external ) !! Add two `abstract_vector` in-place. class ( abstract_vector_rdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rdp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_rdp , vec , one_rdp ) end subroutine add_rdp subroutine chsgn_rdp ( self ) implicit none ( type , external ) !! Changes the sign of the `abstract_vector`. class ( abstract_vector_rdp ), intent ( inout ) :: self !! Vector whose entries need to change sign. call self % scal ( - one_rdp ) end subroutine chsgn_rdp function norm_csp ( self ) result ( alpha ) implicit none ( type , external ) !! Compute the norm of an `abstract_vector`. class ( abstract_vector_csp ), intent ( in ) :: self !! Vector whose norm needs to be computed. real ( sp ) :: alpha !! Norm of the vector. alpha = abs ( self % dot ( self )) ; alpha = sqrt ( alpha ) end function norm_csp subroutine sub_csp ( self , vec ) implicit none ( type , external ) !! Subtract two `abstract_vector` in-place. class ( abstract_vector_csp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_csp ), intent ( in ) :: vec !! Vector to be subtracted. call self % axpby ( - one_csp , vec , one_csp ) end subroutine sub_csp subroutine add_csp ( self , vec ) implicit none ( type , external ) !! Add two `abstract_vector` in-place. class ( abstract_vector_csp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_csp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_csp , vec , one_csp ) end subroutine add_csp subroutine chsgn_csp ( self ) implicit none ( type , external ) !! Changes the sign of the `abstract_vector`. class ( abstract_vector_csp ), intent ( inout ) :: self !! Vector whose entries need to change sign. call self % scal ( - one_csp ) end subroutine chsgn_csp function norm_cdp ( self ) result ( alpha ) implicit none ( type , external ) !! Compute the norm of an `abstract_vector`. class ( abstract_vector_cdp ), intent ( in ) :: self !! Vector whose norm needs to be computed. real ( dp ) :: alpha !! Norm of the vector. alpha = abs ( self % dot ( self )) ; alpha = sqrt ( alpha ) end function norm_cdp subroutine sub_cdp ( self , vec ) implicit none ( type , external ) !! Subtract two `abstract_vector` in-place. class ( abstract_vector_cdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_cdp ), intent ( in ) :: vec !! Vector to be subtracted. call self % axpby ( - one_cdp , vec , one_cdp ) end subroutine sub_cdp subroutine add_cdp ( self , vec ) implicit none ( type , external ) !! Add two `abstract_vector` in-place. class ( abstract_vector_cdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_cdp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_cdp , vec , one_cdp ) end subroutine add_cdp subroutine chsgn_cdp ( self ) implicit none ( type , external ) !! Changes the sign of the `abstract_vector`. class ( abstract_vector_cdp ), intent ( inout ) :: self !! Vector whose entries need to change sign. call self % scal ( - one_cdp ) end subroutine chsgn_cdp !-------------------------------------------------------------------------------- !-----     TYPE-BOUND PROCEDURES FOR THE CONVENIENCE DENSE VECTOR TYPES     ----- !-------------------------------------------------------------------------------- function initialize_dense_vector_from_array_rsp ( x ) result ( vec ) implicit none ( type , external ) real ( sp ), intent ( in ) :: x (:) type ( dense_vector_rsp ) :: vec vec % n = size ( x ) ; vec % data = x end function initialize_dense_vector_from_array_rsp subroutine dense_zero_rsp ( self ) implicit none ( type , external ) class ( dense_vector_rsp ), intent ( inout ) :: self integer :: iostat character ( len = 100 ) :: errmsg if (. not . allocated ( self % data )) then allocate ( self % data ( self % n ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"dense_zero_rsp\" ) endif self % data = zero_rsp end subroutine dense_zero_rsp subroutine dense_rand_rsp ( self , ifnorm ) implicit none ( type , external ) class ( dense_vector_rsp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm integer :: iostat character ( len = 100 ) :: errmsg call random_number ( self % data ) end subroutine dense_rand_rsp subroutine dense_scal_rsp ( self , alpha ) implicit none ( type , external ) class ( dense_vector_rsp ), intent ( inout ) :: self real ( sp ), intent ( in ) :: alpha integer :: n n = self % get_size () call scal ( n , alpha , self % data , 1 ) end subroutine dense_scal_rsp subroutine dense_axpby_rsp ( alpha , vec , beta , self ) implicit none ( type , external ) real ( sp ), intent ( in ) :: alpha , beta class ( dense_vector_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec integer :: n , m , iostat character ( len = 100 ) :: errmsg m = vec % get_size () if (. not . allocated ( self % data )) then allocate ( self % data ( m ), source = zero_rsp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"dense_axpby_rsp\" ) endif n = self % get_size () if ( m /= n ) call stop_error ( \"Inconsistent size between the two vectors.\" ) select type ( vec ) type is ( dense_vector_rsp ) if ( beta /= zero_rsp ) call self % scal ( beta ) call axpy ( n , alpha , vec % data , 1 , self % data , 1 ) class default call type_error ( 'vec' , 'dense_vector_rsp' , 'IN' , this_module , 'dense_axpby_rsp' ) end select end subroutine dense_axpby_rsp function dense_dot_rsp ( self , vec ) result ( alpha ) implicit none ( type , external ) class ( dense_vector_rsp ), intent ( in ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec real ( sp ) :: alpha integer :: n n = self % get_size () select type ( vec ) type is ( dense_vector_rsp ) alpha = dot ( n , self % data , 1 , vec % data , 1 ) class default call type_error ( 'vec' , 'dense_vector_rsp' , 'IN' , this_module , 'dense_dot_rsp' ) end select end function dense_dot_rsp function dense_get_size_rsp ( self ) result ( n ) implicit none ( type , external ) class ( dense_vector_rsp ), intent ( in ) :: self integer :: n n = size ( self % data ) end function dense_get_size_rsp function initialize_dense_vector_from_array_rdp ( x ) result ( vec ) implicit none ( type , external ) real ( dp ), intent ( in ) :: x (:) type ( dense_vector_rdp ) :: vec vec % n = size ( x ) ; vec % data = x end function initialize_dense_vector_from_array_rdp subroutine dense_zero_rdp ( self ) implicit none ( type , external ) class ( dense_vector_rdp ), intent ( inout ) :: self integer :: iostat character ( len = 100 ) :: errmsg if (. not . allocated ( self % data )) then allocate ( self % data ( self % n ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"dense_zero_rdp\" ) endif self % data = zero_rdp end subroutine dense_zero_rdp subroutine dense_rand_rdp ( self , ifnorm ) implicit none ( type , external ) class ( dense_vector_rdp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm integer :: iostat character ( len = 100 ) :: errmsg call random_number ( self % data ) end subroutine dense_rand_rdp subroutine dense_scal_rdp ( self , alpha ) implicit none ( type , external ) class ( dense_vector_rdp ), intent ( inout ) :: self real ( dp ), intent ( in ) :: alpha integer :: n n = self % get_size () call scal ( n , alpha , self % data , 1 ) end subroutine dense_scal_rdp subroutine dense_axpby_rdp ( alpha , vec , beta , self ) implicit none ( type , external ) real ( dp ), intent ( in ) :: alpha , beta class ( dense_vector_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec integer :: n , m , iostat character ( len = 100 ) :: errmsg m = vec % get_size () if (. not . allocated ( self % data )) then allocate ( self % data ( m ), source = zero_rdp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"dense_axpby_rdp\" ) endif n = self % get_size () if ( m /= n ) call stop_error ( \"Inconsistent size between the two vectors.\" ) select type ( vec ) type is ( dense_vector_rdp ) if ( beta /= zero_rdp ) call self % scal ( beta ) call axpy ( n , alpha , vec % data , 1 , self % data , 1 ) class default call type_error ( 'vec' , 'dense_vector_rdp' , 'IN' , this_module , 'dense_axpby_rdp' ) end select end subroutine dense_axpby_rdp function dense_dot_rdp ( self , vec ) result ( alpha ) implicit none ( type , external ) class ( dense_vector_rdp ), intent ( in ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec real ( dp ) :: alpha integer :: n n = self % get_size () select type ( vec ) type is ( dense_vector_rdp ) alpha = dot ( n , self % data , 1 , vec % data , 1 ) class default call type_error ( 'vec' , 'dense_vector_rdp' , 'IN' , this_module , 'dense_dot_rdp' ) end select end function dense_dot_rdp function dense_get_size_rdp ( self ) result ( n ) implicit none ( type , external ) class ( dense_vector_rdp ), intent ( in ) :: self integer :: n n = size ( self % data ) end function dense_get_size_rdp function initialize_dense_vector_from_array_csp ( x ) result ( vec ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: x (:) type ( dense_vector_csp ) :: vec vec % n = size ( x ) ; vec % data = x end function initialize_dense_vector_from_array_csp subroutine dense_zero_csp ( self ) implicit none ( type , external ) class ( dense_vector_csp ), intent ( inout ) :: self integer :: iostat character ( len = 100 ) :: errmsg if (. not . allocated ( self % data )) then allocate ( self % data ( self % n ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"dense_zero_csp\" ) endif self % data = zero_csp end subroutine dense_zero_csp subroutine dense_rand_csp ( self , ifnorm ) implicit none ( type , external ) class ( dense_vector_csp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm integer :: iostat character ( len = 100 ) :: errmsg real ( sp ), allocatable :: y (:, :) allocate ( y ( size ( self % data ), 2 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"dense_rand_csp\" ) call random_number ( y ) self % data % re = y (:, 1 ) ; self % data % im = y (:, 2 ) end subroutine dense_rand_csp subroutine dense_scal_csp ( self , alpha ) implicit none ( type , external ) class ( dense_vector_csp ), intent ( inout ) :: self complex ( sp ), intent ( in ) :: alpha integer :: n n = self % get_size () call scal ( n , alpha , self % data , 1 ) end subroutine dense_scal_csp subroutine dense_axpby_csp ( alpha , vec , beta , self ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: alpha , beta class ( dense_vector_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec integer :: n , m , iostat character ( len = 100 ) :: errmsg m = vec % get_size () if (. not . allocated ( self % data )) then allocate ( self % data ( m ), source = zero_csp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"dense_axpby_csp\" ) endif n = self % get_size () if ( m /= n ) call stop_error ( \"Inconsistent size between the two vectors.\" ) select type ( vec ) type is ( dense_vector_csp ) if ( beta /= zero_csp ) call self % scal ( beta ) call axpy ( n , alpha , vec % data , 1 , self % data , 1 ) class default call type_error ( 'vec' , 'dense_vector_csp' , 'IN' , this_module , 'dense_axpby_csp' ) end select end subroutine dense_axpby_csp function dense_dot_csp ( self , vec ) result ( alpha ) implicit none ( type , external ) class ( dense_vector_csp ), intent ( in ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec complex ( sp ) :: alpha integer :: n n = self % get_size () select type ( vec ) type is ( dense_vector_csp ) alpha = dotc ( n , self % data , 1 , vec % data , 1 ) class default call type_error ( 'vec' , 'dense_vector_csp' , 'IN' , this_module , 'dense_dot_csp' ) end select end function dense_dot_csp function dense_get_size_csp ( self ) result ( n ) implicit none ( type , external ) class ( dense_vector_csp ), intent ( in ) :: self integer :: n n = size ( self % data ) end function dense_get_size_csp function initialize_dense_vector_from_array_cdp ( x ) result ( vec ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: x (:) type ( dense_vector_cdp ) :: vec vec % n = size ( x ) ; vec % data = x end function initialize_dense_vector_from_array_cdp subroutine dense_zero_cdp ( self ) implicit none ( type , external ) class ( dense_vector_cdp ), intent ( inout ) :: self integer :: iostat character ( len = 100 ) :: errmsg if (. not . allocated ( self % data )) then allocate ( self % data ( self % n ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"dense_zero_cdp\" ) endif self % data = zero_cdp end subroutine dense_zero_cdp subroutine dense_rand_cdp ( self , ifnorm ) implicit none ( type , external ) class ( dense_vector_cdp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm integer :: iostat character ( len = 100 ) :: errmsg real ( dp ), allocatable :: y (:, :) allocate ( y ( size ( self % data ), 2 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"dense_rand_cdp\" ) call random_number ( y ) self % data % re = y (:, 1 ) ; self % data % im = y (:, 2 ) end subroutine dense_rand_cdp subroutine dense_scal_cdp ( self , alpha ) implicit none ( type , external ) class ( dense_vector_cdp ), intent ( inout ) :: self complex ( dp ), intent ( in ) :: alpha integer :: n n = self % get_size () call scal ( n , alpha , self % data , 1 ) end subroutine dense_scal_cdp subroutine dense_axpby_cdp ( alpha , vec , beta , self ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: alpha , beta class ( dense_vector_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec integer :: n , m , iostat character ( len = 100 ) :: errmsg m = vec % get_size () if (. not . allocated ( self % data )) then allocate ( self % data ( m ), source = zero_cdp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"dense_axpby_cdp\" ) endif n = self % get_size () if ( m /= n ) call stop_error ( \"Inconsistent size between the two vectors.\" ) select type ( vec ) type is ( dense_vector_cdp ) if ( beta /= zero_cdp ) call self % scal ( beta ) call axpy ( n , alpha , vec % data , 1 , self % data , 1 ) class default call type_error ( 'vec' , 'dense_vector_cdp' , 'IN' , this_module , 'dense_axpby_cdp' ) end select end subroutine dense_axpby_cdp function dense_dot_cdp ( self , vec ) result ( alpha ) implicit none ( type , external ) class ( dense_vector_cdp ), intent ( in ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec complex ( dp ) :: alpha integer :: n n = self % get_size () select type ( vec ) type is ( dense_vector_cdp ) alpha = dotc ( n , self % data , 1 , vec % data , 1 ) class default call type_error ( 'vec' , 'dense_vector_cdp' , 'IN' , this_module , 'dense_dot_cdp' ) end select end function dense_dot_cdp function dense_get_size_cdp ( self ) result ( n ) implicit none ( type , external ) class ( dense_vector_cdp ), intent ( in ) :: self integer :: n n = size ( self % data ) end function dense_get_size_cdp !-------------------------------------- !-----      UTILITY FUNCTIONS     ----- !-------------------------------------- subroutine linear_combination_vector_rsp ( y , X , v ) !! Given `X` and `v`, this function return  \\mathbf{y} = \\mathbf{Xv}  where !! `y` is an `abstract_vector`, `X` an array of `abstract_vector` and `v` a !! Fortran array containing the coefficients of the linear combination. implicit none ( type , external ) class ( abstract_vector_rsp ), allocatable , intent ( out ) :: y !! Ouput vector. class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Krylov basis. real ( sp ), intent ( in ) :: v (:) !! Coordinates of `y` in the Krylov basis `X`. ! Internal variables integer :: i , iostat character ( len = 100 ) :: errmsg ! Check sizes. if ( size ( X ) /= size ( v )) then call stop_error ( \"Krylov basis X and low-dimensional vector v have different sizes.\" , & & this_module , 'linear_combination_vector_rsp' ) endif ! Initialize output vector. if (. not . allocated ( y )) then allocate ( y , source = X ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"linear_combination_vector_rsp\" ) endif call y % zero () ! Compute linear combination. do i = 1 , size ( X ) call y % axpby ( v ( i ), X ( i ), one_rsp ) ! y = y + X[i]*v[i] enddo end subroutine linear_combination_vector_rsp subroutine linear_combination_matrix_rsp ( Y , X , B ) !! Given `X` and `B`, this function computes \\mathbf{Y} = \\mathbf{XB}  where !! `X` and `Y` are arrays of `abstract_vector`, and `B` is a 2D Fortran array. implicit none ( type , external ) class ( abstract_vector_rsp ), allocatable , intent ( out ) :: Y (:) !! Output matrix. class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Krylov basis. real ( sp ), intent ( in ) :: B (:, :) !! Coefficients of the linear combinations. ! Internal variables. integer :: i , j , iostat character ( len = 100 ) :: errmsg ! Check sizes. if ( size ( X ) /= size ( B , 1 )) then call stop_error ( \"Krylov basis X and combination matrix B have incompatible sizes.\" , & this_module , 'linear_combination_matrix_rsp' ) endif ! Initialize output basis. if (. not . allocated ( Y )) then allocate ( Y ( size ( B , 2 )), source = X ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"linear_combination_matrix_rsp\" ) else if ( size ( Y ) /= size ( B , 2 )) then call stop_error ( \"Krylov basis Y and combination matrix B have incompatible sizes.\" , & this_module , 'linear_combination_matrix_rsp' ) endif endif do j = 1 , size ( Y ) call Y ( j )% zero () do i = 1 , size ( X ) call Y ( j )% axpby ( B ( i , j ), X ( i ), one_rsp ) ! y(j) = B(i,j)*X(i) + y(j) enddo enddo end subroutine linear_combination_matrix_rsp function gram_matrix_rsp ( X ) result ( G ) !! Computes the inner product/Gram matrix associated with the basis  \\mathbf{X} . implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( in ) :: X (:) real ( sp ) :: G ( size ( X ), size ( X )) integer :: i , j do i = 1 , size ( X ) do j = i , size ( X ) G ( i , j ) = X ( i )% dot ( X ( j )) G ( j , i ) = G ( i , j ) enddo enddo end function gram_matrix_rsp function innerprod_vector_rsp ( X , v ) result ( y ) !! Computes the inner product vector  \\mathbf{y} = \\mathbf{X}&#94;H \\mathbf{v}  between !! a basis `X` of `abstract_vector` and `v`, a single `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( in ) :: X (:), v !! Basis and single instance of `abstract_vector` whose inner products need to be computed. real ( sp ) :: y ( size ( X )) !! Resulting inner-product vector. ! Local variables. integer :: i y = zero_rsp do i = 1 , size ( X ) y ( i ) = X ( i )% dot ( v ) enddo end function innerprod_vector_rsp function innerprod_matrix_rsp ( X , Y ) result ( M ) !! Computes the inner product matrix  \\mathbf{M} = \\mathbf{X}&#94;H \\mathbf{Y}  between !! two bases of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( in ) :: X (:), Y (:) !! Bases of `abstract_vector` whose inner products need to be computed. real ( sp ) :: M ( size ( X ), size ( Y )) !! Resulting inner-product matrix. ! Local variables. integer :: i , j M = zero_rsp do j = 1 , size ( Y ) do i = 1 , size ( X ) M ( i , j ) = X ( i )% dot ( Y ( j )) enddo enddo end function innerprod_matrix_rsp impure elemental subroutine axpby_basis_rsp ( alpha , X , beta , Y ) !! Compute in-place  \\mathbf{Y} \\leftarrow \\alpha \\mathbf{X} + \\beta \\mathbf{Y}  where !! `X` and `Y` are arrays of `abstract_vector` and `alpha` and `beta` are real(sp) !! numbers. implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( in ) :: X !! Input/Ouput array of `abstract_vector`. class ( abstract_vector_rsp ), intent ( inout ) :: Y !! Array of `abstract_vector` to be added/subtracted to/from `X`. real ( sp ), intent ( in ) :: alpha , beta !! Scalar multipliers. call Y % axpby ( alpha , X , beta ) end subroutine axpby_basis_rsp impure elemental subroutine zero_basis_rsp ( X ) implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: X call X % zero () end subroutine zero_basis_rsp impure elemental subroutine copy_vector_rsp ( out , from ) implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( in ) :: from class ( abstract_vector_rsp ), intent ( out ) :: out ! Copy array. call out % axpby ( one_rsp , from , zero_rsp ) end subroutine copy_vector_rsp impure elemental subroutine rand_basis_rsp ( X , ifnorm ) implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: X logical , optional , intent ( in ) :: ifnorm call X % rand ( ifnorm = ifnorm ) end subroutine rand_basis_rsp subroutine linear_combination_vector_rdp ( y , X , v ) !! Given `X` and `v`, this function return  \\mathbf{y} = \\mathbf{Xv}  where !! `y` is an `abstract_vector`, `X` an array of `abstract_vector` and `v` a !! Fortran array containing the coefficients of the linear combination. implicit none ( type , external ) class ( abstract_vector_rdp ), allocatable , intent ( out ) :: y !! Ouput vector. class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Krylov basis. real ( dp ), intent ( in ) :: v (:) !! Coordinates of `y` in the Krylov basis `X`. ! Internal variables integer :: i , iostat character ( len = 100 ) :: errmsg ! Check sizes. if ( size ( X ) /= size ( v )) then call stop_error ( \"Krylov basis X and low-dimensional vector v have different sizes.\" , & & this_module , 'linear_combination_vector_rdp' ) endif ! Initialize output vector. if (. not . allocated ( y )) then allocate ( y , source = X ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"linear_combination_vector_rdp\" ) endif call y % zero () ! Compute linear combination. do i = 1 , size ( X ) call y % axpby ( v ( i ), X ( i ), one_rdp ) ! y = y + X[i]*v[i] enddo end subroutine linear_combination_vector_rdp subroutine linear_combination_matrix_rdp ( Y , X , B ) !! Given `X` and `B`, this function computes \\mathbf{Y} = \\mathbf{XB}  where !! `X` and `Y` are arrays of `abstract_vector`, and `B` is a 2D Fortran array. implicit none ( type , external ) class ( abstract_vector_rdp ), allocatable , intent ( out ) :: Y (:) !! Output matrix. class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Krylov basis. real ( dp ), intent ( in ) :: B (:, :) !! Coefficients of the linear combinations. ! Internal variables. integer :: i , j , iostat character ( len = 100 ) :: errmsg ! Check sizes. if ( size ( X ) /= size ( B , 1 )) then call stop_error ( \"Krylov basis X and combination matrix B have incompatible sizes.\" , & this_module , 'linear_combination_matrix_rdp' ) endif ! Initialize output basis. if (. not . allocated ( Y )) then allocate ( Y ( size ( B , 2 )), source = X ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"linear_combination_matrix_rdp\" ) else if ( size ( Y ) /= size ( B , 2 )) then call stop_error ( \"Krylov basis Y and combination matrix B have incompatible sizes.\" , & this_module , 'linear_combination_matrix_rdp' ) endif endif do j = 1 , size ( Y ) call Y ( j )% zero () do i = 1 , size ( X ) call Y ( j )% axpby ( B ( i , j ), X ( i ), one_rdp ) ! y(j) = B(i,j)*X(i) + y(j) enddo enddo end subroutine linear_combination_matrix_rdp function gram_matrix_rdp ( X ) result ( G ) !! Computes the inner product/Gram matrix associated with the basis  \\mathbf{X} . implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( in ) :: X (:) real ( dp ) :: G ( size ( X ), size ( X )) integer :: i , j do i = 1 , size ( X ) do j = i , size ( X ) G ( i , j ) = X ( i )% dot ( X ( j )) G ( j , i ) = G ( i , j ) enddo enddo end function gram_matrix_rdp function innerprod_vector_rdp ( X , v ) result ( y ) !! Computes the inner product vector  \\mathbf{y} = \\mathbf{X}&#94;H \\mathbf{v}  between !! a basis `X` of `abstract_vector` and `v`, a single `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( in ) :: X (:), v !! Basis and single instance of `abstract_vector` whose inner products need to be computed. real ( dp ) :: y ( size ( X )) !! Resulting inner-product vector. ! Local variables. integer :: i y = zero_rdp do i = 1 , size ( X ) y ( i ) = X ( i )% dot ( v ) enddo end function innerprod_vector_rdp function innerprod_matrix_rdp ( X , Y ) result ( M ) !! Computes the inner product matrix  \\mathbf{M} = \\mathbf{X}&#94;H \\mathbf{Y}  between !! two bases of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( in ) :: X (:), Y (:) !! Bases of `abstract_vector` whose inner products need to be computed. real ( dp ) :: M ( size ( X ), size ( Y )) !! Resulting inner-product matrix. ! Local variables. integer :: i , j M = zero_rdp do j = 1 , size ( Y ) do i = 1 , size ( X ) M ( i , j ) = X ( i )% dot ( Y ( j )) enddo enddo end function innerprod_matrix_rdp impure elemental subroutine axpby_basis_rdp ( alpha , X , beta , Y ) !! Compute in-place  \\mathbf{Y} \\leftarrow \\alpha \\mathbf{X} + \\beta \\mathbf{Y}  where !! `X` and `Y` are arrays of `abstract_vector` and `alpha` and `beta` are real(dp) !! numbers. implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( in ) :: X !! Input/Ouput array of `abstract_vector`. class ( abstract_vector_rdp ), intent ( inout ) :: Y !! Array of `abstract_vector` to be added/subtracted to/from `X`. real ( dp ), intent ( in ) :: alpha , beta !! Scalar multipliers. call Y % axpby ( alpha , X , beta ) end subroutine axpby_basis_rdp impure elemental subroutine zero_basis_rdp ( X ) implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: X call X % zero () end subroutine zero_basis_rdp impure elemental subroutine copy_vector_rdp ( out , from ) implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( in ) :: from class ( abstract_vector_rdp ), intent ( out ) :: out ! Copy array. call out % axpby ( one_rdp , from , zero_rdp ) end subroutine copy_vector_rdp impure elemental subroutine rand_basis_rdp ( X , ifnorm ) implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: X logical , optional , intent ( in ) :: ifnorm call X % rand ( ifnorm = ifnorm ) end subroutine rand_basis_rdp subroutine linear_combination_vector_csp ( y , X , v ) !! Given `X` and `v`, this function return  \\mathbf{y} = \\mathbf{Xv}  where !! `y` is an `abstract_vector`, `X` an array of `abstract_vector` and `v` a !! Fortran array containing the coefficients of the linear combination. implicit none ( type , external ) class ( abstract_vector_csp ), allocatable , intent ( out ) :: y !! Ouput vector. class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Krylov basis. complex ( sp ), intent ( in ) :: v (:) !! Coordinates of `y` in the Krylov basis `X`. ! Internal variables integer :: i , iostat character ( len = 100 ) :: errmsg ! Check sizes. if ( size ( X ) /= size ( v )) then call stop_error ( \"Krylov basis X and low-dimensional vector v have different sizes.\" , & & this_module , 'linear_combination_vector_csp' ) endif ! Initialize output vector. if (. not . allocated ( y )) then allocate ( y , source = X ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"linear_combination_vector_csp\" ) endif call y % zero () ! Compute linear combination. do i = 1 , size ( X ) call y % axpby ( v ( i ), X ( i ), one_csp ) ! y = y + X[i]*v[i] enddo end subroutine linear_combination_vector_csp subroutine linear_combination_matrix_csp ( Y , X , B ) !! Given `X` and `B`, this function computes \\mathbf{Y} = \\mathbf{XB}  where !! `X` and `Y` are arrays of `abstract_vector`, and `B` is a 2D Fortran array. implicit none ( type , external ) class ( abstract_vector_csp ), allocatable , intent ( out ) :: Y (:) !! Output matrix. class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Krylov basis. complex ( sp ), intent ( in ) :: B (:, :) !! Coefficients of the linear combinations. ! Internal variables. integer :: i , j , iostat character ( len = 100 ) :: errmsg ! Check sizes. if ( size ( X ) /= size ( B , 1 )) then call stop_error ( \"Krylov basis X and combination matrix B have incompatible sizes.\" , & this_module , 'linear_combination_matrix_csp' ) endif ! Initialize output basis. if (. not . allocated ( Y )) then allocate ( Y ( size ( B , 2 )), source = X ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"linear_combination_matrix_csp\" ) else if ( size ( Y ) /= size ( B , 2 )) then call stop_error ( \"Krylov basis Y and combination matrix B have incompatible sizes.\" , & this_module , 'linear_combination_matrix_csp' ) endif endif do j = 1 , size ( Y ) call Y ( j )% zero () do i = 1 , size ( X ) call Y ( j )% axpby ( B ( i , j ), X ( i ), one_csp ) ! y(j) = B(i,j)*X(i) + y(j) enddo enddo end subroutine linear_combination_matrix_csp function gram_matrix_csp ( X ) result ( G ) !! Computes the inner product/Gram matrix associated with the basis  \\mathbf{X} . implicit none ( type , external ) class ( abstract_vector_csp ), intent ( in ) :: X (:) complex ( sp ) :: G ( size ( X ), size ( X )) integer :: i , j do i = 1 , size ( X ) do j = i , size ( X ) G ( i , j ) = X ( i )% dot ( X ( j )) G ( j , i ) = G ( i , j ) enddo enddo end function gram_matrix_csp function innerprod_vector_csp ( X , v ) result ( y ) !! Computes the inner product vector  \\mathbf{y} = \\mathbf{X}&#94;H \\mathbf{v}  between !! a basis `X` of `abstract_vector` and `v`, a single `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_csp ), intent ( in ) :: X (:), v !! Basis and single instance of `abstract_vector` whose inner products need to be computed. complex ( sp ) :: y ( size ( X )) !! Resulting inner-product vector. ! Local variables. integer :: i y = zero_csp do i = 1 , size ( X ) y ( i ) = X ( i )% dot ( v ) enddo end function innerprod_vector_csp function innerprod_matrix_csp ( X , Y ) result ( M ) !! Computes the inner product matrix  \\mathbf{M} = \\mathbf{X}&#94;H \\mathbf{Y}  between !! two bases of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_csp ), intent ( in ) :: X (:), Y (:) !! Bases of `abstract_vector` whose inner products need to be computed. complex ( sp ) :: M ( size ( X ), size ( Y )) !! Resulting inner-product matrix. ! Local variables. integer :: i , j M = zero_csp do j = 1 , size ( Y ) do i = 1 , size ( X ) M ( i , j ) = X ( i )% dot ( Y ( j )) enddo enddo end function innerprod_matrix_csp impure elemental subroutine axpby_basis_csp ( alpha , X , beta , Y ) !! Compute in-place  \\mathbf{Y} \\leftarrow \\alpha \\mathbf{X} + \\beta \\mathbf{Y}  where !! `X` and `Y` are arrays of `abstract_vector` and `alpha` and `beta` are complex(sp) !! numbers. implicit none ( type , external ) class ( abstract_vector_csp ), intent ( in ) :: X !! Input/Ouput array of `abstract_vector`. class ( abstract_vector_csp ), intent ( inout ) :: Y !! Array of `abstract_vector` to be added/subtracted to/from `X`. complex ( sp ), intent ( in ) :: alpha , beta !! Scalar multipliers. call Y % axpby ( alpha , X , beta ) end subroutine axpby_basis_csp impure elemental subroutine zero_basis_csp ( X ) implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: X call X % zero () end subroutine zero_basis_csp impure elemental subroutine copy_vector_csp ( out , from ) implicit none ( type , external ) class ( abstract_vector_csp ), intent ( in ) :: from class ( abstract_vector_csp ), intent ( out ) :: out ! Copy array. call out % axpby ( one_csp , from , zero_csp ) end subroutine copy_vector_csp impure elemental subroutine rand_basis_csp ( X , ifnorm ) implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: X logical , optional , intent ( in ) :: ifnorm call X % rand ( ifnorm = ifnorm ) end subroutine rand_basis_csp subroutine linear_combination_vector_cdp ( y , X , v ) !! Given `X` and `v`, this function return  \\mathbf{y} = \\mathbf{Xv}  where !! `y` is an `abstract_vector`, `X` an array of `abstract_vector` and `v` a !! Fortran array containing the coefficients of the linear combination. implicit none ( type , external ) class ( abstract_vector_cdp ), allocatable , intent ( out ) :: y !! Ouput vector. class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Krylov basis. complex ( dp ), intent ( in ) :: v (:) !! Coordinates of `y` in the Krylov basis `X`. ! Internal variables integer :: i , iostat character ( len = 100 ) :: errmsg ! Check sizes. if ( size ( X ) /= size ( v )) then call stop_error ( \"Krylov basis X and low-dimensional vector v have different sizes.\" , & & this_module , 'linear_combination_vector_cdp' ) endif ! Initialize output vector. if (. not . allocated ( y )) then allocate ( y , source = X ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"linear_combination_vector_cdp\" ) endif call y % zero () ! Compute linear combination. do i = 1 , size ( X ) call y % axpby ( v ( i ), X ( i ), one_cdp ) ! y = y + X[i]*v[i] enddo end subroutine linear_combination_vector_cdp subroutine linear_combination_matrix_cdp ( Y , X , B ) !! Given `X` and `B`, this function computes \\mathbf{Y} = \\mathbf{XB}  where !! `X` and `Y` are arrays of `abstract_vector`, and `B` is a 2D Fortran array. implicit none ( type , external ) class ( abstract_vector_cdp ), allocatable , intent ( out ) :: Y (:) !! Output matrix. class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Krylov basis. complex ( dp ), intent ( in ) :: B (:, :) !! Coefficients of the linear combinations. ! Internal variables. integer :: i , j , iostat character ( len = 100 ) :: errmsg ! Check sizes. if ( size ( X ) /= size ( B , 1 )) then call stop_error ( \"Krylov basis X and combination matrix B have incompatible sizes.\" , & this_module , 'linear_combination_matrix_cdp' ) endif ! Initialize output basis. if (. not . allocated ( Y )) then allocate ( Y ( size ( B , 2 )), source = X ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"linear_combination_matrix_cdp\" ) else if ( size ( Y ) /= size ( B , 2 )) then call stop_error ( \"Krylov basis Y and combination matrix B have incompatible sizes.\" , & this_module , 'linear_combination_matrix_cdp' ) endif endif do j = 1 , size ( Y ) call Y ( j )% zero () do i = 1 , size ( X ) call Y ( j )% axpby ( B ( i , j ), X ( i ), one_cdp ) ! y(j) = B(i,j)*X(i) + y(j) enddo enddo end subroutine linear_combination_matrix_cdp function gram_matrix_cdp ( X ) result ( G ) !! Computes the inner product/Gram matrix associated with the basis  \\mathbf{X} . implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( in ) :: X (:) complex ( dp ) :: G ( size ( X ), size ( X )) integer :: i , j do i = 1 , size ( X ) do j = i , size ( X ) G ( i , j ) = X ( i )% dot ( X ( j )) G ( j , i ) = G ( i , j ) enddo enddo end function gram_matrix_cdp function innerprod_vector_cdp ( X , v ) result ( y ) !! Computes the inner product vector  \\mathbf{y} = \\mathbf{X}&#94;H \\mathbf{v}  between !! a basis `X` of `abstract_vector` and `v`, a single `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( in ) :: X (:), v !! Basis and single instance of `abstract_vector` whose inner products need to be computed. complex ( dp ) :: y ( size ( X )) !! Resulting inner-product vector. ! Local variables. integer :: i y = zero_cdp do i = 1 , size ( X ) y ( i ) = X ( i )% dot ( v ) enddo end function innerprod_vector_cdp function innerprod_matrix_cdp ( X , Y ) result ( M ) !! Computes the inner product matrix  \\mathbf{M} = \\mathbf{X}&#94;H \\mathbf{Y}  between !! two bases of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( in ) :: X (:), Y (:) !! Bases of `abstract_vector` whose inner products need to be computed. complex ( dp ) :: M ( size ( X ), size ( Y )) !! Resulting inner-product matrix. ! Local variables. integer :: i , j M = zero_cdp do j = 1 , size ( Y ) do i = 1 , size ( X ) M ( i , j ) = X ( i )% dot ( Y ( j )) enddo enddo end function innerprod_matrix_cdp impure elemental subroutine axpby_basis_cdp ( alpha , X , beta , Y ) !! Compute in-place  \\mathbf{Y} \\leftarrow \\alpha \\mathbf{X} + \\beta \\mathbf{Y}  where !! `X` and `Y` are arrays of `abstract_vector` and `alpha` and `beta` are complex(dp) !! numbers. implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( in ) :: X !! Input/Ouput array of `abstract_vector`. class ( abstract_vector_cdp ), intent ( inout ) :: Y !! Array of `abstract_vector` to be added/subtracted to/from `X`. complex ( dp ), intent ( in ) :: alpha , beta !! Scalar multipliers. call Y % axpby ( alpha , X , beta ) end subroutine axpby_basis_cdp impure elemental subroutine zero_basis_cdp ( X ) implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: X call X % zero () end subroutine zero_basis_cdp impure elemental subroutine copy_vector_cdp ( out , from ) implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( in ) :: from class ( abstract_vector_cdp ), intent ( out ) :: out ! Copy array. call out % axpby ( one_cdp , from , zero_cdp ) end subroutine copy_vector_cdp impure elemental subroutine rand_basis_cdp ( X , ifnorm ) implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: X logical , optional , intent ( in ) :: ifnorm call X % rand ( ifnorm = ifnorm ) end subroutine rand_basis_cdp end module LightKrylov_AbstractVectors","tags":"","url":"sourcefile/abstractvectors.f90.html"},{"title":"CG.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_iterativesolvers ) cg_solver use stdlib_strings , only : padr implicit none ( type , external ) contains !---------------------------------------- !-----     Options and Metadata     ----- !---------------------------------------- module procedure print_cg_sp character ( len =* ), parameter :: this_procedure = 'print_cg_sp' integer :: i logical :: ifreset , ifverbose character ( len = 128 ) :: msg ifreset = optval ( reset_counters , . false .) ifverbose = optval ( verbose , . false .) write ( msg , '(A30,I20)' ) padr ( 'Iterations: ' , 30 ), self % n_iter call log_message ( msg , this_module , this_procedure ) if ( ifverbose ) then write ( msg , '(14X,A15)' ) 'Residual' call log_message ( msg , this_module , this_procedure ) call log_message ( 'Residual history:' , this_module , this_procedure ) write ( msg , '(A14,E15.8)' ) '   INIT:' , self % res ( 1 ) call log_message ( msg , this_module , this_procedure ) do i = 2 , self % n_iter + 1 write ( msg , '(A,I4,A,E15.8)' ) '   Step ' , i - 1 , ': ' , self % res ( i ) call log_message ( msg , this_module , this_procedure ) end do else write ( msg , '(A30,I20)' ) padr ( 'Number of records: ' , 30 ), size ( self % res ) call log_message ( msg , this_module , this_procedure ) write ( msg , '(A30,E20.8)' ) padr ( 'Residual: ' , 30 ), self % res ( size ( self % res )) call log_message ( msg , this_module , this_procedure ) end if if ( self % converged ) then call log_message ( 'Status: CONVERGED' , this_module , this_procedure ) else call log_message ( 'Status: NOT CONVERGED' , this_module , this_procedure ) end if if ( ifreset ) call self % reset () end procedure module procedure reset_cg_sp self % n_iter = 0 self % converged = . false . self % info = 0 if ( allocated ( self % res )) deallocate ( self % res ) end procedure module procedure print_cg_dp character ( len =* ), parameter :: this_procedure = 'print_cg_dp' integer :: i logical :: ifreset , ifverbose character ( len = 128 ) :: msg ifreset = optval ( reset_counters , . false .) ifverbose = optval ( verbose , . false .) write ( msg , '(A30,I20)' ) padr ( 'Iterations: ' , 30 ), self % n_iter call log_message ( msg , this_module , this_procedure ) if ( ifverbose ) then write ( msg , '(14X,A15)' ) 'Residual' call log_message ( msg , this_module , this_procedure ) call log_message ( 'Residual history:' , this_module , this_procedure ) write ( msg , '(A14,E15.8)' ) '   INIT:' , self % res ( 1 ) call log_message ( msg , this_module , this_procedure ) do i = 2 , self % n_iter + 1 write ( msg , '(A,I4,A,E15.8)' ) '   Step ' , i - 1 , ': ' , self % res ( i ) call log_message ( msg , this_module , this_procedure ) end do else write ( msg , '(A30,I20)' ) padr ( 'Number of records: ' , 30 ), size ( self % res ) call log_message ( msg , this_module , this_procedure ) write ( msg , '(A30,E20.8)' ) padr ( 'Residual: ' , 30 ), self % res ( size ( self % res )) call log_message ( msg , this_module , this_procedure ) end if if ( self % converged ) then call log_message ( 'Status: CONVERGED' , this_module , this_procedure ) else call log_message ( 'Status: NOT CONVERGED' , this_module , this_procedure ) end if if ( ifreset ) call self % reset () end procedure module procedure reset_cg_dp self % n_iter = 0 self % converged = . false . self % info = 0 if ( allocated ( self % res )) deallocate ( self % res ) end procedure !------------------------------------------------- !-----     CG SOLVERS FOR ABSTRACT TYPES     ----- !------------------------------------------------- module procedure cg_rsp ! Options. integer :: maxiter real ( sp ) :: tol , rtol_ , atol_ type ( cg_sp_opts ) :: opts type ( cg_sp_metadata ) :: cg_meta ! Working variables. class ( abstract_vector_rsp ), allocatable :: r , p , Ap , z real ( sp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( sp ) :: residual ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'cg_rsp' integer :: i , iostat character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then opts = options else opts = cg_sp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call r % zero () allocate ( p , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call p % zero () allocate ( Ap , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call Ap % zero () ! Initialize meta & reset matvec counter cg_meta = cg_sp_metadata () call A % reset_counter (. false ., 'cg%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % apply_matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Deal with the preconditioner (if available). if ( ifprecond ) then z = r ; call preconditioner % apply ( z ) ; p = z r_dot_r_old = r % dot ( z ) else p = r ; r_dot_r_old = r % dot ( r ) endif allocate ( cg_meta % res ( 1 ), source = sqrt ( abs ( r_dot_r_old )), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % apply_matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( alpha , p , one_rsp ) ! Update residual r = r - alpha*Ap call r % axpby ( - alpha , Ap , one_rsp ) if ( ifprecond ) then z = r ; call preconditioner % apply ( z ) ; r_dot_r_new = r % dot ( z ) else ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) endif ! Check for convergence. residual = sqrt ( r_dot_r_new ) ! Save metadata. cg_meta % n_iter = cg_meta % n_iter + 1 cg_meta % res = [ cg_meta % res , residual ] if ( residual < tol ) then cg_meta % converged = . true . exit cg_loop end if ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r if ( ifprecond ) then call p % axpby ( one_rsp , z , beta ) else call p % axpby ( one_rsp , r , beta ) endif ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) enddo cg_loop end associate ! Returns the number of iterations if converged if ( cg_meta % converged ) then info = cg_meta % n_iter else info = - cg_meta % n_iter end if cg_meta % info = info if ( opts % if_print_metadata ) call cg_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( cg_sp_metadata ) meta = cg_meta class default call type_error ( 'meta' , 'cg_sp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter (. false ., 'cg%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure cg_rdp ! Options. integer :: maxiter real ( dp ) :: tol , rtol_ , atol_ type ( cg_dp_opts ) :: opts type ( cg_dp_metadata ) :: cg_meta ! Working variables. class ( abstract_vector_rdp ), allocatable :: r , p , Ap , z real ( dp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( dp ) :: residual ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'cg_rdp' integer :: i , iostat character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then opts = options else opts = cg_dp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call r % zero () allocate ( p , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call p % zero () allocate ( Ap , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call Ap % zero () ! Initialize meta & reset matvec counter cg_meta = cg_dp_metadata () call A % reset_counter (. false ., 'cg%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % apply_matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Deal with the preconditioner (if available). if ( ifprecond ) then z = r ; call preconditioner % apply ( z ) ; p = z r_dot_r_old = r % dot ( z ) else p = r ; r_dot_r_old = r % dot ( r ) endif allocate ( cg_meta % res ( 1 ), source = sqrt ( abs ( r_dot_r_old )), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % apply_matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( alpha , p , one_rdp ) ! Update residual r = r - alpha*Ap call r % axpby ( - alpha , Ap , one_rdp ) if ( ifprecond ) then z = r ; call preconditioner % apply ( z ) ; r_dot_r_new = r % dot ( z ) else ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) endif ! Check for convergence. residual = sqrt ( r_dot_r_new ) ! Save metadata. cg_meta % n_iter = cg_meta % n_iter + 1 cg_meta % res = [ cg_meta % res , residual ] if ( residual < tol ) then cg_meta % converged = . true . exit cg_loop end if ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r if ( ifprecond ) then call p % axpby ( one_rdp , z , beta ) else call p % axpby ( one_rdp , r , beta ) endif ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) enddo cg_loop end associate ! Returns the number of iterations if converged if ( cg_meta % converged ) then info = cg_meta % n_iter else info = - cg_meta % n_iter end if cg_meta % info = info if ( opts % if_print_metadata ) call cg_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( cg_dp_metadata ) meta = cg_meta class default call type_error ( 'meta' , 'cg_dp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter (. false ., 'cg%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure cg_csp ! Options. integer :: maxiter real ( sp ) :: tol , rtol_ , atol_ type ( cg_sp_opts ) :: opts type ( cg_sp_metadata ) :: cg_meta ! Working variables. class ( abstract_vector_csp ), allocatable :: r , p , Ap , z complex ( sp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( sp ) :: residual ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'cg_csp' integer :: i , iostat character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then opts = options else opts = cg_sp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call r % zero () allocate ( p , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call p % zero () allocate ( Ap , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call Ap % zero () ! Initialize meta & reset matvec counter cg_meta = cg_sp_metadata () call A % reset_counter (. false ., 'cg%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % apply_matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Deal with the preconditioner (if available). if ( ifprecond ) then z = r ; call preconditioner % apply ( z ) ; p = z r_dot_r_old = r % dot ( z ) else p = r ; r_dot_r_old = r % dot ( r ) endif allocate ( cg_meta % res ( 1 ), source = sqrt ( abs ( r_dot_r_old )), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % apply_matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( alpha , p , one_csp ) ! Update residual r = r - alpha*Ap call r % axpby ( - alpha , Ap , one_csp ) if ( ifprecond ) then z = r ; call preconditioner % apply ( z ) ; r_dot_r_new = r % dot ( z ) else ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) endif ! Check for convergence. residual = sqrt ( abs ( r_dot_r_new )) ! Save metadata. cg_meta % n_iter = cg_meta % n_iter + 1 cg_meta % res = [ cg_meta % res , residual ] if ( residual < tol ) then cg_meta % converged = . true . exit cg_loop end if ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r if ( ifprecond ) then call p % axpby ( one_csp , z , beta ) else call p % axpby ( one_csp , r , beta ) endif ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) enddo cg_loop end associate ! Returns the number of iterations if converged if ( cg_meta % converged ) then info = cg_meta % n_iter else info = - cg_meta % n_iter end if cg_meta % info = info if ( opts % if_print_metadata ) call cg_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( cg_sp_metadata ) meta = cg_meta class default call type_error ( 'meta' , 'cg_sp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter (. false ., 'cg%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure cg_cdp ! Options. integer :: maxiter real ( dp ) :: tol , rtol_ , atol_ type ( cg_dp_opts ) :: opts type ( cg_dp_metadata ) :: cg_meta ! Working variables. class ( abstract_vector_cdp ), allocatable :: r , p , Ap , z complex ( dp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( dp ) :: residual ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'cg_cdp' integer :: i , iostat character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then opts = options else opts = cg_dp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call r % zero () allocate ( p , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call p % zero () allocate ( Ap , mold = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call Ap % zero () ! Initialize meta & reset matvec counter cg_meta = cg_dp_metadata () call A % reset_counter (. false ., 'cg%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % apply_matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Deal with the preconditioner (if available). if ( ifprecond ) then z = r ; call preconditioner % apply ( z ) ; p = z r_dot_r_old = r % dot ( z ) else p = r ; r_dot_r_old = r % dot ( r ) endif allocate ( cg_meta % res ( 1 ), source = sqrt ( abs ( r_dot_r_old )), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % apply_matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( alpha , p , one_cdp ) ! Update residual r = r - alpha*Ap call r % axpby ( - alpha , Ap , one_cdp ) if ( ifprecond ) then z = r ; call preconditioner % apply ( z ) ; r_dot_r_new = r % dot ( z ) else ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) endif ! Check for convergence. residual = sqrt ( abs ( r_dot_r_new )) ! Save metadata. cg_meta % n_iter = cg_meta % n_iter + 1 cg_meta % res = [ cg_meta % res , residual ] if ( residual < tol ) then cg_meta % converged = . true . exit cg_loop end if ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r if ( ifprecond ) then call p % axpby ( one_cdp , z , beta ) else call p % axpby ( one_cdp , r , beta ) endif ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) enddo cg_loop end associate ! Returns the number of iterations if converged if ( cg_meta % converged ) then info = cg_meta % n_iter else info = - cg_meta % n_iter end if cg_meta % info = info if ( opts % if_print_metadata ) call cg_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( cg_dp_metadata ) meta = cg_meta class default call type_error ( 'meta' , 'cg_dp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter (. false ., 'cg%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure end submodule","tags":"","url":"sourcefile/cg.f90.html"},{"title":"fgmres.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_iterativesolvers ) fgmres_solver use stdlib_strings , only : padr use stdlib_linalg , only : lstsq , norm use stdlib_linalg_lapack , only : trtrs implicit none ( type , external ) contains !---------------------------------------- !-----     Options and Metadata     ----- !---------------------------------------- module procedure print_fgmres_sp ! internals character ( len =* ), parameter :: this_procedure = 'print_fgmres_sp' integer :: i logical :: ifreset , ifverbose character ( len = 128 ) :: msg ifreset = optval ( reset_counters , . false .) ifverbose = optval ( verbose , . false .) write ( msg , '(A30,I6,\"  (\",I6,\"/\",I3,\")\")' ) padr ( 'Iterations   (inner/outer): ' , 30 ), & & self % n_iter , self % n_inner , self % n_outer call log_message ( msg , this_module , this_procedure ) if ( ifverbose ) then write ( msg , '(14X,A15)' ) 'Residual' call log_message ( msg , this_module , this_procedure ) write ( msg , '(A14,E15.8)' ) '   INIT:' , self % res ( 1 ) call log_message ( msg , this_module , this_procedure ) do i = 1 , self % n_iter write ( msg , '(A,I3,A,E20.8)' ) '   Step ' , i , ': ' , self % res ( i ) call log_message ( msg , this_module , this_procedure ) end do else write ( msg , '(A30,I20)' ) padr ( 'Number of records: ' , 30 ), size ( self % res ) call log_message ( msg , this_module , this_procedure ) write ( msg , '(A30,E20.8)' ) padr ( 'Residual: ' , 30 ), self % res ( size ( self % res )) call log_message ( msg , this_module , this_procedure ) end if if ( self % converged ) then call log_message ( 'Status: CONVERGED' , this_module , this_procedure ) else call log_message ( 'Status: NOT CONVERGED' , this_module , this_procedure ) end if if ( ifreset ) call self % reset () end procedure module procedure reset_fgmres_sp self % n_iter = 0 self % n_inner = 0 self % n_outer = 0 self % converged = . false . self % info = 0 if ( allocated ( self % res )) deallocate ( self % res ) end procedure module procedure print_fgmres_dp ! internals character ( len =* ), parameter :: this_procedure = 'print_fgmres_dp' integer :: i logical :: ifreset , ifverbose character ( len = 128 ) :: msg ifreset = optval ( reset_counters , . false .) ifverbose = optval ( verbose , . false .) write ( msg , '(A30,I6,\"  (\",I6,\"/\",I3,\")\")' ) padr ( 'Iterations   (inner/outer): ' , 30 ), & & self % n_iter , self % n_inner , self % n_outer call log_message ( msg , this_module , this_procedure ) if ( ifverbose ) then write ( msg , '(14X,A15)' ) 'Residual' call log_message ( msg , this_module , this_procedure ) write ( msg , '(A14,E15.8)' ) '   INIT:' , self % res ( 1 ) call log_message ( msg , this_module , this_procedure ) do i = 1 , self % n_iter write ( msg , '(A,I3,A,E20.8)' ) '   Step ' , i , ': ' , self % res ( i ) call log_message ( msg , this_module , this_procedure ) end do else write ( msg , '(A30,I20)' ) padr ( 'Number of records: ' , 30 ), size ( self % res ) call log_message ( msg , this_module , this_procedure ) write ( msg , '(A30,E20.8)' ) padr ( 'Residual: ' , 30 ), self % res ( size ( self % res )) call log_message ( msg , this_module , this_procedure ) end if if ( self % converged ) then call log_message ( 'Status: CONVERGED' , this_module , this_procedure ) else call log_message ( 'Status: NOT CONVERGED' , this_module , this_procedure ) end if if ( ifreset ) call self % reset () end procedure module procedure reset_fgmres_dp self % n_iter = 0 self % n_inner = 0 self % n_outer = 0 self % converged = . false . self % info = 0 if ( allocated ( self % res )) deallocate ( self % res ) end procedure !------------------------------------------------------------- !-----     FLEXIBLE GMRES SOLVERS FOR ABSTRACT TYPES     ----- !------------------------------------------------------------- module procedure fgmres_rsp ! Options. integer :: kdim , maxiter real ( sp ) :: tol , rtol_ , atol_ logical :: trans type ( fgmres_sp_opts ) :: opts type ( fgmres_sp_metadata ) :: fgmres_meta ! Krylov subspace class ( abstract_vector_rsp ), allocatable :: V (:), Z (:) ! Hessenberg matrix. real ( sp ), allocatable :: H (:, :) ! Least-squares variables. real ( sp ), target , allocatable :: e (:) real ( sp ), pointer :: y (:, :) real ( sp ) :: beta ! Givens rotations. real ( sp ), allocatable :: c (:), s (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'fgmres_rsp' integer :: k , iostat class ( abstract_vector_rsp ), allocatable :: dx , wrk character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then select type ( options ) type is ( fgmres_sp_opts ) opts = options class default call type_error ( 'options' , 'fgmres_sp_opts' , 'IN' , this_module , this_procedure ) end select else opts = fgmres_sp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Initialize working variables. allocate ( wrk , source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call wrk % zero () allocate ( V ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( V ) allocate ( Z ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Z ) allocate ( H ( kdim + 1 , kdim ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( e ( kdim + 1 ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( c ( kdim ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( s ( kdim ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Initialize metadata and & reset matvec counter fgmres_meta = fgmres_sp_metadata () ; fgmres_meta % converged = . false . call A % reset_counter ( trans , 'fgmres%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) do while ((. not . fgmres_meta % converged ) . and . ( fgmres_meta % n_outer <= maxiter )) !> Initialize data H = 0.0_sp ; call zero_basis ( V ) if ( x % norm () /= 0.0_sp ) then if ( trans ) then call A % apply_rmatvec ( x , V ( 1 )) else call A % apply_matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () e = 0.0_sp ; beta = V ( 1 )% norm () ; e ( 1 ) = beta call V ( 1 )% scal ( one_rsp / beta ) c = 0.0_sp ; s = 0.0_sp if ( fgmres_meta % n_outer == 0 ) then allocate ( fgmres_meta % res ( 1 ), source = abs ( beta ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) write ( msg , '(2(A,E11.4))' ) 'FGMRES(k)   init step     : |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if gmres_iter : do k = 1 , kdim !> Preconditioner. call copy ( Z ( k ), V ( k )) ; if ( ifprecond ) call preconditioner % apply ( Z ( k ), k , beta , tol ) !----------------------------------------- !-----     Arnoldi factorization     ----- !----------------------------------------- !> Matrix vector product. if ( trans ) then call A % apply_rmatvec ( Z ( k ), V ( k + 1 )) else call A % apply_matvec ( Z ( k ), V ( k + 1 )) endif !> Orthogonalization + Hessenberg update. call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) !> Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) call V ( k + 1 )% scal ( one_rsp / H ( k + 1 , k )) !----------------------------------------- !-----     Least-Squares Problem     ----- !----------------------------------------- !> Apply Givens rotations to the Hessenberg matrix. call apply_givens_rotation ( H (: k + 1 , k ), c (: k ), s (: k )) !> Update the right-hand side vector accordingly. e ( k + 1 ) = - s ( k ) * e ( k ) ; e ( k ) = c ( k ) * e ( k ) !> Least-squares residual. beta = abs ( e ( k + 1 )) ! Save metadata. fgmres_meta % n_iter = fgmres_meta % n_iter + 1 fgmres_meta % n_inner = fgmres_meta % n_inner + 1 fgmres_meta % res = [ fgmres_meta % res , abs ( beta ) ] ! Check convergence. write ( msg , '(A,I3,2(A,E11.4))' ) 'FGMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) if ( abs ( beta ) < tol ) fgmres_meta % converged = . true . if ( fgmres_meta % converged ) exit gmres_iter enddo gmres_iter ! Update solution. k = min ( k , kdim ) y ( 1 : k , 1 : 1 ) => e (: k ) ; call trtrs ( \"u\" , \"n\" , \"n\" , k , 1 , H (: k , : k ), k , y , k , info ) call linear_combination ( dx , Z (: k ), e (: k )) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % apply_rmatvec ( x , v ( 1 )) else call A % apply_matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; if ( abs ( beta ) > 0.0_sp ) call v ( 1 )% scal ( one_rsp / beta ) ! Save metadata. fgmres_meta % n_iter = fgmres_meta % n_iter + 1 fgmres_meta % n_outer = fgmres_meta % n_outer + 1 fgmres_meta % res = [ fgmres_meta % res , abs ( beta ) ] write ( msg , '(A,I3,2(A,E11.4))' ) 'FGMRES(k) outer step   ' , fgmres_meta % n_outer , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) < tol ) then fgmres_meta % converged = . true . exit end if enddo end associate ! Returns the number of iterations if converged if ( fgmres_meta % converged ) then info = fgmres_meta % n_iter else info = - fgmres_meta % n_iter end if fgmres_meta % info = info if ( opts % if_print_metadata ) call fgmres_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( fgmres_sp_metadata ) meta = fgmres_meta class default call type_error ( 'meta' , 'fgmres_sp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter ( trans , 'fgmres%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure fgmres_rdp ! Options. integer :: kdim , maxiter real ( dp ) :: tol , rtol_ , atol_ logical :: trans type ( fgmres_dp_opts ) :: opts type ( fgmres_dp_metadata ) :: fgmres_meta ! Krylov subspace class ( abstract_vector_rdp ), allocatable :: V (:), Z (:) ! Hessenberg matrix. real ( dp ), allocatable :: H (:, :) ! Least-squares variables. real ( dp ), target , allocatable :: e (:) real ( dp ), pointer :: y (:, :) real ( dp ) :: beta ! Givens rotations. real ( dp ), allocatable :: c (:), s (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'fgmres_rdp' integer :: k , iostat class ( abstract_vector_rdp ), allocatable :: dx , wrk character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then select type ( options ) type is ( fgmres_dp_opts ) opts = options class default call type_error ( 'options' , 'fgmres_dp_opts' , 'IN' , this_module , this_procedure ) end select else opts = fgmres_dp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Initialize working variables. allocate ( wrk , source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call wrk % zero () allocate ( V ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( V ) allocate ( Z ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Z ) allocate ( H ( kdim + 1 , kdim ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( e ( kdim + 1 ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( c ( kdim ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( s ( kdim ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Initialize metadata and & reset matvec counter fgmres_meta = fgmres_dp_metadata () ; fgmres_meta % converged = . false . call A % reset_counter ( trans , 'fgmres%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) do while ((. not . fgmres_meta % converged ) . and . ( fgmres_meta % n_outer <= maxiter )) !> Initialize data H = 0.0_dp ; call zero_basis ( V ) if ( x % norm () /= 0.0_dp ) then if ( trans ) then call A % apply_rmatvec ( x , V ( 1 )) else call A % apply_matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () e = 0.0_dp ; beta = V ( 1 )% norm () ; e ( 1 ) = beta call V ( 1 )% scal ( one_rdp / beta ) c = 0.0_dp ; s = 0.0_dp if ( fgmres_meta % n_outer == 0 ) then allocate ( fgmres_meta % res ( 1 ), source = abs ( beta ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) write ( msg , '(2(A,E11.4))' ) 'FGMRES(k)   init step     : |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if gmres_iter : do k = 1 , kdim !> Preconditioner. call copy ( Z ( k ), V ( k )) ; if ( ifprecond ) call preconditioner % apply ( Z ( k ), k , beta , tol ) !----------------------------------------- !-----     Arnoldi factorization     ----- !----------------------------------------- !> Matrix vector product. if ( trans ) then call A % apply_rmatvec ( Z ( k ), V ( k + 1 )) else call A % apply_matvec ( Z ( k ), V ( k + 1 )) endif !> Orthogonalization + Hessenberg update. call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) !> Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) call V ( k + 1 )% scal ( one_rdp / H ( k + 1 , k )) !----------------------------------------- !-----     Least-Squares Problem     ----- !----------------------------------------- !> Apply Givens rotations to the Hessenberg matrix. call apply_givens_rotation ( H (: k + 1 , k ), c (: k ), s (: k )) !> Update the right-hand side vector accordingly. e ( k + 1 ) = - s ( k ) * e ( k ) ; e ( k ) = c ( k ) * e ( k ) !> Least-squares residual. beta = abs ( e ( k + 1 )) ! Save metadata. fgmres_meta % n_iter = fgmres_meta % n_iter + 1 fgmres_meta % n_inner = fgmres_meta % n_inner + 1 fgmres_meta % res = [ fgmres_meta % res , abs ( beta ) ] ! Check convergence. write ( msg , '(A,I3,2(A,E11.4))' ) 'FGMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) if ( abs ( beta ) < tol ) fgmres_meta % converged = . true . if ( fgmres_meta % converged ) exit gmres_iter enddo gmres_iter ! Update solution. k = min ( k , kdim ) y ( 1 : k , 1 : 1 ) => e (: k ) ; call trtrs ( \"u\" , \"n\" , \"n\" , k , 1 , H (: k , : k ), k , y , k , info ) call linear_combination ( dx , Z (: k ), e (: k )) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % apply_rmatvec ( x , v ( 1 )) else call A % apply_matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; if ( abs ( beta ) > 0.0_dp ) call v ( 1 )% scal ( one_rdp / beta ) ! Save metadata. fgmres_meta % n_iter = fgmres_meta % n_iter + 1 fgmres_meta % n_outer = fgmres_meta % n_outer + 1 fgmres_meta % res = [ fgmres_meta % res , abs ( beta ) ] write ( msg , '(A,I3,2(A,E11.4))' ) 'FGMRES(k) outer step   ' , fgmres_meta % n_outer , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) < tol ) then fgmres_meta % converged = . true . exit end if enddo end associate ! Returns the number of iterations if converged if ( fgmres_meta % converged ) then info = fgmres_meta % n_iter else info = - fgmres_meta % n_iter end if fgmres_meta % info = info if ( opts % if_print_metadata ) call fgmres_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( fgmres_dp_metadata ) meta = fgmres_meta class default call type_error ( 'meta' , 'fgmres_dp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter ( trans , 'fgmres%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure fgmres_csp ! Options. integer :: kdim , maxiter real ( sp ) :: tol , rtol_ , atol_ logical :: trans type ( fgmres_sp_opts ) :: opts type ( fgmres_sp_metadata ) :: fgmres_meta ! Krylov subspace class ( abstract_vector_csp ), allocatable :: V (:), Z (:) ! Hessenberg matrix. complex ( sp ), allocatable :: H (:, :) ! Least-squares variables. complex ( sp ), target , allocatable :: e (:) complex ( sp ), pointer :: y (:, :) real ( sp ) :: beta ! Givens rotations. complex ( sp ), allocatable :: c (:), s (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'fgmres_csp' integer :: k , iostat class ( abstract_vector_csp ), allocatable :: dx , wrk character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then select type ( options ) type is ( fgmres_sp_opts ) opts = options class default call type_error ( 'options' , 'fgmres_sp_opts' , 'IN' , this_module , this_procedure ) end select else opts = fgmres_sp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Initialize working variables. allocate ( wrk , source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call wrk % zero () allocate ( V ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( V ) allocate ( Z ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Z ) allocate ( H ( kdim + 1 , kdim ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( e ( kdim + 1 ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( c ( kdim ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( s ( kdim ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Initialize metadata and & reset matvec counter fgmres_meta = fgmres_sp_metadata () ; fgmres_meta % converged = . false . call A % reset_counter ( trans , 'fgmres%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) do while ((. not . fgmres_meta % converged ) . and . ( fgmres_meta % n_outer <= maxiter )) !> Initialize data H = 0.0_sp ; call zero_basis ( V ) if ( x % norm () /= 0.0_sp ) then if ( trans ) then call A % apply_rmatvec ( x , V ( 1 )) else call A % apply_matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () e = 0.0_sp ; beta = V ( 1 )% norm () ; e ( 1 ) = beta call V ( 1 )% scal ( one_csp / beta ) c = 0.0_sp ; s = 0.0_sp if ( fgmres_meta % n_outer == 0 ) then allocate ( fgmres_meta % res ( 1 ), source = abs ( beta ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) write ( msg , '(2(A,E11.4))' ) 'FGMRES(k)   init step     : |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if gmres_iter : do k = 1 , kdim !> Preconditioner. call copy ( Z ( k ), V ( k )) ; if ( ifprecond ) call preconditioner % apply ( Z ( k ), k , beta , tol ) !----------------------------------------- !-----     Arnoldi factorization     ----- !----------------------------------------- !> Matrix vector product. if ( trans ) then call A % apply_rmatvec ( Z ( k ), V ( k + 1 )) else call A % apply_matvec ( Z ( k ), V ( k + 1 )) endif !> Orthogonalization + Hessenberg update. call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) !> Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) call V ( k + 1 )% scal ( one_csp / H ( k + 1 , k )) !----------------------------------------- !-----     Least-Squares Problem     ----- !----------------------------------------- !> Apply Givens rotations to the Hessenberg matrix. call apply_givens_rotation ( H (: k + 1 , k ), c (: k ), s (: k )) !> Update the right-hand side vector accordingly. e ( k + 1 ) = - s ( k ) * e ( k ) ; e ( k ) = c ( k ) * e ( k ) !> Least-squares residual. beta = abs ( e ( k + 1 )) ! Save metadata. fgmres_meta % n_iter = fgmres_meta % n_iter + 1 fgmres_meta % n_inner = fgmres_meta % n_inner + 1 fgmres_meta % res = [ fgmres_meta % res , abs ( beta ) ] ! Check convergence. write ( msg , '(A,I3,2(A,E11.4))' ) 'FGMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) if ( abs ( beta ) < tol ) fgmres_meta % converged = . true . if ( fgmres_meta % converged ) exit gmres_iter enddo gmres_iter ! Update solution. k = min ( k , kdim ) y ( 1 : k , 1 : 1 ) => e (: k ) ; call trtrs ( \"u\" , \"n\" , \"n\" , k , 1 , H (: k , : k ), k , y , k , info ) call linear_combination ( dx , Z (: k ), e (: k )) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % apply_rmatvec ( x , v ( 1 )) else call A % apply_matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; if ( abs ( beta ) > 0.0_sp ) call v ( 1 )% scal ( one_csp / beta ) ! Save metadata. fgmres_meta % n_iter = fgmres_meta % n_iter + 1 fgmres_meta % n_outer = fgmres_meta % n_outer + 1 fgmres_meta % res = [ fgmres_meta % res , abs ( beta ) ] write ( msg , '(A,I3,2(A,E11.4))' ) 'FGMRES(k) outer step   ' , fgmres_meta % n_outer , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) < tol ) then fgmres_meta % converged = . true . exit end if enddo end associate ! Returns the number of iterations if converged if ( fgmres_meta % converged ) then info = fgmres_meta % n_iter else info = - fgmres_meta % n_iter end if fgmres_meta % info = info if ( opts % if_print_metadata ) call fgmres_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( fgmres_sp_metadata ) meta = fgmres_meta class default call type_error ( 'meta' , 'fgmres_sp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter ( trans , 'fgmres%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure fgmres_cdp ! Options. integer :: kdim , maxiter real ( dp ) :: tol , rtol_ , atol_ logical :: trans type ( fgmres_dp_opts ) :: opts type ( fgmres_dp_metadata ) :: fgmres_meta ! Krylov subspace class ( abstract_vector_cdp ), allocatable :: V (:), Z (:) ! Hessenberg matrix. complex ( dp ), allocatable :: H (:, :) ! Least-squares variables. complex ( dp ), target , allocatable :: e (:) complex ( dp ), pointer :: y (:, :) real ( dp ) :: beta ! Givens rotations. complex ( dp ), allocatable :: c (:), s (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'fgmres_cdp' integer :: k , iostat class ( abstract_vector_cdp ), allocatable :: dx , wrk character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then select type ( options ) type is ( fgmres_dp_opts ) opts = options class default call type_error ( 'options' , 'fgmres_dp_opts' , 'IN' , this_module , this_procedure ) end select else opts = fgmres_dp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Initialize working variables. allocate ( wrk , source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call wrk % zero () allocate ( V ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( V ) allocate ( Z ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Z ) allocate ( H ( kdim + 1 , kdim ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( e ( kdim + 1 ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( c ( kdim ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( s ( kdim ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Initialize metadata and & reset matvec counter fgmres_meta = fgmres_dp_metadata () ; fgmres_meta % converged = . false . call A % reset_counter ( trans , 'fgmres%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) do while ((. not . fgmres_meta % converged ) . and . ( fgmres_meta % n_outer <= maxiter )) !> Initialize data H = 0.0_dp ; call zero_basis ( V ) if ( x % norm () /= 0.0_dp ) then if ( trans ) then call A % apply_rmatvec ( x , V ( 1 )) else call A % apply_matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () e = 0.0_dp ; beta = V ( 1 )% norm () ; e ( 1 ) = beta call V ( 1 )% scal ( one_cdp / beta ) c = 0.0_dp ; s = 0.0_dp if ( fgmres_meta % n_outer == 0 ) then allocate ( fgmres_meta % res ( 1 ), source = abs ( beta ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) write ( msg , '(2(A,E11.4))' ) 'FGMRES(k)   init step     : |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if gmres_iter : do k = 1 , kdim !> Preconditioner. call copy ( Z ( k ), V ( k )) ; if ( ifprecond ) call preconditioner % apply ( Z ( k ), k , beta , tol ) !----------------------------------------- !-----     Arnoldi factorization     ----- !----------------------------------------- !> Matrix vector product. if ( trans ) then call A % apply_rmatvec ( Z ( k ), V ( k + 1 )) else call A % apply_matvec ( Z ( k ), V ( k + 1 )) endif !> Orthogonalization + Hessenberg update. call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) !> Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) call V ( k + 1 )% scal ( one_cdp / H ( k + 1 , k )) !----------------------------------------- !-----     Least-Squares Problem     ----- !----------------------------------------- !> Apply Givens rotations to the Hessenberg matrix. call apply_givens_rotation ( H (: k + 1 , k ), c (: k ), s (: k )) !> Update the right-hand side vector accordingly. e ( k + 1 ) = - s ( k ) * e ( k ) ; e ( k ) = c ( k ) * e ( k ) !> Least-squares residual. beta = abs ( e ( k + 1 )) ! Save metadata. fgmres_meta % n_iter = fgmres_meta % n_iter + 1 fgmres_meta % n_inner = fgmres_meta % n_inner + 1 fgmres_meta % res = [ fgmres_meta % res , abs ( beta ) ] ! Check convergence. write ( msg , '(A,I3,2(A,E11.4))' ) 'FGMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) if ( abs ( beta ) < tol ) fgmres_meta % converged = . true . if ( fgmres_meta % converged ) exit gmres_iter enddo gmres_iter ! Update solution. k = min ( k , kdim ) y ( 1 : k , 1 : 1 ) => e (: k ) ; call trtrs ( \"u\" , \"n\" , \"n\" , k , 1 , H (: k , : k ), k , y , k , info ) call linear_combination ( dx , Z (: k ), e (: k )) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % apply_rmatvec ( x , v ( 1 )) else call A % apply_matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; if ( abs ( beta ) > 0.0_dp ) call v ( 1 )% scal ( one_cdp / beta ) ! Save metadata. fgmres_meta % n_iter = fgmres_meta % n_iter + 1 fgmres_meta % n_outer = fgmres_meta % n_outer + 1 fgmres_meta % res = [ fgmres_meta % res , abs ( beta ) ] write ( msg , '(A,I3,2(A,E11.4))' ) 'FGMRES(k) outer step   ' , fgmres_meta % n_outer , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) < tol ) then fgmres_meta % converged = . true . exit end if enddo end associate ! Returns the number of iterations if converged if ( fgmres_meta % converged ) then info = fgmres_meta % n_iter else info = - fgmres_meta % n_iter end if fgmres_meta % info = info if ( opts % if_print_metadata ) call fgmres_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( fgmres_dp_metadata ) meta = fgmres_meta class default call type_error ( 'meta' , 'fgmres_dp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter ( trans , 'fgmres%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure dense_fgmres_rsp type ( dense_vector_rsp ) :: b_ , x_ type ( dense_linop_rsp ) :: A_ ! Wrap data into convenience types. A_ = dense_linop ( A ) b_ = dense_vector ( b ) x_ = dense_vector ( x ) ! Call abstract gmres. call fgmres ( A_ , b_ , x_ , info , rtol , atol , preconditioner , options , transpose , meta ) ! Extract solution. x = x_ % data end procedure module procedure dense_fgmres_rdp type ( dense_vector_rdp ) :: b_ , x_ type ( dense_linop_rdp ) :: A_ ! Wrap data into convenience types. A_ = dense_linop ( A ) b_ = dense_vector ( b ) x_ = dense_vector ( x ) ! Call abstract gmres. call fgmres ( A_ , b_ , x_ , info , rtol , atol , preconditioner , options , transpose , meta ) ! Extract solution. x = x_ % data end procedure module procedure dense_fgmres_csp type ( dense_vector_csp ) :: b_ , x_ type ( dense_linop_csp ) :: A_ ! Wrap data into convenience types. A_ = dense_linop ( A ) b_ = dense_vector ( b ) x_ = dense_vector ( x ) ! Call abstract gmres. call fgmres ( A_ , b_ , x_ , info , rtol , atol , preconditioner , options , transpose , meta ) ! Extract solution. x = x_ % data end procedure module procedure dense_fgmres_cdp type ( dense_vector_cdp ) :: b_ , x_ type ( dense_linop_cdp ) :: A_ ! Wrap data into convenience types. A_ = dense_linop ( A ) b_ = dense_vector ( b ) x_ = dense_vector ( x ) ! Call abstract gmres. call fgmres ( A_ , b_ , x_ , info , rtol , atol , preconditioner , options , transpose , meta ) ! Extract solution. x = x_ % data end procedure end submodule","tags":"","url":"sourcefile/fgmres.f90.html"},{"title":"Constants.f90 – LightKrylov","text":"Source Code module LightKrylov_Constants !! This module defines a list of simple constants used throughout `LightKrylov`. !! It also provides some utility functions related to let `LightKrylov` be aware !! of any MPI-related information (e.g. rank of the current MPI process, dimension !! of the MPI communicator, etc). implicit none ( type , external ) private integer , private :: nid = 0 !! Rank of the current process (local MPI variable). integer , private :: comm_size = 1 !! Dimension of the MPI communicator. integer , private :: nio = 0 !! Rank of the processor for logging information. integer , parameter , public :: sp = selected_real_kind ( 6 , 37 ) !! Single precision data type. real ( sp ), parameter , public :: atol_sp = 1 0.0_sp ** ( - precision ( 1.0_sp )) !! Absolute tolerance for single precision computations. real ( sp ), parameter , public :: rtol_sp = sqrt ( atol_sp ) !! Relative tolerance for single precision computations. real ( sp ), parameter , public :: one_rsp = 1.0_sp !! Real-valued single precision one. real ( sp ), parameter , public :: zero_rsp = 0.0_sp !! Real-valued single precision zero. complex ( sp ), parameter , public :: one_csp = cmplx ( 1.0_sp , 0.0_sp , kind = sp ) !! Complex-valued single precision one. complex ( sp ), parameter , public :: one_im_csp = cmplx ( 0.0_sp , 1.0_sp , kind = sp ) !! Complex-valued single precision imaginary unit. complex ( sp ), parameter , public :: zero_csp = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) !! Complex-value single precision zero. integer , parameter , public :: dp = selected_real_kind ( 15 , 307 ) !! Double precision data type. real ( dp ), parameter , public :: atol_dp = 1 0.0_dp ** ( - precision ( 1.0_dp )) !! Absolute tolerance for double precision computations. real ( dp ), parameter , public :: rtol_dp = sqrt ( atol_dp ) !! Relative tolerance for double precision computations. real ( dp ), parameter , public :: one_rdp = 1.0_dp !! Real-valued double precision one. real ( dp ), parameter , public :: zero_rdp = 0.0_dp !! Real-valued double precision zero. complex ( dp ), parameter , public :: one_cdp = cmplx ( 1.0_dp , 0.0_dp , kind = dp ) !! Complex-valued double precision one. complex ( dp ), parameter , public :: one_im_cdp = cmplx ( 0.0_dp , 1.0_dp , kind = dp ) !! Complex-valued double precision imaginary unit. complex ( dp ), parameter , public :: zero_cdp = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! Complex-valued double precision zero. ! Getter/setter routines public :: set_comm_size public :: set_rank public :: set_io_rank public :: get_rank public :: get_comm_size public :: io_rank contains subroutine set_rank ( rank ) !! Utility function to set the rank of an MPI process. integer , intent ( in ) :: rank !! Desired rank identification. nid = rank end subroutine set_rank subroutine set_comm_size ( c_size ) !! Utility function to inform `LightKrylov` of the MPI-communicator's dimension. integer , intent ( in ) :: c_size !! Dimension of the MPI communicator. comm_size = c_size end subroutine set_comm_size subroutine set_io_rank ( rk ) !! Utility function to set the rank of the process doing I/O. integer , intent ( in ) :: rk !! Desired rank for the IO process. if ( rk > comm_size . or . rk < 0 ) then if ( io_rank ()) print * , 'Invalid I/O rank specified!' , rk else nio = rk if ( io_rank ()) print * , 'I/O rank --> rank ' , nio end if end subroutine set_io_rank pure integer function get_rank () result ( rank ) !! Utility function to get the rank of the current MPI process. rank = nid end function get_rank pure integer function get_comm_size () result ( c_size ) !! Utility function to get the dimension of the communicator known to `LightKrylov`. c_size = comm_size end function get_comm_size pure logical function io_rank () result ( is_io ) !! Utility function to determine whether the current MPI process can do I/O. is_io = . false . if ( nid == nio ) is_io = . true . end function io_rank end module LightKrylov_Constants","tags":"","url":"sourcefile/constants.f90.html"},{"title":"LightKrylov.f90 – LightKrylov","text":"Source Code module LightKrylov ! --> Definitions of various constants. use LightKrylov_Constants ! --> Set of utility functions. use LightKrylov_Utils ! --> Definitions of the abstract vector types. use LightKrylov_AbstractVectors ! --> Definitions of the abstract linear operators. use LightKrylov_AbstractLinops ! --> Definitions of the abstract dynamical systems. use LightKrylov_AbstractSystems ! --> Standard Krylov techniques. use LightKrylov_BaseKrylov ! --> Iterative solvers. use LightKrylov_NewtonKrylov ! --> Newton-Krylov fixed-point iteration. use LightKrylov_IterativeSolvers ! --> Expmlib use LightKrylov_Expmlib ! --> Timing utilities use LightKrylov_Timer_Utils use LightKrylov_Timing , only : lk_timer => global_lightkrylov_timer ! --> TestTypes implicit none ( type , external ) private ! LightKrylov exports. public :: greetings ! Constants exports. public :: sp , atol_sp , rtol_sp public :: dp , atol_dp , rtol_dp ! Utils exports. public :: gmres_sp_opts public :: fgmres_sp_opts public :: cg_sp_opts public :: newton_sp_opts public :: gmres_dp_opts public :: fgmres_dp_opts public :: cg_dp_opts public :: newton_dp_opts public :: gmres_sp_metadata public :: fgmres_sp_metadata public :: cg_sp_metadata public :: newton_sp_metadata public :: gmres_dp_metadata public :: fgmres_dp_metadata public :: cg_dp_metadata public :: newton_dp_metadata ! AbstractVectors exports. public :: abstract_vector public :: abstract_vector_rsp public :: dense_vector_rsp public :: abstract_vector_rdp public :: dense_vector_rdp public :: abstract_vector_csp public :: dense_vector_csp public :: abstract_vector_cdp public :: dense_vector_cdp public :: dense_vector public :: innerprod , Gram public :: linear_combination public :: axpby_basis public :: zero_basis public :: copy public :: rand_basis ! AbstractLinops exports. public :: abstract_linop public :: abstract_linop_rsp public :: abstract_exptA_linop_rsp public :: adjoint_linop_rsp public :: Id_rsp public :: scaled_linop_rsp public :: axpby_linop_rsp public :: dense_linop_rsp public :: abstract_sym_linop_rsp public :: abstract_linop_rdp public :: abstract_exptA_linop_rdp public :: adjoint_linop_rdp public :: Id_rdp public :: scaled_linop_rdp public :: axpby_linop_rdp public :: dense_linop_rdp public :: abstract_sym_linop_rdp public :: abstract_linop_csp public :: abstract_exptA_linop_csp public :: adjoint_linop_csp public :: Id_csp public :: scaled_linop_csp public :: axpby_linop_csp public :: dense_linop_csp public :: abstract_hermitian_linop_csp public :: abstract_linop_cdp public :: abstract_exptA_linop_cdp public :: adjoint_linop_cdp public :: Id_cdp public :: scaled_linop_cdp public :: axpby_linop_cdp public :: dense_linop_cdp public :: abstract_hermitian_linop_cdp public :: adjoint ! AbstractSystems exports. public :: abstract_system_rsp public :: abstract_jacobian_linop_rsp public :: abstract_system_rdp public :: abstract_jacobian_linop_rdp public :: abstract_system_csp public :: abstract_jacobian_linop_csp public :: abstract_system_cdp public :: abstract_jacobian_linop_cdp ! BaseKrylov exports. public :: qr public :: permcols , invperm public :: arnoldi public :: initialize_krylov_subspace public :: initialize_random_orthonormal_basis public :: orthogonalize_against_basis public :: orthonormalize_basis public :: bidiagonalization public :: lanczos public :: krylov_schur ! IterativeSolvers exports. public :: abstract_precond_rsp public :: abstract_precond_rdp public :: abstract_precond_csp public :: abstract_precond_cdp public :: abstract_linear_solver_rsp public :: abstract_linear_solver_rdp public :: abstract_linear_solver_csp public :: abstract_linear_solver_cdp public :: eigs , eighs , save_eigenspectrum public :: svds public :: gmres public :: gmres_rsp public :: gmres_rdp public :: gmres_csp public :: gmres_cdp public :: fgmres public :: fgmres_rsp public :: fgmres_rdp public :: fgmres_csp public :: fgmres_cdp public :: cg ! Newton-Krylov exports. public :: newton public :: constant_tol_sp , dynamic_tol_sp public :: constant_tol_dp , dynamic_tol_dp ! ExpmLib exports. public :: abstract_exptA_rsp public :: abstract_exptA_rdp public :: abstract_exptA_csp public :: abstract_exptA_cdp public :: kexpm public :: krylov_exptA ! Timer exports public :: lightkrylov_timer public :: abstract_watch public :: lk_timer contains subroutine greetings () write ( * , * ) write ( * , * ) write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) write ( * , * ) \"      _     _       _     _   _  __           _            \" write ( * , * ) \"     | |   (_) __ _| |__ | |_| |/ /_ __ _   _| | _____   __\" write ( * , * ) \"     | |   | |/ _` | '_ \\| __| ' /| '__| | | | |/ _ \\ \\ / /\" write ( * , * ) \"     | |___| | (_| | | | | |_| . \\| |  | |_| | | (_) \\ V / \" write ( * , * ) \"     |_____|_|\\__, |_| |_|\\__|_|\\_\\_|   \\__, |_|\\___/ \\_/  \" write ( * , * ) \"              |___/                     |___/              \" write ( * , * ) write ( * , * ) \"Developed by: Jean-Christophe Loiseau\" write ( * , * ) \"              J. Simon Kern\" write ( * , * ) \"              Arts & Métiers Institute of Technology, 2023.\" write ( * , * ) \"              jean-christophe.loiseau@ensam.eu\" write ( * , * ) write ( * , * ) \"Version -- beta 0.1.0\" write ( * , * ) \"License -- BSD 3-Clause\" write ( * , * ) write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) write ( * , * ) end subroutine greetings end module LightKrylov","tags":"","url":"sourcefile/lightkrylov.f90.html"},{"title":"BaseKrylov.f90 – LightKrylov","text":"Source Code module LightKrylov_BaseKrylov !!  This module provides a collection of Krylov-based factorizations forming the !!  computational core of `LightKrylov`. It also provides a set of utility functions !!  to operate on arrays of `abstract_vector`. The most important ones are: !! !!  - `arnoldi(A, X, H, info)`: Arnoldi factorization for general square matrices. !!  - `lanczos(A, X, H, info)`: Lanczos factorization for general symmetric/hermitian matrices. !!  - `bidiagonalization(A, U, V, B)`: Lanczos bidiagonalization for arbitrary matrices. !!  - `qr(X, R, perm, info)`: QR factorization (with and without column pivoting) of an array of `abstract_vector`. !-------------------------------------------- !-----     Standard Fortran Library     ----- !-------------------------------------------- use stdlib_optval , only : optval use stdlib_linalg , only : eye , schur , norm , mnorm !------------------------------- !-----     LightKrylov     ----- !------------------------------- use LightKrylov_Constants use LightKrylov_Logger , only : log_information , stop_error , check_info use LightKrylov_Timing , only : timer => global_lightkrylov_timer , time_lightkrylov use LightKrylov_AbstractVectors use LightKrylov_AbstractLinops use LightKrylov_Utils implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_BKrylov' character ( len =* ), parameter :: this_module_long = 'LightKrylov_BaseKrylov' !----- Krylov processes ------ public :: arnoldi public :: bidiagonalization public :: lanczos !----- Utility functions ------ public :: qr public :: double_gram_schmidt_step public :: is_orthonormal public :: orthonormalize_basis public :: orthogonalize_against_basis public :: permcols , invperm public :: initialize_krylov_subspace public :: initialize_random_orthonormal_basis public :: krylov_schur !------------------------------------ !-----                          ----- !-----     KRYLOV PROCESSES     ----- !-----                          ----- !------------------------------------ interface arnoldi !!  ### Description !! !!  Given a square linear operator  A , find matrices  X  and  H  such that !! !!   !!      AX_k = X_k H_k + h_{k+1, k} x_{k+1} e_k&#94;T, !!   !! !!  where  X  is an orthogonal basis and  H  is upper Hessenberg. !! !!  **Algorithmic Features** !! !!  - The operator  A  only needs to be accessed through matrix-vector products. !!  - Constructs an orthonormal Krylov basis  X  via the Gram-Schmidt process. !!  - Constructs an upper Hessenberg matrix  H  whose eigenvalues approximates those of  A . !!  - Checks for convergence and invariant subspaces. !   - Block version available (experimental). !! !!  **References** !! !!  - Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003. !!    see Chapter 6.3: Arnoldi's method. !! !!  ### Syntax !! !!  ```fortran !!      call arnoldi(A, X, H, info [, kstart] [, kend] [, tol] [, transpose] [, blksize]) !!  ``` !! !!  ### Arguments !! !!  - `A` : Linear operator derived from one the base types provided by the `AbstractLinops` !!          module. The operator needs to be square, i.e. the dimension of its domain and !!          co-domain is the same. It is an `intent(inout)` argument. !! !!  - `X` : Array of types derived from one the base types provided by the `AbstractVectors` !!          module. It needs to be consistent with the type of `A`. On exit, it contains the !!          the computed Krylov vectors. The first entry `X(1)` is the starting vector for !!          the Arnoldi factorization. Additionally, the maximum number of Arnoldi steps !!          is equal to `size(X) - 1`. It is an `intent(inout)` argument. !! !!  -`H` : `real` or `complex` rank-2 array. On exit, it contains the  (k+1) \\times k !!          upper Hessenberg matrix computed from the Arnoldi factorization. It is an !!          `intent(inout)` argument. !! !!  -`info` :   `integer` variable. It is the `LightKrylov` information flag. On exit, if !!              `info` > 0, the Arnoldi factorization experienced a lucky breakdown. !!              The array of Krylov vectors `X` spans an A-invariant subpsace of !!              dimension `info`. !! !!  - `kstart` (*optional*) :   `integer` value determining the index of the first Arnoldi !!                              step to be computed. By default, `kstart = 1`. It is an !!                              optional `intent(in)` argument. !! !!  - `kend` (*optional*)   :   `integer` value determining the index of the last Arnoldi step !!                              to be computed. It is an optional `intent(in)` argument. !!                              By default, `kend = size(X) - 1`. !! !!  - `tol` (*optional*)    :   Numerical tolerance below which a subspace is considered !!                              to be  A -invariant. It is an optional `intent(in)` argument. !!                              By default `tol = atol_sp` or `tol = atol_rp` depending on the !!                              kind of `A`. !! !!  - `transpose` (*optional*)  :   `logical` flag determining whether the Arnoldi factorization !!                                  is applied to  A  or  A&#94;H . It is an optional `intent(in)` !!                                  argument. Default `transpose = .false.` !! !!  - `blksize` (*optional*)    :   `integer` value determining the dimension of a block for the !!                                  block Arnoldi factorization. It is an optional `intent(in)` !!                                  argument. Default is `blksize=1`. module subroutine arnoldi_rsp ( A , X , H , info , kstart , kend , tol , transpose , blksize ) implicit none ( type , external ) class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be factorized. class ( abstract_vector_rsp ), intent ( inout ) :: X (:) !! Orthogonal basis for the generated Krylov subspace. real ( sp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Arnoldi factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Arnoldi factorization (default `size(X)-1`) logical , optional , intent ( in ) :: transpose !! Whether  \\mathbf{A}  is being transposed or not (default `.false.`) real ( sp ), optional , intent ( in ) :: tol !! Tolerance to determine whether an invariant subspace has been computed or not. integer , optional , intent ( in ) :: blksize !! Block size for block Arnoldi (default 1). end subroutine arnoldi_rsp module subroutine arnoldi_rdp ( A , X , H , info , kstart , kend , tol , transpose , blksize ) implicit none ( type , external ) class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be factorized. class ( abstract_vector_rdp ), intent ( inout ) :: X (:) !! Orthogonal basis for the generated Krylov subspace. real ( dp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Arnoldi factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Arnoldi factorization (default `size(X)-1`) logical , optional , intent ( in ) :: transpose !! Whether  \\mathbf{A}  is being transposed or not (default `.false.`) real ( dp ), optional , intent ( in ) :: tol !! Tolerance to determine whether an invariant subspace has been computed or not. integer , optional , intent ( in ) :: blksize !! Block size for block Arnoldi (default 1). end subroutine arnoldi_rdp module subroutine arnoldi_csp ( A , X , H , info , kstart , kend , tol , transpose , blksize ) implicit none ( type , external ) class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be factorized. class ( abstract_vector_csp ), intent ( inout ) :: X (:) !! Orthogonal basis for the generated Krylov subspace. complex ( sp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Arnoldi factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Arnoldi factorization (default `size(X)-1`) logical , optional , intent ( in ) :: transpose !! Whether  \\mathbf{A}  is being transposed or not (default `.false.`) real ( sp ), optional , intent ( in ) :: tol !! Tolerance to determine whether an invariant subspace has been computed or not. integer , optional , intent ( in ) :: blksize !! Block size for block Arnoldi (default 1). end subroutine arnoldi_csp module subroutine arnoldi_cdp ( A , X , H , info , kstart , kend , tol , transpose , blksize ) implicit none ( type , external ) class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be factorized. class ( abstract_vector_cdp ), intent ( inout ) :: X (:) !! Orthogonal basis for the generated Krylov subspace. complex ( dp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Arnoldi factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Arnoldi factorization (default `size(X)-1`) logical , optional , intent ( in ) :: transpose !! Whether  \\mathbf{A}  is being transposed or not (default `.false.`) real ( dp ), optional , intent ( in ) :: tol !! Tolerance to determine whether an invariant subspace has been computed or not. integer , optional , intent ( in ) :: blksize !! Block size for block Arnoldi (default 1). end subroutine arnoldi_cdp end interface interface lanczos !!  ### Description !! !!  Given a symmetric or Hermitian linear operator  A , find matrices  X  and !!   T  such that !! !!   !!      AX_k = X_k T_k + t_{k+1, k} x_{k+1} e_k&#94;T, !!   !! !!  where  X  is an orthogonal basis and  T  is symmetric tridiagonal. !! !!  **Algorithmic Features** !! !!  - The operator  A  only needs to be accessed through matrix-vector products. !!  - Constructs an orthonormal Krylov basis  X  via the Lanczos process with full !!    reorthogonalization. !!  - Constructs a symmetric tridiagonal matrix  T  whose eigenvalues approximates those of  A . !!  - Checks for convergence and invariant subspaces. !! !!  **References** !! !!  - Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003. !!    see Chapter 6.6: The symmetric Lanczos algorithm. !! !!  ### Syntax !! !!  ```fortran !!      call lanczos(A, X, T, info [, kstart] [, kend] [, tol]) !!  ``` !! !!  ### Arguments !! !!  - `A`   :   Symmetric or Hermitian linear operator derived from one the base types !!              provided by the `AbstractLinops` module. It is an `intent(inout)` argument. !! !!  - `X`   :   Array of types derived from one the base types provided by the `AbstractVectors` !!              module. It needs to be consistent with the type of `A`. On exit, it contains the !!              the computed Krylov vectors. The first entry `X(1)` is the starting vector for !!              the Lanczos factorization. Additionally, the maximum number of Lanczos steps !!              is equal to `size(X) - 1`. It is an `intent(inout)` argument. !! !!  - `T`   :   `real` or `complex` rank-2 array. On exit, it contains the  (k+1) \\times k !!              symmetric tridiagonal matrix computed from the Arnoldi factorization. It is an !!              `intent(inout)` argument. !! !!  - `info`    :   `integer` variable. It is the `LightKrylov` information flag. On exit, if !!                  `info` > 0, the Lanczos factorization experienced a lucky breakdown. !!                  The array of Krylov vectors `X` spans an A-invariant subpsace of !!                  dimension `info`. !! !!  - `kstart` (*optional*) :   `integer` value determining the index of the first Lanczos !!                              step to be computed. It is an optional `intent(in)` argument. !!                              By default, `kstart = 1`. !! !!  - `kend` (*optional*)   :   `integer` value determining the index of the last Lanczos step !!                              to be computed. It is an optional `intent(in)` argument. !!                              By default, `kend = size(X) - 1`. !! !!  - `tol` (*optional*)    :   Numerical tolerance below which a subspace is considered !!                              to be  A -invariant. It is an optional `intent(in)` argument. !!                              By default `tol = atol_sp` or `tol = atol_rp` depending on the !!                              kind of `A`. module subroutine lanczos_tridiagonalization_rsp ( A , X , T , info , kstart , kend , tol ) implicit none ( type , external ) class ( abstract_sym_linop_rsp ), intent ( inout ) :: A class ( abstract_vector_rsp ), intent ( inout ) :: X (:) real ( sp ), intent ( inout ) :: T (:, :) integer , intent ( out ) :: info integer , optional , intent ( in ) :: kstart integer , optional , intent ( in ) :: kend real ( sp ), optional , intent ( in ) :: tol end subroutine lanczos_tridiagonalization_rsp module subroutine lanczos_tridiagonalization_rdp ( A , X , T , info , kstart , kend , tol ) implicit none ( type , external ) class ( abstract_sym_linop_rdp ), intent ( inout ) :: A class ( abstract_vector_rdp ), intent ( inout ) :: X (:) real ( dp ), intent ( inout ) :: T (:, :) integer , intent ( out ) :: info integer , optional , intent ( in ) :: kstart integer , optional , intent ( in ) :: kend real ( dp ), optional , intent ( in ) :: tol end subroutine lanczos_tridiagonalization_rdp module subroutine lanczos_tridiagonalization_csp ( A , X , T , info , kstart , kend , tol ) implicit none ( type , external ) class ( abstract_hermitian_linop_csp ), intent ( inout ) :: A class ( abstract_vector_csp ), intent ( inout ) :: X (:) complex ( sp ), intent ( inout ) :: T (:, :) integer , intent ( out ) :: info integer , optional , intent ( in ) :: kstart integer , optional , intent ( in ) :: kend real ( sp ), optional , intent ( in ) :: tol end subroutine lanczos_tridiagonalization_csp module subroutine lanczos_tridiagonalization_cdp ( A , X , T , info , kstart , kend , tol ) implicit none ( type , external ) class ( abstract_hermitian_linop_cdp ), intent ( inout ) :: A class ( abstract_vector_cdp ), intent ( inout ) :: X (:) complex ( dp ), intent ( inout ) :: T (:, :) integer , intent ( out ) :: info integer , optional , intent ( in ) :: kstart integer , optional , intent ( in ) :: kend real ( dp ), optional , intent ( in ) :: tol end subroutine lanczos_tridiagonalization_cdp end interface interface bidiagonalization !!  ### Description !! !!  Given a general linear operator  A , find matrices  U ,  V  and !!   B  such that !! !!   !!      \\begin{aligned} !!          AV_k & = U_k T_k + t_{k+1, k} v_{k+1} e_k&#94;T, \\\\ !!          A&#94;H U_k & = V_k T_k&#94;T + t_{k+1, k} u_{k+1} e_k&#94;T !!      \\end{aligned} !!   !! !!  where  U  and  V  are orthogonal bases for the column span and row span !!  of  A , respectively, and  B  is a bidiagonal matrix. !! !!  **Algorithmic Features** !! !!  - The operator  A  only needs to be accessed through matrix-vector products. !!  - Constructs an orthonormal Krylov basis  U  for the column span of  A . !!  - Constructs an orthonormal Krylov basis  V  for the row span of  A . !!  - Constructs a bidiagonal matrix  B  whose singular values approximates those of  A . !!  - Checks for convergence and invariant subspaces. !! !!  **References** !! !!  - R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\" !!    Technical Report, 1998. [(PDF)](http://sun.stanford.edu/~rmunk/PROPACK/paper.pdf) !! !!  ### Syntax !! !!  ```fortran !!      call bidiagonalization(A, U, V, B, info [, kstart] [, kend] [, tol]) !!  ``` !! !!  ### Arguments !! !!  - `A`   :   Linear operator derived from one the base types provided by the !!              `AbstractLinops` module. It is an `intent(inout)` argument. !! !!  - `U`   :   Array of types derived from one the base types provided by the `AbstractVectors` !!              module. It needs to be consistent with the type of `A`. On exit, it contains the !!              the computed Krylov vectors for the column span of `A`. The first entry `U(1)` !!              is the starting vector for the Lanczos factorization. Additionally, the !!              maximum number of Lanczos steps is equal to `size(X) - 1`. !!              It is an `intent(inout)` argument. !! !!  - `V`   :   Array of types derived from one the base types provided by the `AbstractVectors` !!              module. It needs to be consistent with the type of `A`. On exit, it contains the !!              the computed Krylov vectors for the row span of `A`. It is an `intent(inout)` !!              argument. !! !!  - `B`   :   `real` or `complex` rank-2 array. On exit, it contains the  (k+1) \\times k !!              bidiagonal matrix computed from the Lanczos factorization. It is an `intent(inout)` !!              argument. !! !!  - `info`    :   `integer` variable. It is the `LightKrylov` information flag. On exit, if !!                  `info` > 0, the Lanczos factorization experienced a lucky breakdown. !! !!  - `kstart` (*optional*) :   `integer` value determining the index of the first Lanczos !!                              step to be computed. It is an optional `intent(in)` argument. !!                              By default, `kstart = 1`. !! !!  - `kend` (*optional*)   :   `integer` value determining the index of the last Lanczos step !!                              to be computed. It is an optional `intent(in)` argument. !!                              By default, `kend = size(X) - 1`. !! !!  - `tol` (*optional*)    :   Numerical tolerance below which a subspace is considered !!                              to be  A -invariant. It is an optional `intent(in)` argument. !!                              By default `tol = atol_sp` or `tol = atol_rp` depending on the !!                              kind of `A`. module subroutine lanczos_bidiagonalization_rsp ( A , U , V , B , info , kstart , kend , tol ) implicit none ( type , external ) class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be factorized. class ( abstract_vector_rsp ), intent ( inout ) :: U (:) !! Orthonormal basis for the column span of \\mathbf{A}. On entry, `U(1)` needs to be set to !! the starting Krylov vector. class ( abstract_vector_rsp ), intent ( inout ) :: V (:) !! Orthonormal basis for the row span of \\mathbf{A}. real ( sp ), intent ( inout ) :: B (:, :) !! Bidiagonal matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Lanczos factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Lanczos factorization (default 1). real ( sp ), optional , intent ( in ) :: tol !! Tolerance to determine whether invariant subspaces have been computed or not. end subroutine lanczos_bidiagonalization_rsp module subroutine lanczos_bidiagonalization_rdp ( A , U , V , B , info , kstart , kend , tol ) implicit none ( type , external ) class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be factorized. class ( abstract_vector_rdp ), intent ( inout ) :: U (:) !! Orthonormal basis for the column span of \\mathbf{A}. On entry, `U(1)` needs to be set to !! the starting Krylov vector. class ( abstract_vector_rdp ), intent ( inout ) :: V (:) !! Orthonormal basis for the row span of \\mathbf{A}. real ( dp ), intent ( inout ) :: B (:, :) !! Bidiagonal matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Lanczos factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Lanczos factorization (default 1). real ( dp ), optional , intent ( in ) :: tol !! Tolerance to determine whether invariant subspaces have been computed or not. end subroutine lanczos_bidiagonalization_rdp module subroutine lanczos_bidiagonalization_csp ( A , U , V , B , info , kstart , kend , tol ) implicit none ( type , external ) class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be factorized. class ( abstract_vector_csp ), intent ( inout ) :: U (:) !! Orthonormal basis for the column span of \\mathbf{A}. On entry, `U(1)` needs to be set to !! the starting Krylov vector. class ( abstract_vector_csp ), intent ( inout ) :: V (:) !! Orthonormal basis for the row span of \\mathbf{A}. complex ( sp ), intent ( inout ) :: B (:, :) !! Bidiagonal matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Lanczos factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Lanczos factorization (default 1). real ( sp ), optional , intent ( in ) :: tol !! Tolerance to determine whether invariant subspaces have been computed or not. end subroutine lanczos_bidiagonalization_csp module subroutine lanczos_bidiagonalization_cdp ( A , U , V , B , info , kstart , kend , tol ) implicit none ( type , external ) class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be factorized. class ( abstract_vector_cdp ), intent ( inout ) :: U (:) !! Orthonormal basis for the column span of \\mathbf{A}. On entry, `U(1)` needs to be set to !! the starting Krylov vector. class ( abstract_vector_cdp ), intent ( inout ) :: V (:) !! Orthonormal basis for the row span of \\mathbf{A}. complex ( dp ), intent ( inout ) :: B (:, :) !! Bidiagonal matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Lanczos factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Lanczos factorization (default 1). real ( dp ), optional , intent ( in ) :: tol !! Tolerance to determine whether invariant subspaces have been computed or not. end subroutine lanczos_bidiagonalization_cdp end interface !------------------------------------- !-----                           ----- !-----     UTILITY FUNCTIONS     ----- !-----                           ----- !------------------------------------- interface qr !!  ### Description !! !!  Given an array  X  of types derived from `abstract_vector`, it computes the !!  *in-place* QR factorization of  X , i.e. !! !!   !!      X = QR, !!   !! !!  where  Q  is an orthonormal arrays of vectors such that  Q&#94;H Q = I  and !!   R  is upper triangular. Note that it can also perform the QR factorization !!  with column pivoting !! !!   !!      XP = QR !!   !! !!  where  P  is a permutation matrix ensuring that the diagonal entries of  R  !!  have non-increasing absolute values. This amounts to using the pivoting QR as a !!  rank-revealing factorization. !! !!  **References** !! !!  - G. H. Golub & C. F. Van Loan. \"Matrix Computations\". 4th edition, The John Hopkins !!   University Press, 2013. !!   See Chapter 5.2.8: Modified Gram-Schmidt algorithm. !! !!  ### Syntax !! !!  ```fortran !!      call qr(Q [, R] [, perm], info [, tol]) !!  ``` !! !!  ### Arguments !! !!  - `Q`   :   Array of types derived from one of the base types provided in the !!              `AbstractVectors` module. On entry, it contains the original array. !!              On exit, it is overwritten by the orthogonal basis for its span. !!              It is an `intent(inout)` argument. !! !!  - `R`   :   `real` or `complex` rank-2 array. On exit, its contains the upper triangular !!              matrix resulting from the QR factorization. It is an `intent(out)` argument. !! !!  - `perm` (*optional*)   :   Rank-1 array of `integer` corresponding to the indices of !!                              permuted columns. If `perm` is absent, the naive QR factorization !!                              is being computed. In is an optional `intent(in)` argument. !! !!  - `info`    :   `integer` information flag. !! !!  - `tol` (*optional*)    :   Numerical tolerance to determine whether two vectors are colinear !!                              or not. It is an optional `intent(in)` argument. Default `tol = atol_sp` or !!                              `tol = atol_dp`. module subroutine qr_no_pivoting_rsp ( Q , R , info , tol ) implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. real ( sp ), intent ( out ) :: R (:, :) !! Upper triangular matrix \\mathbf{R} resulting from the QR factorization. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: tol end subroutine qr_no_pivoting_rsp module subroutine qr_with_pivoting_rsp ( Q , R , perm , info , tol ) implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. real ( sp ), intent ( out ) :: R (:, :) !! Upper triangular matrix resulting from the QR factorization. integer , intent ( out ) :: perm ( size ( Q )) !! Permutation matrix. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: tol end subroutine qr_with_pivoting_rsp module subroutine qr_no_pivoting_rdp ( Q , R , info , tol ) implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. real ( dp ), intent ( out ) :: R (:, :) !! Upper triangular matrix \\mathbf{R} resulting from the QR factorization. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: tol end subroutine qr_no_pivoting_rdp module subroutine qr_with_pivoting_rdp ( Q , R , perm , info , tol ) implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. real ( dp ), intent ( out ) :: R (:, :) !! Upper triangular matrix resulting from the QR factorization. integer , intent ( out ) :: perm ( size ( Q )) !! Permutation matrix. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: tol end subroutine qr_with_pivoting_rdp module subroutine qr_no_pivoting_csp ( Q , R , info , tol ) implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. complex ( sp ), intent ( out ) :: R (:, :) !! Upper triangular matrix \\mathbf{R} resulting from the QR factorization. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: tol end subroutine qr_no_pivoting_csp module subroutine qr_with_pivoting_csp ( Q , R , perm , info , tol ) implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. complex ( sp ), intent ( out ) :: R (:, :) !! Upper triangular matrix resulting from the QR factorization. integer , intent ( out ) :: perm ( size ( Q )) !! Permutation matrix. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: tol end subroutine qr_with_pivoting_csp module subroutine qr_no_pivoting_cdp ( Q , R , info , tol ) implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. complex ( dp ), intent ( out ) :: R (:, :) !! Upper triangular matrix \\mathbf{R} resulting from the QR factorization. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: tol end subroutine qr_no_pivoting_cdp module subroutine qr_with_pivoting_cdp ( Q , R , perm , info , tol ) implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. complex ( dp ), intent ( out ) :: R (:, :) !! Upper triangular matrix resulting from the QR factorization. integer , intent ( out ) :: perm ( size ( Q )) !! Permutation matrix. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: tol end subroutine qr_with_pivoting_cdp end interface interface permcols !!  ### Description !! !!  Given an array  X  and a permutation vector  p , this function computes !!  *in-place* the column-permuted matrix !! !!   !!      X = X P !!   !! !!  where  P  is the column-permutation matrix constructed from the permutation !!  vector  p . !! !!  ### Syntax !! !!  ```fortran !!      call permcols(X, perm) !!  ``` !! !!  ### Arguments !! !!  - `X`   :   Array of vectors derived from the base types defined in the `AbstractVectors` !!              module. On entry, it is the original array. On exit, it contains the !!              column-permuted version computed in-place. It is an `intent(inout)` argument. !! !!  - `perm`    :   Rank-1 array of `integer` corresponding to the desired permutation vector. !!                  It is an `intent(in)` argument. module subroutine permcols_basis_rsp ( Q , perm ) implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: Q (:) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) end subroutine permcols_basis_rsp module subroutine permcols_array_rsp ( Q , perm ) implicit none ( type , external ) real ( sp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) end subroutine permcols_array_rsp module subroutine permcols_basis_rdp ( Q , perm ) implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: Q (:) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) end subroutine permcols_basis_rdp module subroutine permcols_array_rdp ( Q , perm ) implicit none ( type , external ) real ( dp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) end subroutine permcols_array_rdp module subroutine permcols_basis_csp ( Q , perm ) implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: Q (:) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) end subroutine permcols_basis_csp module subroutine permcols_array_csp ( Q , perm ) implicit none ( type , external ) complex ( sp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) end subroutine permcols_array_csp module subroutine permcols_basis_cdp ( Q , perm ) implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: Q (:) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) end subroutine permcols_basis_cdp module subroutine permcols_array_cdp ( Q , perm ) implicit none ( type , external ) complex ( dp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) end subroutine permcols_array_cdp end interface interface !!  ### Description !! !!  Given a permutation vector  p , this function computes the vector !!  representation of the inverse permutation matrix. !! !!  ### Syntax !! !!  ```fortran !!      inv_perm = invperm(perm) !!  ``` !! !!  ### Arguments !! !!  - `perm`    :   Rank-1 array of `integer` corresponding to the desired permutation vector. !!                  It is an `intent(in)` argument. module function invperm ( perm ) result ( inv_perm ) implicit none ( type , external ) integer , intent ( in ) :: perm (:) integer , allocatable :: inv_perm (:) end function invperm end interface interface initialize_krylov_subspace !!  ### Description !! !!  Utility function to initialize a basis for a Krylov subspace. !! !!  ### Syntax !! !!  ```fortran !!      call initialize_krylov_subspace(X [, X0]) !!  ``` !! !!  ### Arguments !! !!  - `X`   :   Array of vectors that needs to be initialized. It is an `intent(inout)` !!              argument. Note that the first action in the subroutine is !!              `call zero_basis(X)`, effectively zeroing-out any data stored. !! !!  - `X0` (*optional*) :   Collection of vectors which will form the first few !!                          Krylov vectors. Note that `X0` need not be an orthonormal !!                          basis as this subroutine includes a `call orthonormalize_basis(X0)`. !!                          It is an optional `intent(in)` argument. module subroutine initialize_krylov_subspace_rsp ( X , X0 ) implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: X (:) class ( abstract_vector_rsp ), optional , intent ( in ) :: X0 (:) end subroutine initialize_krylov_subspace_rsp module subroutine initialize_krylov_subspace_rdp ( X , X0 ) implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: X (:) class ( abstract_vector_rdp ), optional , intent ( in ) :: X0 (:) end subroutine initialize_krylov_subspace_rdp module subroutine initialize_krylov_subspace_csp ( X , X0 ) implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: X (:) class ( abstract_vector_csp ), optional , intent ( in ) :: X0 (:) end subroutine initialize_krylov_subspace_csp module subroutine initialize_krylov_subspace_cdp ( X , X0 ) implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: X (:) class ( abstract_vector_cdp ), optional , intent ( in ) :: X0 (:) end subroutine initialize_krylov_subspace_cdp end interface interface initialize_random_orthonormal_basis !!  ### Description !! !!  Utility function to initialize a random orthonormal basis. !! !!  ### Syntax !! !!  ```fortran !!      call initialize_random_orthonormal_basis(X) !!  ``` !! !!  ### Arguments !! !!  - `X`   :   Array of vectors that needs to be initialized with random orthonormal vectors. !!              It is an `intent(inout)` argument. module subroutine initialize_random_orthonormal_basis_rsp ( X ) implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: X (:) end subroutine initialize_random_orthonormal_basis_rsp module subroutine initialize_random_orthonormal_basis_rdp ( X ) implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: X (:) end subroutine initialize_random_orthonormal_basis_rdp module subroutine initialize_random_orthonormal_basis_csp ( X ) implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: X (:) end subroutine initialize_random_orthonormal_basis_csp module subroutine initialize_random_orthonormal_basis_cdp ( X ) implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: X (:) end subroutine initialize_random_orthonormal_basis_cdp end interface interface is_orthonormal !!  ### Description !! !!  Utility function returning a logical `.true.` if the set of vectors stored in  X  form !!  an orthonormal set of vectors and `.false.` otherwise. !! !!  ### Syntax !! !!  ```fortran !!      out = is_orthonormal(X) !!  ``` !! !!  ### Arguments !! !!  - `X`   :   Array of derived types extended from the base types provided in the !!              `AbstractVectors` module. It is an `intent(in)` argument. module function is_orthonormal_rsp ( X ) result ( ortho ) implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( in ) :: X (:) logical :: ortho end function is_orthonormal_rsp module function is_orthonormal_rdp ( X ) result ( ortho ) implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( in ) :: X (:) logical :: ortho end function is_orthonormal_rdp module function is_orthonormal_csp ( X ) result ( ortho ) implicit none ( type , external ) class ( abstract_vector_csp ), intent ( in ) :: X (:) logical :: ortho end function is_orthonormal_csp module function is_orthonormal_cdp ( X ) result ( ortho ) implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( in ) :: X (:) logical :: ortho end function is_orthonormal_cdp end interface interface orthonormalize_basis !!  ### Description !! !!  Given an array  X  of vectors, it computes an orthonormal basis for its !!  column-span using the `double_gram_schmidt` process. All computations are done !!  in-place. !! !!  ### Syntax !! !!  ```fortran !!      call orthonormalize_basis(X) !!  ``` !! !!  ### Arguments !! !!  - `X`   :   Array of `abstract_vector` to orthonormalize. Note that this process is done !!              in-place. It is an `intent(inout)` argument. module subroutine orthonormalize_basis_rsp ( X ) !! Orthonormalizes the `abstract_vector` basis `X` implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against end subroutine orthonormalize_basis_rsp module subroutine orthonormalize_basis_rdp ( X ) !! Orthonormalizes the `abstract_vector` basis `X` implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against end subroutine orthonormalize_basis_rdp module subroutine orthonormalize_basis_csp ( X ) !! Orthonormalizes the `abstract_vector` basis `X` implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against end subroutine orthonormalize_basis_csp module subroutine orthonormalize_basis_cdp ( X ) !! Orthonormalizes the `abstract_vector` basis `X` implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against end subroutine orthonormalize_basis_cdp end interface interface orthogonalize_against_basis module subroutine orthogonalize_vector_against_basis_rsp ( y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` `y` against a basis `X` of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. real ( sp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested end subroutine orthogonalize_vector_against_basis_rsp module subroutine orthogonalize_basis_against_basis_rsp ( Y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` basis `Y` against a basis `X` of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. real ( sp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested end subroutine orthogonalize_basis_against_basis_rsp module subroutine orthogonalize_vector_against_basis_rdp ( y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` `y` against a basis `X` of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. real ( dp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested end subroutine orthogonalize_vector_against_basis_rdp module subroutine orthogonalize_basis_against_basis_rdp ( Y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` basis `Y` against a basis `X` of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. real ( dp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested end subroutine orthogonalize_basis_against_basis_rdp module subroutine orthogonalize_vector_against_basis_csp ( y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` `y` against a basis `X` of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. complex ( sp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested end subroutine orthogonalize_vector_against_basis_csp module subroutine orthogonalize_basis_against_basis_csp ( Y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` basis `Y` against a basis `X` of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. complex ( sp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested end subroutine orthogonalize_basis_against_basis_csp module subroutine orthogonalize_vector_against_basis_cdp ( y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` `y` against a basis `X` of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. complex ( dp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested end subroutine orthogonalize_vector_against_basis_cdp module subroutine orthogonalize_basis_against_basis_cdp ( Y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` basis `Y` against a basis `X` of `abstract_vector`. implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. complex ( dp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested end subroutine orthogonalize_basis_against_basis_cdp end interface interface double_gram_schmidt_step !!  ### Description !! !!  Given an array  X  of `abstract_vector` and an `abstract_vector` !!  (or array of `abstract_vectors`)  y , this subroutine returns a modified !!  vector  y  orthogonal to all columns of  X , i.e. !! !!   !!      y \\leftarrow \\left( I - XX&#94;H \\right) y, !!   !! !!  using a double Gram-Schmidt process. On exit,  y  is orthogonal to  X  but !!  does not have unit norm. Note moreover that  X  is assumed to be an orthonormal !!  set of vectors. The function can also return the projection coefficients !!   \\beta = X&#94;H y . !! !!  ### Syntax !! !!  ```fortran !!      call double_gram_schmidt_step(y, X, info [, if_chk_orthonormal] [, beta]) !!  ``` !! !!  ### Arguments !! !!  - `y`   :   `abstract_vector` (or array of `abstract_vector`) that needs to be !!              orthogonalize **in-place** against  X . It is an `intent(inout)` argument. !! !!  - `X`   :   Array of `abstract_vector` against which  y  needs to be orthogonalized. !!              Note the function assumes that  X  is an orthonormal set of vectors, i.e. !!               X&#94;H X = I . If it this is not the case, the result is meaningless. !!              It is an `intent(in)` argument. !! !!  - `info`    :   `integer` Information flag. !! !!  - `if_chk_orthonormal` (*optional*) :   `logical` flag to check whether !!                                           X  is an orthonormal set of vectors or not. !!                                          If the orthonormality returns `.false.`, the function raises !!                                          an error. Note that this check is computationally expensive !!                                          and should be disabled in production unless required !!                                          for better performance. Is is an optional `intent(in)` !!                                          argument. Default `.true.`. !! !!  - `beta` (*optional*)   :   `real` or `complex` array containing the coefficients  \\beta = X&#94;H y . !!                              Is is an optional `intent(out)` argument. module subroutine DGS_vector_against_basis_rsp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the implicit none ( type , external ) !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_rsp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. real ( sp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested end subroutine DGS_vector_against_basis_rsp module subroutine DGS_basis_against_basis_rsp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the implicit none ( type , external ) !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_rsp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. real ( sp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested end subroutine DGS_basis_against_basis_rsp module subroutine DGS_vector_against_basis_rdp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the implicit none ( type , external ) !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_rdp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. real ( dp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested end subroutine DGS_vector_against_basis_rdp module subroutine DGS_basis_against_basis_rdp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the implicit none ( type , external ) !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_rdp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. real ( dp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested end subroutine DGS_basis_against_basis_rdp module subroutine DGS_vector_against_basis_csp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the implicit none ( type , external ) !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_csp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. complex ( sp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested end subroutine DGS_vector_against_basis_csp module subroutine DGS_basis_against_basis_csp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the implicit none ( type , external ) !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_csp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. complex ( sp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested end subroutine DGS_basis_against_basis_csp module subroutine DGS_vector_against_basis_cdp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the implicit none ( type , external ) !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_cdp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. complex ( dp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested end subroutine DGS_vector_against_basis_cdp module subroutine DGS_basis_against_basis_cdp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the implicit none ( type , external ) !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_cdp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!). Default `.true.`. complex ( dp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested end subroutine DGS_basis_against_basis_cdp end interface interface krylov_schur !!  ### Description !! !!  Given a partial Krylov decomposition !! !!   !!      AX_k = X_k H_k + h_{k+1, k} x_{k+1} e_k&#94;H, !!   !! !!  this subroutine implements the Krylov-Schur restarting strategy proposed by !!  Stewart [1]. !! !!  **References** !! !!  - G. W. Stewart. \"A Krylov-Schur algorithm for large eigenproblems\". !!    SIAM Journal on Matrix Analysis and Applications, vol 23 (3), 2002. !! !!  ### Syntax !! !!  ```fortran !!      call krylov_schur(n, X, H, select_eigs) !!  ``` !! !!  ### Arguments !! !!  - `n`   :   Number of selected eigenvalues moved to the upper left-block of the !!              Schur matrix. It is an `intent(out)` argument. !! !!  - `X`   :   On entry, array of `abstract_vector` computed using the Arnoldi process. !!              On exit, the first `n` columns form an orthonormal basis for the eigenspace !!              associated with eigenvalues moved to the upper left-block of the Schur matrix. !!              It is an `intent(inout)` argument. !! !!  - `H`   :   On entry, `real` of `complex` upper Hessenberg matrix computed using the !!              Arnoldi process. On exit, the leading  n \\times n block contains the !!               S_{11}  block of the re-ordered Schur matrix containing the selected !!              eigenvalues. It is an `intent(inout)` argument. !! !!  - `select_eigs` :   Procedure to select which eigenvalues to move in the upper-left !!                  block. It is an `intent(inout)` argument. module procedure krylov_schur_rsp module procedure krylov_schur_rdp module procedure krylov_schur_csp module procedure krylov_schur_cdp end interface !---------------------------------------------------------- !-----     ABSTRACT EIGENVALUE SELECTOR INTERFACE     ----- !---------------------------------------------------------- abstract interface function eigvals_select_sp ( lambda ) result ( selected ) import sp implicit none ( type , external ) complex ( sp ), intent ( in ) :: lambda (:) logical , allocatable :: selected (:) end function eigvals_select_sp function eigvals_select_dp ( lambda ) result ( selected ) import dp implicit none ( type , external ) complex ( dp ), intent ( in ) :: lambda (:) logical , allocatable :: selected (:) end function eigvals_select_dp end interface contains !---------------------------------------- !-----     KRYLOV-SCHUR RESTART     ----- !---------------------------------------- subroutine krylov_schur_rsp ( n , X , H , select_eigs ) character ( len =* ), parameter :: this_procedure = 'krylov_schur_rsp' integer , intent ( out ) :: n !! Number eigenvalues that have been moved to the upper !! left block of the Schur factorization of `H`. class ( abstract_vector_rsp ), intent ( inout ) :: X (:) !! Krylov basis. real ( sp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. procedure ( eigvals_select_sp ) :: select_eigs !! Procedure to select the eigenvalues to move in the upper left-block. ! Schur-related. real ( sp ) :: Z ( size ( H , 2 ), size ( H , 2 )), T ( size ( H , 2 ), size ( H , 2 )) complex ( sp ) :: eigvals ( size ( H , 2 )) logical :: selected ( size ( H , 2 )) ! Miscellaneous integer :: kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Krylov subspace dimension. kdim = size ( X ) - 1 ! Schur decomposition of the Hessenberg matrix. call schur ( H (: size ( H , 2 ), :), T , Z , eigvals ) ; H (: size ( H , 2 ), :) = T ! Eigenvalue selection of the upper left block. selected = select_eigs ( eigvals ) ; n = count ( selected ) ! Re-order the Schur decomposition and Schur basis. call ordschur ( H (: kdim , :), Z , selected ) ! Update the Hessenberg matrix and Krylov basis. block real ( sp ) :: b ( size ( H , 2 )) class ( abstract_vector_rsp ), allocatable :: Xwrk (:) ! Update the Krylov basis. call linear_combination ( Xwrk , X (: size ( H , 2 )), Z (:, : n )) call copy ( X (: n ), Xwrk (: n )) call copy ( X ( n + 1 ), X ( kdim + 1 )) call zero_basis ( X ( n + 2 :)) ! Update the Hessenberg matrix. b = matmul ( H ( kdim + 1 , :), Z ) H ( n + 1 , :) = b H ( n + 2 :, :) = zero_rsp H (:, n + 1 :) = zero_rsp end block if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end subroutine krylov_schur_rsp subroutine krylov_schur_rdp ( n , X , H , select_eigs ) character ( len =* ), parameter :: this_procedure = 'krylov_schur_rdp' integer , intent ( out ) :: n !! Number eigenvalues that have been moved to the upper !! left block of the Schur factorization of `H`. class ( abstract_vector_rdp ), intent ( inout ) :: X (:) !! Krylov basis. real ( dp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. procedure ( eigvals_select_dp ) :: select_eigs !! Procedure to select the eigenvalues to move in the upper left-block. ! Schur-related. real ( dp ) :: Z ( size ( H , 2 ), size ( H , 2 )), T ( size ( H , 2 ), size ( H , 2 )) complex ( dp ) :: eigvals ( size ( H , 2 )) logical :: selected ( size ( H , 2 )) ! Miscellaneous integer :: kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Krylov subspace dimension. kdim = size ( X ) - 1 ! Schur decomposition of the Hessenberg matrix. call schur ( H (: size ( H , 2 ), :), T , Z , eigvals ) ; H (: size ( H , 2 ), :) = T ! Eigenvalue selection of the upper left block. selected = select_eigs ( eigvals ) ; n = count ( selected ) ! Re-order the Schur decomposition and Schur basis. call ordschur ( H (: kdim , :), Z , selected ) ! Update the Hessenberg matrix and Krylov basis. block real ( dp ) :: b ( size ( H , 2 )) class ( abstract_vector_rdp ), allocatable :: Xwrk (:) ! Update the Krylov basis. call linear_combination ( Xwrk , X (: size ( H , 2 )), Z (:, : n )) call copy ( X (: n ), Xwrk (: n )) call copy ( X ( n + 1 ), X ( kdim + 1 )) call zero_basis ( X ( n + 2 :)) ! Update the Hessenberg matrix. b = matmul ( H ( kdim + 1 , :), Z ) H ( n + 1 , :) = b H ( n + 2 :, :) = zero_rdp H (:, n + 1 :) = zero_rdp end block if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end subroutine krylov_schur_rdp subroutine krylov_schur_csp ( n , X , H , select_eigs ) character ( len =* ), parameter :: this_procedure = 'krylov_schur_csp' integer , intent ( out ) :: n !! Number eigenvalues that have been moved to the upper !! left block of the Schur factorization of `H`. class ( abstract_vector_csp ), intent ( inout ) :: X (:) !! Krylov basis. complex ( sp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. procedure ( eigvals_select_sp ) :: select_eigs !! Procedure to select the eigenvalues to move in the upper left-block. ! Schur-related. complex ( sp ) :: Z ( size ( H , 2 ), size ( H , 2 )), T ( size ( H , 2 ), size ( H , 2 )) complex ( sp ) :: eigvals ( size ( H , 2 )) logical :: selected ( size ( H , 2 )) ! Miscellaneous integer :: kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Krylov subspace dimension. kdim = size ( X ) - 1 ! Schur decomposition of the Hessenberg matrix. call schur ( H (: size ( H , 2 ), :), T , Z , eigvals ) ; H (: size ( H , 2 ), :) = T ! Eigenvalue selection of the upper left block. selected = select_eigs ( eigvals ) ; n = count ( selected ) ! Re-order the Schur decomposition and Schur basis. call ordschur ( H (: kdim , :), Z , selected ) ! Update the Hessenberg matrix and Krylov basis. block complex ( sp ) :: b ( size ( H , 2 )) class ( abstract_vector_csp ), allocatable :: Xwrk (:) ! Update the Krylov basis. call linear_combination ( Xwrk , X (: size ( H , 2 )), Z (:, : n )) call copy ( X (: n ), Xwrk (: n )) call copy ( X ( n + 1 ), X ( kdim + 1 )) call zero_basis ( X ( n + 2 :)) ! Update the Hessenberg matrix. b = matmul ( H ( kdim + 1 , :), Z ) H ( n + 1 , :) = b H ( n + 2 :, :) = zero_csp H (:, n + 1 :) = zero_csp end block if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end subroutine krylov_schur_csp subroutine krylov_schur_cdp ( n , X , H , select_eigs ) character ( len =* ), parameter :: this_procedure = 'krylov_schur_cdp' integer , intent ( out ) :: n !! Number eigenvalues that have been moved to the upper !! left block of the Schur factorization of `H`. class ( abstract_vector_cdp ), intent ( inout ) :: X (:) !! Krylov basis. complex ( dp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. procedure ( eigvals_select_dp ) :: select_eigs !! Procedure to select the eigenvalues to move in the upper left-block. ! Schur-related. complex ( dp ) :: Z ( size ( H , 2 ), size ( H , 2 )), T ( size ( H , 2 ), size ( H , 2 )) complex ( dp ) :: eigvals ( size ( H , 2 )) logical :: selected ( size ( H , 2 )) ! Miscellaneous integer :: kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Krylov subspace dimension. kdim = size ( X ) - 1 ! Schur decomposition of the Hessenberg matrix. call schur ( H (: size ( H , 2 ), :), T , Z , eigvals ) ; H (: size ( H , 2 ), :) = T ! Eigenvalue selection of the upper left block. selected = select_eigs ( eigvals ) ; n = count ( selected ) ! Re-order the Schur decomposition and Schur basis. call ordschur ( H (: kdim , :), Z , selected ) ! Update the Hessenberg matrix and Krylov basis. block complex ( dp ) :: b ( size ( H , 2 )) class ( abstract_vector_cdp ), allocatable :: Xwrk (:) ! Update the Krylov basis. call linear_combination ( Xwrk , X (: size ( H , 2 )), Z (:, : n )) call copy ( X (: n ), Xwrk (: n )) call copy ( X ( n + 1 ), X ( kdim + 1 )) call zero_basis ( X ( n + 2 :)) ! Update the Hessenberg matrix. b = matmul ( H ( kdim + 1 , :), Z ) H ( n + 1 , :) = b H ( n + 2 :, :) = zero_cdp H (:, n + 1 :) = zero_cdp end block if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end subroutine krylov_schur_cdp end module LightKrylov_BaseKrylov","tags":"","url":"sourcefile/basekrylov.f90.html"},{"title":"Logger.f90 – LightKrylov","text":"Source Code module LightKrylov_Logger #ifdef MPI use mpi_f08 #endif ! Fortran Standard Library use stdlib_optval , only : optval use stdlib_logger , only : logger => global_logger use stdlib_ascii , only : to_lower use stdlib_strings , only : chomp , replace_all ! LightKrylov use LightKrylov_Constants implicit none ( type , external ) private character ( len = 128 ), parameter :: this_module = 'LightKrylov_Logger' logical , parameter , private :: exit_on_error = . true . logical , parameter , private :: exit_on_test_error = . true . logical :: logger_is_active = . false . public :: stop_error public :: type_error public :: check_info public :: logger public :: log_message , log_information , log_warning , log_error , log_debug public :: logger_setup ! MPI subroutines public :: comm_setup public :: comm_close contains subroutine logger_setup ( logfile , nio , log_level , log_stdout , log_timestamp , close_old , iunit ) !! Wrapper to set up MPI if needed and initialize log files character ( len =* ), optional , intent ( in ) :: logfile !! name of the dedicated LightKrylov logfile integer , optional , intent ( in ) :: nio !! I/O rank for logging integer , optional , intent ( in ) :: log_level !! set logging level !! 0   : all_level !! 10  : debug_level !! 20  : information_level !! 30  : warning_level !! 40  : error_level !! 100 : none_level logical , optional , intent ( in ) :: log_stdout !! duplicate log messages to stdout? logical , optional , intent ( in ) :: log_timestamp !! add timestamp to log messages logical , optional , intent ( in ) :: close_old !! close previously opened logfiles (if present?) - stdout is not closed integer , optional , intent ( out ) :: iunit !! log unit identifier ! internals character ( len =* ), parameter :: this_procedure = 'logger_setup' character ( len = :), allocatable :: logfile_ integer :: nio_ integer :: log_level_ logical :: log_stdout_ logical :: log_timestamp_ logical :: close_old_ integer :: iunit_ ! misc character ( len = 128 ) :: msg integer :: stat logfile_ = optval ( logfile , 'lightkrylov.log' ) nio_ = optval ( nio , 0 ) log_level_ = optval ( log_level , 20 ) log_level_ = max ( 0 , min ( log_level_ , 100 )) log_stdout_ = optval ( log_stdout , . true .) log_timestamp_ = optval ( log_timestamp , . true .) close_old_ = optval ( close_old , . true .) ! Set up comms call comm_setup () ! Set I/O rank if ( nio_ /= 0 ) call set_io_rank ( nio_ ) if ( io_rank ()) then write ( msg , '(A,I0,A,I0)' ) 'IO rank = ' , get_rank () call logger % log_message ( trim ( msg ), this_module , this_procedure ) end if if ( io_rank ()) then ! Flush log units if ( close_old_ ) call reset_log_units () ! set log level call logger % configure ( level = log_level_ , time_stamp = log_timestamp_ ) ! set up LightKrylov log file call logger % add_log_file ( logfile_ , unit = iunit_ , stat = stat ) if ( stat /= 0 ) call stop_error ( 'Unable to open logfile ' // trim ( logfile_ ) // '.' , this_module , this_procedure ) ! log to stdout if ( log_stdout_ ) then call logger % add_log_unit ( unit = 6 , stat = stat ) if ( stat /= 0 ) call stop_error ( 'Unable to add stdout to logger.' , this_module , this_procedure ) end if ! return unit if requested if ( present ( iunit )) iunit = iunit_ end if ! mark that logger is active logger_is_active = . true . end subroutine logger_setup subroutine log_message ( msg , module , procedure , flush_log ) character ( len =* ), intent ( in ) :: msg !! Log message to print character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens logical , optional , intent ( in ) :: flush_log !! Flush the I/O buffer? ! internal logical :: flush_ flush_ = optval ( flush_log , . true .) if ( logger_is_active ) then if ( io_rank ()) then call logger % log_message ( msg , module = module , procedure = procedure ) if ( flush_ ) call flush_log_units () end if else print '(A)' , msg end if end subroutine log_message subroutine log_information ( msg , module , procedure , flush_log ) character ( len =* ), intent ( in ) :: msg !! Log message to print character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens logical , optional , intent ( in ) :: flush_log !! Flush the I/O buffer? ! internal logical :: flush_ flush_ = optval ( flush_log , . true .) if ( logger_is_active ) then if ( io_rank ()) then call logger % log_information ( msg , module = module , procedure = procedure ) if ( flush_ ) call flush_log_units () end if else print '(\"INFO: \",A)' , msg end if end subroutine log_information subroutine log_warning ( msg , module , procedure ) character ( len =* ), intent ( in ) :: msg !! Log message to print character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens if ( logger_is_active ) then if ( io_rank ()) then call logger % log_warning ( msg , module = module , procedure = procedure ) call flush_log_units () end if else print '(\"WARN: \",A)' , msg end if end subroutine log_warning subroutine log_error ( msg , module , procedure , stat , errmsg ) character ( len =* ), intent ( in ) :: msg !! Log message to print character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens integer , optional , intent ( in ) :: stat !! status message character ( len =* ), optional , intent ( in ) :: errmsg !! error message if ( logger_is_active ) then if ( io_rank ()) then call logger % log_error ( msg , module = module , procedure = procedure , stat = stat , errmsg = errmsg ) call flush_log_units () end if else print '(A,\": \",A)' , msg , errmsg end if end subroutine log_error subroutine log_debug ( msg , module , procedure ) character ( len =* ), intent ( in ) :: msg !! Log message to print character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens if ( logger_is_active ) then if ( io_rank ()) then call logger % log_debug ( msg , module = module , procedure = procedure ) call flush_log_units () end if else print '(\"DEBUG: \",A)' , msg end if end subroutine log_debug subroutine flush_log_units () integer , allocatable :: current_log_units (:) integer :: i if ( io_rank ()) then ! get current units call logger % configuration ( log_units = current_log_units ) do i = 1 , size ( current_log_units ) call flush ( current_log_units ( i )) end do end if end subroutine flush_log_units subroutine reset_log_units () integer , allocatable :: current_log_units (:) integer :: i , iunit if ( io_rank ()) then ! get current units call logger % configuration ( log_units = current_log_units ) ! close all existing units (except stdout if it is included) do i = 1 , size ( current_log_units ) iunit = current_log_units ( i ) if ( iunit == 6 ) then call logger % remove_log_unit ( unit = iunit ) else call logger % remove_log_unit ( unit = iunit , close_unit = . true .) end if end do end if end subroutine reset_log_units subroutine comm_setup () ! internal character ( len =* ), parameter :: this_procedure = 'comm_setup' character ( len = 128 ) :: msg #ifdef MPI integer :: ierr , rank_local , size_local logical :: mpi_is_initialized call MPI_Initialized ( mpi_is_initialized , ierr ) if (. not . mpi_is_initialized ) then call MPI_Init ( ierr ) if ( ierr /= MPI_SUCCESS ) call stop_error ( \"Error initializing MPI\" , this_module , this_procedure ) end if call MPI_Comm_rank ( MPI_COMM_WORLD , rank_local , ierr ) call MPI_Comm_size ( MPI_COMM_WORLD , size_local , ierr ) call set_rank ( rank_local ) call set_comm_size ( size_local ) if ( rank_local == 0 ) then call logger % log_message ( 'Setup parallel run' , this_module , this_procedure ) write ( msg , '(A,I0,A,I0)' ) 'comm_size = ' , size_local call logger % log_message ( trim ( msg ), this_module , this_procedure ) end if #else call set_rank ( 0 ) call set_comm_size ( 1 ) call logger % log_message ( 'Setup serial run' , this_module , this_procedure ) #endif end subroutine comm_setup subroutine comm_close () integer :: ierr #ifdef MPI character ( len = 128 ) :: msg ! Finalize MPI call MPI_Finalize ( ierr ) if ( ierr /= MPI_SUCCESS ) call stop_error ( \"Error finalizing MPI\" , this_module , 'comm_close' ) #else ierr = 0 #endif end subroutine comm_close subroutine stop_error ( msg , module , procedure ) character ( len =* ), intent ( in ) :: msg !! The name of the procedure in which the call happens character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens call check_info ( - 1 , origin = \"STOP_ERROR\" , module = module , procedure = procedure , info_msg = msg ) end subroutine stop_error subroutine type_error ( var , type , intent , module , procedure ) character ( len =* ), intent ( in ) :: var !! Name of the variable character ( len =* ), intent ( in ) :: type !! Required type of the variable character ( len =* ), intent ( in ) :: intent !! Intent of the argument within the caller character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens character ( len = 256 ) :: msg msg = \"The intent [\" // trim ( intent ) // \"] argument '\" // trim ( var ) // \"' must be of type '\" // trim ( type ) // \"'\" call stop_error ( msg , module = module , procedure = procedure ) end subroutine type_error subroutine check_info ( info , origin , module , procedure , info_msg ) integer , intent ( in ) :: info !! Informaion flag character ( len =* ), intent ( in ) :: origin !! The name of the subroutine from which the flag originates character ( len =* ), optional , intent ( in ) :: module !! The name of the module in which the call happens character ( len =* ), optional , intent ( in ) :: procedure !! The name of the procedure in which the call happens character ( len =* ), optional , intent ( in ) :: info_msg character ( len = 128 ) :: str !! Optional extra message ! internals character ( len = 256 ) :: msg integer :: ierr str = optval ( info_msg , '' ) ierr = 0 if ( info == 0 ) then ! Successful exit --> only log on debug write ( msg , '(A)' ) 'The subroutine \"' // trim ( origin ) // '\" returned successfully. ' // trim ( str ) call log_debug ( trim ( msg ), module = module , procedure = procedure ) else ! !   LAPACK ! if ( trim ( to_lower ( origin )) == 'getref' ) then ! GETREF if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A,I0,A,I0,A)' ) \"U(\" , info , \",\" , info , \") is exactly zero. The factorization \" , & & \"has been completed but the factor U is exactly singular. \" , & & \"Division by zero will occur if used to solve Ax=b. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'getri' ) then ! GETRI if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A,I0,A)' ) \"U(\" , info , \",\" , info , \") is exactly zero. \" , & & \"The matrix is singular and its inverse cannot be computed. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'geev' ) then ! GEEV if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A,I0,A)' ) \"The QR alg. failed to compute all of the eigenvalues.\" , & & \"No eigenvector has been computed. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'syev' ) then ! SYEV if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"The QR alg. failed to compute all of the eigenvalues.\" , & & \"No eigenvector has been computed. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'heev' ) then ! HEEV if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"The QR alg. failed to compute all of the eigenvalues.\" , & & \"No eigenvector has been computed. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'gels' ) then ! GELS if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'gees' ) then ! GEES if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"The QR alg. failed to compute all of the eigenvalues.\" , & & \"No eigenvector has been computed. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'trsen' ) then ! GEES if ( info < 0 ) then write ( msg , '(A,I0,A)' ) \"The \" , - info , \"-th argument has illegal value. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else if ( info == 1 ) then write ( msg , '(A)' ) \"The reordering of T failed because some eigenvalues are too\" , & & \"close to separate (the problem is very ill-conditioned); \" , & & \"T may have been partially reordered, and WR and WI \" , & & \"contain the eigenvalues in the same order as in T; S and\" , & & \"SEP (if requested) are set to zero. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if ! !   LightKrylov_Utils ! else if ( trim ( to_lower ( origin )) == 'sqrtm' ) then if ( info == 1 ) then write ( msg , '(A)' ) 'The input matrix is singular to tolerance. The singular eigenvalues are set to zero. ' call log_warning ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) \"The input matrix is not positive (semi-)definite. \" call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if ! !   LightKrylov_BaseKrylov ! else if ( trim ( to_lower ( origin )) == 'orthogonalize_against_basis' ) then ! the regular case ! orthogonalization if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Orthogonalization: The ' , info , 'th input vector is numerically zero.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) 'The input Krylov basis is not orthonormal.' call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else if ( info == - 2 ) then write ( msg , '(A)' ) 'Orthogonalization: The last column of the input basis is zero.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'orthogonalize_against_basis_p1' ) then ! orthogonalization if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Orthogonalization: The ' , info , 'th input vector is numerically zero.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) 'The input Krylov basis is not orthonormal.' call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else if ( info == - 2 ) then write ( msg , '(A)' ) 'Orthogonalization: The last column of the input basis is zero.' call log_warning ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'orthogonalize_against_basis_p2' ) then ! orthogonalization if ( info > 0 ) then ! show this information only for debugging write ( msg , '(A,I0,A)' ) 'Orthogonalization: The ' , info , 'th input vector is numerically zero.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) 'The input Krylov basis is not orthonormal.' call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else if ( info == - 2 ) then write ( msg , '(A)' ) 'Orthogonalization: The last column of the input basis is zero.' call log_warning ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'double_gram_schmidt_step' ) then ! orthogonalization if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Orthogonalization: The ' , info , 'th input vector is numerically zero.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) 'The input Krylov basis is not orthonormal.' call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 else if ( info == - 2 ) then write ( msg , '(A)' ) 'Orthogonalization: The last column of the input basis is zero.' call log_warning ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'qr' ) then ! qr if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'QR factorization: Colinear column detected in column ' , info , & & '. NOTE: Other subsequent columns may also be colinear.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'qr_pivot' ) then ! qr_pivot if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'QR factorization: Invariant subspace found after ' , info , ' steps.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'arnoldi' ) then ! arnoldi if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Arnoldi factorization: Invariant subspace computed after ' , info , ' iterations.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'bidiagonalization' ) then ! lanczos_bidiagonalization if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Lanczos Bidiagonalisation: Invariant subspace found after ' , info , ' steps.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'lanczos' ) then ! lanczos_tridiagonalization if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'Lanczos Tridiagonalisation: Invariant subspace found after ' , info , ' steps.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if ! !   LightKrylov_IterativeSolvers ! else if ( trim ( to_lower ( origin )) == 'eigs' ) then ! GMRES if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'eigs iteration converged after ' , info , ' iterations' call log_information ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'eighs' ) then ! GMRES if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'eigs iteration converged after ' , info , ' iterations' call log_information ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'svds' ) then ! GMRES if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'svds iteration converged after ' , info , ' iterations' call log_information ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'gmres' ) then ! GMRES if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'GMRES iteration converged after ' , info , ' iterations' call log_message ( trim ( msg ), module = module , procedure = procedure ) else if ( info < 0 ) then write ( msg , '(A,I0,A)' ) 'Maximum number of GMRES iterations reached (' , abs ( info ), & & '). Solution tolerance not achieved.' call log_message ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'fgmres' ) then ! GMRES if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'FGMRES iteration converged after ' , info , ' iterations' call log_message ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'cg' ) then ! CG if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'CG iteration converged after ' , info , ' iterations' call log_message ( trim ( msg ), module = module , procedure = procedure ) else if ( info < 0 ) then write ( msg , '(A,I0,A)' ) 'Maximum number of CG iterations reached (' , abs ( info ), & & '). Solution tolerance not achieved.' call log_message ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if else if ( trim ( to_lower ( origin )) == 'linear_solver' ) then ! Abstract linear solver if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'The linear solver converged after ' , info , ' iterations' call log_message ( trim ( msg ), module = module , procedure = procedure ) else if ( info < 0 ) then write ( msg , '(A,I0,A)' ) 'Maximum number of iterations reached (' , abs ( info ), & & '). Solution tolerance not achieved.' call log_message ( trim ( msg ), module = module , procedure = procedure ) else write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if ! !   LightKrylov_ExpmLib ! else if ( trim ( to_lower ( origin )) == 'kexpm' ) then ! Krylov Matrix Exponential if ( info > 0 ) then write ( msg , '(A,I0,A)' ) 'kexpm converged. Estimated error below tolerance using ' , info , ' Krylov vectors.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 2 ) then write ( msg , '(A)' ) 'kexpm converged. Arnoldi iteration breakdown. Approximation is exact to arnoldi tolerance.' call log_debug ( trim ( msg ), module = module , procedure = procedure ) else if ( info == - 1 ) then write ( msg , '(A)' ) 'kexpm did not converge. Maximum number of Krylov vectors reached.' call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 write ( msg , '(A)' ) \"Undocumented error. \" // trim ( str ) call log_error ( origin , module = module , procedure = procedure , stat = info , errmsg = trim ( msg )) ierr = - 1 end if ! !  stop error ! else if ( trim ( origin ) == 'STOP_ERROR' ) then call log_error ( trim ( origin ), module = module , procedure = procedure , stat = info , errmsg = trim ( str )) ierr = - 1 ! !   Default ! else write ( msg , '(A)' ) 'subroutine \"' // trim ( origin ) // '\" returned with a non-zero error flag.' call log_error ( trim ( msg ), module = module , procedure = procedure , stat = info , errmsg = trim ( str )) ierr = - 1 end if end if ! info /= 0 call error_handler ( ierr ) end subroutine check_info subroutine error_handler ( ierr ) integer , intent ( in ) :: ierr if ( ierr == 0 ) then return else if ( exit_on_error ) then write ( * , * ) write ( * , * ) 'A fatal error was encountered. Aborting calculation as per user directive.' write ( * , * ) if ( logger_is_active ) then write ( * , * ) 'Details on the error have been written to the lightkrylov logfile.' end if STOP 1 end if end if end subroutine error_handler end module LightKrylov_Logger","tags":"","url":"sourcefile/logger.f90.html"},{"title":"Timer_Utils.f90 – LightKrylov","text":"Source Code module LightKrylov_Timer_Utils use stdlib_optval , only : optval use stdlib_ascii , only : to_lower use LightKrylov_Constants , only : dp use LightKrylov_Logger implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_TmrUtils' character ( len =* ), parameter :: this_module_long = 'LightKrylov_Timer_Utils' ! Timer type type , public :: lightkrylov_timer !! Individual timer. !! Atomic timer that is associated to a particular 'event' by name which may be a !! procedure or a user-defined string at instantiation. !! !! The timing information in gathered for each timer independently. The individual !! timers are gathered into groups (relevant only for timing output) and managed !! by a central watch that is derived from  the `abstract_watch` type. The !! individual timers are rarely used independently but all timing actions are !! typically performed via procedures in the central timer. !! !! A notable exception are the `matvec`/`rmatvec` as well as `reponse` timers !! associated with the types `abstract_linop` and `abstract_system`, respectively, !! which are managed via their parent types and the corresponding type-bound !! procedures only. private character ( len = 128 ), public :: name = 'default_timer' !! Timer name. real ( dp ) :: etime = 0.0_dp !! Elapsed time since reset. real ( dp ) :: etime_pause = 0.0_dp !! Elapsed time up until most recent pause. real ( dp ) :: start_time = 0.0_dp !! Start time for comparison. real ( dp ) :: etime_max = 0.0_dp !! Maximum elapsed time since reset. real ( dp ) :: etime_min = huge ( 1.0_dp ) !! Minimum elapsed time since reset. integer :: local_count = 0 !! Call counter since reset. integer :: reset_count = 0 !! Reset counter. integer :: count = 0 !! Global counter (only reset when data is flushed). logical :: running = . false . !! Protection against repeated starts. logical :: is_finalized = . false . !! Switch for printing. real ( dp ), dimension (:), allocatable :: etime_data real ( dp ), dimension (:), allocatable :: etavg_data real ( dp ), dimension (:), allocatable :: etmin_data real ( dp ), dimension (:), allocatable :: etmax_data integer , dimension (:), allocatable :: count_data contains private procedure , pass ( self ), public :: start => start_timer procedure , pass ( self ), public :: stop => stop_timer procedure , pass ( self ), public :: pause => pause_timer procedure , pass ( self ), public :: reset => reset_timer !! Reset timing data (soft/hard, clear/save data). procedure , pass ( self ), public :: finalize => finalize_timer !! Aggregate data and prepare summary. procedure , pass ( self ), public :: get_time => get_timer_etime !! Getter routine to access self%etime only. procedure , pass ( self ), public :: get_data => get_timer_data !! Getter routine to access to all local data: etime, counts, etime_max, etime_min, etime_pause. procedure , pass ( self ), public :: get_data_save => get_timer_data_save !! Getter routine to access to global data. procedure , pass ( self ), public :: print_info => print_timer_info !! Print timing data. procedure , pass ( self ), public :: save_timer_data !! Transfer timing data to arrays. end type lightkrylov_timer ! Timer group type type , public :: lightkrylov_timer_group !! Simple type to allow for some structure in the timer output. private character ( len = 128 ), public :: name = 'default_group' !! group name. integer :: istart = 0 !! global index of first timer in group. integer :: iend = 0 !! global index of last timer in group. end type lightkrylov_timer_group ! Abstract watch type type , abstract , public :: abstract_watch !! Base type to define a global timer. !! All watches within LightKrylov and associated tools are derived from this type. !! !! Within LightKrylov, the derived type `global_lightkrylov_timer` is used to manage all !! atomic timers associated with both internal routines (private) as well as user-defined !! (public) timers that can be added and removed as necessary. In order to protect the !! private timers, they are defined and set only during the initialisation of the derived !! type via the deferred procedure `set_private_timers_and_name` if timing is requested !! and cannot be deleted. !! Once the global watch is initalized, the user can define and subsequently remove !! user-defined timers at any point that will be managed by the global watch in the same !! way as private timers. !! Upon finalization, the user-defined timers with the associated timing information is !! presented together with that of the private timers. !! !! The type-bound procedures of the abstract_watch type allow individual access to each !! managed timer individually using the timer name as reference. private character ( len = 128 ) :: name = 'default_watch' type ( lightkrylov_timer ), dimension (:), allocatable :: timers !! Array of timers contained in the watch. integer :: timer_count = 0 !! Number of timers managed by watch. type ( lightkrylov_timer_group ), dimension (:), allocatable :: groups !! Array of timer groups contained in the watch. integer :: group_count = 0 !! Number of timer groups managed by watch. integer :: private_count = 0 !! Number of private timers (immutable by user). integer :: user_count = 0 !! Number of user defined timers. logical :: user_mode = . false . !! Number of user defined timers. logical :: is_initialized = . false . contains private procedure , pass ( self ), public :: add_timer !! Add new timer to the watch. procedure , pass ( self ), public :: remove_timer !! Remove existing timer from the watch. procedure , pass ( self ), public :: add_group !! Add new timer group to the watch. ! Getter/Setter and helper routines for watch components. procedure , pass ( self ), public :: get_timer_id procedure , pass ( self ), public :: get_group_id procedure , pass ( self ), public :: set_watch_name ! Wrappers for the basic timing routines/access to timer components. procedure , pass ( self ), public :: start => start_timer_by_name procedure , pass ( self ), public :: stop => stop_timer_by_name procedure , pass ( self ), public :: pause => pause_timer_by_name procedure , pass ( self ), public :: reset => reset_timer_by_name procedure , pass ( self ), public :: get_time => get_timer_etime_by_name procedure , pass ( self ), public :: get_data => get_timer_data_by_name procedure , pass ( self ), public :: get_data_save => get_timer_data_save_by_name procedure , pass ( self ), public :: print_info => print_timer_info_by_name ! Global manipulation routines. procedure , pass ( self ), public :: reset_all !! Reset all timers in watch. procedure , pass ( self ), public :: enumerate !! Print summary of registered timers and their current status. procedure , pass ( self ), public :: get_called !! Get the number and names of timer called (locally or globally) procedure , pass ( self ), public :: initialize !! Set up private timers, flags and counters. Switch on timing. procedure , pass ( self ), public :: finalize !! Gather timing information and print it to screen/logfile. procedure ( abstract_set_timers ), pass ( self ), deferred , public :: set_private_timers_and_name !! Define private timers that cannot be removed by the user. end type abstract_watch abstract interface subroutine abstract_set_timers ( self ) !! Interface for defining timers and groups. import abstract_watch implicit none ( type , external ) class ( abstract_watch ), intent ( inout ) :: self end subroutine abstract_set_timers end interface ! format strings for uniform printing character ( len = 128 ), parameter :: fmt_h = '(2X,A30,\" : \",  10X,A9,4(A15))' ! headers character ( len = 128 ), parameter :: fmt_t = '(2X,A30,\" : \",A6,4X,I9,4(1X,F14.6))' ! data total character ( len = 128 ), parameter :: fmt_1 = '(2X,A30,\" : \",A6,4X,I9,1X,F14.6,3(A15))' ! data 1 call character ( len = 128 ), parameter :: fmt_r = '(2X,30X,3X,   A6,I4,I9,4(1X,F14.6))' ! data reset character ( len = 128 ), parameter :: fmt_n = '(2X,30X,3X,   A6,I4,I9,A60)' ! not called contains !-------------------------------------------------------------- !  Type-bound procedures for lightkrylov_timer type !-------------------------------------------------------------- subroutine start_timer ( self ) !! Type-bound to lightkrylov_timer: Start timer. class ( lightkrylov_timer ), intent ( inout ) :: self if (. not . self % running ) then call cpu_time ( self % start_time ) self % running = . true . self % count = self % count + 1 self % local_count = self % local_count + 1 end if end subroutine start_timer subroutine stop_timer ( self ) !! Type-bound to lightkrylov_timer: Stop timer. class ( lightkrylov_timer ), intent ( inout ) :: self ! internal real ( dp ) :: t_now , etime call cpu_time ( t_now ) if ( self % running ) then etime = t_now - self % start_time self % etime = self % etime + etime + self % etime_pause self % etime_pause = 0.0_dp self % etime_min = min ( self % etime_min , etime ) self % etime_max = max ( self % etime_max , etime ) self % running = . false . end if end subroutine stop_timer subroutine pause_timer ( self ) !! Type-bound to lightkrylov_timer: Pause timer. class ( lightkrylov_timer ), intent ( inout ) :: self ! internal real ( dp ) :: t_now call cpu_time ( t_now ) if ( self % running ) then self % etime_pause = self % etime_pause + ( t_now - self % start_time ) self % running = . false . end if end subroutine pause_timer subroutine save_timer_data ( self ) !! Type-bound to lightkrylov_timer: Save current timing information. !! Note: This is done irrespective of the call/run status of the timer. class ( lightkrylov_timer ), intent ( inout ) :: self if ( self % reset_count == 0 ) then allocate ( self % etime_data ( 1 )) allocate ( self % etmin_data ( 1 )) allocate ( self % etmax_data ( 1 )) allocate ( self % etavg_data ( 1 )) allocate ( self % count_data ( 1 )) if ( self % local_count > 0 ) then self % etime_data ( 1 ) = self % etime self % etmin_data ( 1 ) = self % etime_min self % etmax_data ( 1 ) = self % etime_max self % etavg_data ( 1 ) = self % etime / self % local_count self % count_data ( 1 ) = self % local_count else self % etime_data ( 1 ) = 0.0_dp self % etavg_data ( 1 ) = 0.0_dp self % etmin_data ( 1 ) = 0.0_dp self % etmax_data ( 1 ) = 0.0_dp self % count_data ( 1 ) = 0 end if self % reset_count = 1 else if ( self % local_count > 0 ) then self % etime_data = [ self % etime_data , self % etime ] self % etmin_data = [ self % etmin_data , self % etime_min ] self % etmax_data = [ self % etmax_data , self % etime_max ] self % etavg_data = [ self % etavg_data , self % etime / self % local_count ] self % count_data = [ self % count_data , self % local_count ] else self % etime_data = [ self % etime_data , 0.0_dp ] self % etmin_data = [ self % etmin_data , 0.0_dp ] self % etmax_data = [ self % etmax_data , 0.0_dp ] self % etavg_data = [ self % etavg_data , 0.0_dp ] self % count_data = [ self % count_data , 0 ] end if self % reset_count = self % reset_count + 1 end if end subroutine save_timer_data subroutine reset_timer ( self , soft , clean , verbose ) !! Type-bound to lightkrylov_timer: Reset timer. class ( lightkrylov_timer ), intent ( inout ) :: self logical , optional , intent ( in ) :: soft !! Save timing data and reset only if data was collected (i.e. timer was called), default = .true. logical , optional , intent ( in ) :: clean !! Flush timing data as well as previously saved timing data, default = .false. logical , optional , intent ( in ) :: verbose !! Always print information about the reset process. ! internal logical :: save_data , flush_timer , print_info character ( len = 128 ) :: msg save_data = optval ( soft , . true .) flush_timer = optval ( clean , . false .) print_info = optval ( verbose , . false .) if ( self % running ) then write ( msg , '(A)' ) 'Timer \"' // trim ( self % name ) // '\" is curently running. Timer not reset.' call log_message ( msg , this_module , 'reset_timer' ) else write ( msg , '(A,L1,3X,A,L1)' ) 'soft reset: ' , save_data , 'flush timers: ' , flush_timer if ( print_info ) then call log_message ( msg , this_module , self % name ) else call log_debug ( msg , this_module , self % name ) end if if ( save_data . and . . not . flush_timer ) then if ( self % local_count > 0 ) then call self % save_timer_data () self % etime = 0.0_dp self % etime_pause = 0.0_dp self % start_time = 0.0_dp self % etime_min = huge ( 1.0_dp ) self % etime_max = 0.0_dp self % running = . false . self % local_count = 0 end if else ! hard reset self % etime = 0.0_dp self % etime_pause = 0.0_dp self % etime_min = huge ( 1.0_dp ) self % etime_max = 0.0_dp self % start_time = 0.0_dp self % running = . false . self % local_count = 0 self % reset_count = 0 if ( allocated ( self % etime_data )) deallocate ( self % etime_data ) if ( allocated ( self % etmin_data )) deallocate ( self % etmin_data ) if ( allocated ( self % etmax_data )) deallocate ( self % etmax_data ) if ( allocated ( self % etavg_data )) deallocate ( self % etavg_data ) if ( allocated ( self % count_data )) deallocate ( self % count_data ) end if if ( flush_timer ) then self % count = 0 self % is_finalized = . false . end if end if end subroutine reset_timer real ( dp ) function get_timer_etime ( self , restart ) result ( etime ) !! Type-bound to lightkrylov_timer: Getter routine to return the current timer etime. !! Note: If it is running, the timer is stopped. class ( lightkrylov_timer ), intent ( inout ) :: self logical , intent ( in ), optional :: restart ! internal logical :: restart_timer restart_timer = optval ( restart , . false .) if ( self % running ) call self % stop () etime = self % etime if ( restart_timer ) call self % start () end function get_timer_etime subroutine get_timer_data ( self , restart , etime , etmin , etmax , etimp , lcount , rcount , gcount ) !! Type-bound to lightkrylov_timer: Getter routine to return the timer data. !! Note: If it is running, the timer is stopped. class ( lightkrylov_timer ), intent ( inout ) :: self logical , optional , intent ( in ) :: restart real ( dp ), optional , intent ( out ) :: etime real ( dp ), optional , intent ( out ) :: etmin real ( dp ), optional , intent ( out ) :: etmax real ( dp ), optional , intent ( out ) :: etimp integer , optional , intent ( out ) :: lcount integer , optional , intent ( out ) :: rcount integer , optional , intent ( out ) :: gcount ! internal logical :: restart_timer restart_timer = optval ( restart , . false .) if ( self % running ) call self % stop () if ( present ( etime )) etime = self % etime if ( present ( etmin )) etmin = self % etime_min if ( present ( etmax )) etmax = self % etime_max if ( present ( etimp )) etimp = self % etime_pause if ( present ( lcount )) lcount = self % local_count if ( present ( rcount )) rcount = self % reset_count if ( present ( gcount )) gcount = self % count if ( restart_timer ) call self % start () end subroutine get_timer_data subroutine get_timer_data_save ( self , timed , countd ) !! Type-bound to lightkrylov_timer: Getter routine to return the timer data. !! Note: If it is running, the timer is NOT stopped. class ( lightkrylov_timer ), intent ( inout ) :: self real ( dp ), allocatable , intent ( out ) :: timed (:,:) !! time information integer , allocatable , intent ( out ) :: countd (:) !! Count information ! internal integer :: i , n n = size ( self % etime_data ) allocate ( timed ( n , 4 )) allocate ( countd ( n )) do i = 1 , n timed ( i , :) = [ self % etime_data ( i ), self % etmin_data ( i ), self % etmax_data ( i ), self % etavg_data ( i ) ] end do countd = self % count_data end subroutine get_timer_data_save subroutine print_timer_info ( self ) !! Type-bound to lightkrylov_timer: Compute simple statistics and print timing information to screen. class ( lightkrylov_timer ), intent ( inout ) :: self ! internal character ( len = 128 ) :: msg call log_message ( '#########        Timer info        ##########' , this_module ) if ( self % count == 0 ) then write ( msg , '(A)' ) 'No timing data available for \"' // trim ( self % name ) // '\": Timer not called.' call log_message ( msg , this_module ) else call print_summary_header ( 'Summary' , self % name ) if (. not . self % is_finalized ) then call self % save_timer_data () else ! is_finalized if ( self % reset_count == 0 ) then call stop_error ( trim ( self % name ) // ': reset_count inconsistent!' , this_module , 'finalize_timer' ) end if end if call print_summary ( self ) end if end subroutine print_timer_info subroutine finalize_timer ( self , if_silent ) !! Type-bound to lightkrylov_timer: Prepare timer summary. class ( lightkrylov_timer ), intent ( inout ) :: self logical , optional , intent ( in ) :: if_silent !! No output ! internal logical :: silent character ( len = 128 ) :: msg silent = optval ( if_silent , . false .) call self % stop () call self % save_timer_data () self % is_finalized = . true . if (. not . silent ) then write ( msg , '(*(A))' ) trim ( self % name ), ' finalization complete.' call log_message ( msg , this_module ) call self % print_info () end if end subroutine finalize_timer !-------------------------------------------------------------- !  Type-bound procedures for abstract_watch type !-------------------------------------------------------------- subroutine add_timer ( self , name , start , count ) !! Type-bound to abstract_watch: Add timer to watch and optionally start it immediately. !! Note: The new timer name must be unique. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name logical , optional , intent ( in ) :: start integer , optional , intent ( out ) :: count ! internal logical :: start_ character ( len = 128 ) :: msg , tname start_ = optval ( start , . false .) tname = to_lower ( name ) if ( self % timer_count == 0 ) then allocate ( self % timers ( 1 )) self % timers ( 1 ) = lightkrylov_timer ( tname ) self % timer_count = 1 else if ( self % get_timer_id ( name ) > 0 ) call element_exists ( tname , 'Timer' , 'add_timer' ) self % timers = [ self % timers , lightkrylov_timer ( tname )] self % timer_count = self % timer_count + 1 if ( self % user_mode ) self % user_count = self % user_count + 1 end if write ( msg , '(A,I0)' ) 'Timer \"' // trim ( tname ) // '\" added: timer_count: ' , self % timer_count call log_debug ( msg , this_module ) if ( present ( count )) count = self % timer_count if ( start_ ) call self % start ( tname ) end subroutine add_timer subroutine remove_timer ( self , name , count ) !! Type-bound to abstract_watch: Remove timer from watch. !! Note: Timers considered private (defined during initialisation) cannot be removed. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name integer , optional , intent ( out ) :: count ! internal type ( lightkrylov_timer ), dimension (:), allocatable :: new_timers character ( len = 128 ) :: msg , tname integer :: id tname = to_lower ( name ) id = self % get_timer_id ( tname ) if ( id == 0 ) call timer_not_found ( tname , 'remove_timer' ) if ( id <= self % private_count ) then write ( msg , '(A)' ) 'Cannot remove private timer \"' // trim ( tname ) // '\". Do nothing.' call log_message ( msg , this_module , 'remove_timer' ) else self % timer_count = self % timer_count - 1 allocate ( new_timers ( self % timer_count )) new_timers ( 1 : id - 1 ) = self % timers ( 1 : id - 1 ) new_timers ( id :) = self % timers ( id + 1 :) deallocate ( self % timers ) self % timers = new_timers write ( msg , '(A,I0)' ) 'Timer \"' // trim ( tname ) // '\" removed: timer_count: ' , self % timer_count call log_debug ( msg , this_module , 'remove_timer' ) end if if ( present ( count )) count = self % timer_count end subroutine remove_timer subroutine add_group ( self , name , istart , iend , count ) !! Type-bound to abstract_watch: Add timer group to watch. !! Note: The new group name must be unique. This is a quick hack and should be done better. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: istart integer , intent ( in ) :: iend integer , optional , intent ( out ) :: count ! internal character ( len =* ), parameter :: this_procedure = 'add_group' character ( len = 128 ) :: msg , gname ! Sanity checks if ( istart < 1 . or . iend < 1 ) then call stop_error ( 'Inconsistent input for istart, iend.' , this_module , this_procedure ) else if ( istart > iend ) then call stop_error ( 'istart > iend.' , this_module , this_procedure ) else if ( iend > self % timer_count ) then call stop_error ( 'iend > timer_count.' , this_module , this_procedure ) end if gname = to_lower ( name ) if ( self % group_count == 0 ) then allocate ( self % groups ( 1 )) self % groups ( 1 ) = lightkrylov_timer_group ( name = gname , istart = istart , iend = iend ) self % group_count = 1 else if ( self % get_group_id ( name ) > 0 ) call element_exists ( gname , 'Group' , this_module ) self % groups = [ self % groups , lightkrylov_timer_group ( name = gname , istart = istart , iend = iend )] self % group_count = self % group_count + 1 end if write ( msg , '(A,I0)' ) 'Timer group \"' // trim ( gname ) // '\" added: group_count: ' , self % group_count call log_debug ( msg , this_module ) if ( present ( count )) count = self % group_count end subroutine add_group integer function get_timer_id ( self , name ) result ( id ) !! Type-bound to abstract_watch: Getter routine to return the timer id based on name. class ( abstract_watch ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name !! Timer name ! internal integer :: i id = 0 do i = 1 , self % timer_count if ( self % timers ( i )% name == to_lower ( name )) id = i end do end function get_timer_id integer function get_group_id ( self , name ) result ( id ) !! Type-bound to abstract_watch: Getter routine to return the group id based on name. class ( abstract_watch ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name !! Timer name ! internal integer :: i id = 0 do i = 1 , self % group_count if ( self % groups ( i )% name == to_lower ( name )) id = i end do end function get_group_id subroutine set_watch_name ( self , name ) !! Type-bound to abstract_watch: Set name of watch class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name !! Watch name self % name = name end subroutine set_watch_name subroutine start_timer_by_name ( self , name ) !! Type-bound to abstract_watch: Start timer referenced by name. !! Note: Wrapper of the corresponding routine from lightkrylov_timer. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name ! internal integer :: id character ( len = 128 ) :: tname tname = to_lower ( name ) id = self % get_timer_id ( tname ) if ( id == 0 ) call timer_not_found ( tname , 'start_timer_by_name' ) call self % timers ( id )% start () call log_debug ( 'Timer \"' // trim ( tname ) // '\" started.' , this_module , self % name ) end subroutine start_timer_by_name subroutine stop_timer_by_name ( self , name ) !! Type-bound to abstract_watch: Stop timer referenced by name. !! Note: Wrapper of the corresponding routine from lightkrylov_timer. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name ! internal integer :: id character ( len = 128 ) :: tname tname = to_lower ( name ) id = self % get_timer_id ( tname ) if ( id == 0 ) call timer_not_found ( tname , 'stop_timer_by_name' ) call self % timers ( id )% stop () call log_debug ( 'Timer \"' // trim ( tname ) // '\" stopped.' , this_module , self % name ) end subroutine stop_timer_by_name subroutine pause_timer_by_name ( self , name ) !! Type-bound to abstract_watch: Pause timer referenced by name. !! Note: Wrapper of the corresponding routine from lightkrylov_timer. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name ! internal integer :: id character ( len = 128 ) :: tname tname = to_lower ( name ) id = self % get_timer_id ( tname ) if ( id == 0 ) call timer_not_found ( tname , 'pause_timer_by_name' ) call self % timers ( id )% pause () call log_debug ( 'Timer \"' // trim ( tname ) // '\" paused.' , this_module , self % name ) end subroutine pause_timer_by_name subroutine reset_timer_by_name ( self , name , soft , clean ) !! Type-bound to abstract_watch: Reset timer referenced by name. !! Note: Wrapper of the corresponding routine from lightkrylov_timer. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name logical , optional , intent ( in ) :: soft logical , optional , intent ( in ) :: clean ! internal integer :: id character ( len = 128 ) :: tname tname = to_lower ( name ) id = self % get_timer_id ( tname ) if ( id == 0 ) call timer_not_found ( tname , 'reset_timer_by_name' ) call self % timers ( id )% reset ( soft , clean ) end subroutine reset_timer_by_name real ( dp ) function get_timer_etime_by_name ( self , name , restart ) result ( etime ) !! Type-bound to abstract_watch: Getter routine to return the current etime for timer referenced by name. !! Notes: Wrapper of the corresponding routine from lightkrylov_timer. !!        If it is running, the timer is stopped. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name logical , intent ( in ), optional :: restart ! internal integer :: id character ( len = 128 ) :: tname tname = to_lower ( name ) id = self % get_timer_id ( tname ) if ( id == 0 ) call timer_not_found ( tname , 'get_timer_etime_by_name' ) etime = self % timers ( id )% get_time ( restart ) end function get_timer_etime_by_name subroutine get_timer_data_by_name ( self , name , restart , etime , etmin , etmax , etimp , lcount , rcount , gcount ) !! Type-bound to abstract_watch: Getter routine to return the data for timer referenced by name. !! Notes: Wrapper of the corresponding routine from lightkrylov_timer. !!        If it is running, the timer is stopped. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name logical , optional , intent ( in ) :: restart real ( dp ), optional , intent ( out ) :: etime real ( dp ), optional , intent ( out ) :: etmin real ( dp ), optional , intent ( out ) :: etmax real ( dp ), optional , intent ( out ) :: etimp integer , optional , intent ( out ) :: lcount integer , optional , intent ( out ) :: rcount integer , optional , intent ( out ) :: gcount ! internal integer :: id character ( len = 128 ) :: tname tname = to_lower ( name ) id = self % get_timer_id ( tname ) if ( id == 0 ) then call timer_not_found ( tname , 'get_timer_data_by_name' ) else call self % timers ( id )% get_data ( restart , etime , etmin , etmax , etimp , lcount , rcount , gcount ) end if end subroutine get_timer_data_by_name subroutine get_timer_data_save_by_name ( self , name , timed , countd ) !! Type-bound to abstract_watch: Getter routine to return the timer data referenced by name. !! Notes: Wrapper of the corresponding routine from lightkrylov_timer. !!        If it is running, the timer is NOT stopped. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name real ( dp ), allocatable , intent ( out ) :: timed (:,:) !! time information integer , allocatable , intent ( out ) :: countd (:) !! Count information ! internal integer :: id character ( len = 128 ) :: tname tname = to_lower ( name ) id = self % get_timer_id ( tname ) if ( id == 0 ) then call timer_not_found ( tname , 'get_timer_data_save_by_name' ) else call self % timers ( id )% get_data_save ( timed , countd ) end if end subroutine get_timer_data_save_by_name subroutine print_timer_info_by_name ( self , name ) !! Type-bound to abstract_watch: Print timing information for timer referenced by name. !! Note: Wrapper of the corresponding routine from lightkrylov_timer. class ( abstract_watch ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name ! internal integer :: id character ( len = 128 ) :: tname tname = to_lower ( name ) id = self % get_timer_id ( tname ) if ( id == 0 ) then call timer_not_found ( tname , 'print_timer_info_by_name' ) else call self % timers ( id )% print_info () end if end subroutine print_timer_info_by_name subroutine reset_all ( self , soft , clean ) !! Type-bound to abstract_watch: Utility function to reset all timers at once. !! Note: Wrapper of the corresponding routine from lightkrylov_timer. class ( abstract_watch ), intent ( inout ) :: self logical , optional , intent ( in ) :: soft logical , optional , intent ( in ) :: clean ! internal integer :: i logical :: soft_ logical :: clean_ character ( len = 128 ) :: msg soft_ = optval ( soft , . true .) clean_ = optval ( clean , . false .) do i = 1 , self % timer_count call self % timers ( i )% reset ( soft , clean , verbose = . false .) end do write ( msg , '(A,2(A,I0))' ) 'All timers reset: ' , 'private: ' , self % private_count , & & ', user: ' , self % user_count call log_message ( msg , this_module , self % name ) write ( msg , '(A,L,3X,A,L)' ) 'soft reset: ' , soft_ , 'flush timers: ' , clean_ call log_message ( msg , this_module , self % name ) end subroutine reset_all subroutine enumerate ( self , only_user ) !! Type-bound to abstract_watch: Summarize registered timers and their status. class ( abstract_watch ), intent ( in ) :: self logical , optional , intent ( in ) :: only_user !! Summarize only user defined timers? default: .false. ! internal integer :: i , j logical :: only_user_ character ( len = 128 ) :: msg , fmt_e fmt_e = '(2X,I3,A50,\" :\",3(1X,I0))' only_user_ = optval ( only_user , . false .) if (. not . only_user_ ) then call log_message ( 'Registered timers: all' , this_module , self % name ) do i = 1 , self % group_count call log_message ( trim ( self % groups ( i )% name ) // \":\" , this_module ) do j = self % groups ( i )% istart , self % groups ( i )% iend associate ( t => self % timers ( j )) write ( msg , fmt_e ) j , trim ( t % name ), t % count , t % local_count , t % reset_count call log_message ( msg , this_module ) end associate end do end do end if if ( self % user_count > 0 ) then call log_message ( 'Registered timers: user' , this_module , self % name ) do i = self % private_count + 1 , self % timer_count associate ( t => self % timers ( i )) write ( msg , fmt_e ) i , trim ( t % name ), t % count , t % local_count , t % reset_count call log_message ( msg , this_module ) end associate end do end if end subroutine enumerate subroutine get_called ( self , n_called , names , only_user , check_global ) !! Type-bound to abstract_watch: Get number and names of called timers class ( abstract_watch ), intent ( inout ) :: self !! Watch integer , intent ( out ) :: n_called !! number of claled times character ( len = 128 ), allocatable , intent ( out ) :: names (:) !! names of called timers logical , optional , intent ( in ) :: only_user !! Check only for user defined timers? Default: .false. logical , optional , intent ( in ) :: check_global !! Check for global call? Default: .false. ! internal character ( len =* ), parameter :: this_procedure = 'get_called' logical :: only_user_ , check_global_ integer :: i , istart , iend integer :: lcount , gcount , count integer , dimension (:), allocatable :: ic character ( len = 128 ) :: msg only_user_ = optval ( only_user , . false .) check_global_ = optval ( check_global , . false .) ! find number of called timers n_called = 0 istart = 1 if ( only_user_ ) istart = self % private_count + 1 iend = self % timer_count do i = istart , iend call self % timers ( i )% get_data ( lcount = lcount , gcount = gcount ) count = merge ( lcount , gcount , check_global_ ) if ( lcount > 0 ) then if ( n_called == 0 ) then allocate ( ic ( 1 )); ic ( 1 ) = i else ic = [ ic , i ] end if n_called = n_called + 1 end if end do allocate ( names ( n_called )) do i = 1 , n_called names ( i ) = self % timers ( ic ( i ))% name end do write ( msg , '(A,I0,A)' ) 'Found a total of ' , n_called , ' timers that have been called at least once.' call log_information ( msg , this_module , this_procedure ) end subroutine get_called subroutine initialize ( self ) !! Initialize global watch within LightKrylov and define private system timers. class ( abstract_watch ), intent ( inout ) :: self ! internal integer :: i , count character ( len = 128 ) :: msg if (. not . self % is_initialized ) then call self % set_private_timers_and_name () self % private_count = self % timer_count write ( msg , '(2(I0,A))' ) self % private_count , ' private timers registered in ' , self % group_count , ' groups:' call log_information ( msg , this_module , self % name ) do i = 1 , self % group_count count = self % groups ( i )% iend - self % groups ( i )% istart + 1 write ( msg , '(3X,A20,\" : \",I3,\" timers.\")' ) self % groups ( i )% name , count call log_information ( msg , this_module , self % name ) end do self % is_initialized = . true . else ! If the system timers have already been defined, we want to flush the data. call self % reset_all ( soft = . false .) write ( msg , '(3X,I4,A)' ) self % private_count , ' private timers registered and fully reset.' call log_information ( msg , this_module , self % name ) if ( self % user_count > 0 ) then write ( msg , '(3X,I4,A)' ) self % user_count , ' user defined timers registered and fully reset.' call log_information ( msg , this_module , self % name ) end if end if ! All subsequent timers that are added are user defined. self % user_mode = . true . call log_message ( 'Private timer initialization complete.' , this_module , self % name ) end subroutine initialize subroutine finalize ( self , write_to_file ) !! Finalize global watch within LightKrylov and print used timers. class ( abstract_watch ), intent ( inout ) :: self logical , optional , intent ( in ) :: write_to_file !! Print timer summary to a dedicated timer logfile as well as the general log file? default: .true. ! internal integer :: i , j , icalled , ic_user , tmr_unit integer , dimension (:), allocatable :: ic logical :: to_file character ( len = 128 ) :: msg , logfile_tmr to_file = optval ( write_to_file , . true .) if ( to_file ) then write ( logfile_tmr , '(A,A)' ) trim ( to_lower ( self % name )), '.log' call logger % add_log_file ( logfile_tmr , tmr_unit , status = 'replace' , action = 'write' ) end if icalled = 0 allocate ( ic ( self % group_count )) do i = 1 , self % timer_count call self % timers ( i )% finalize ( if_silent = . true .) if ( self % timers ( i )% count > 0 ) icalled = icalled + 1 do j = 1 , self % group_count if ( i == self % groups ( j )% iend ) then ic ( j ) = icalled icalled = 0 end if end do end do ic_user = icalled call log_message ( 'Timer finalization complete.' , this_module , self % name ) call log_message ( '#########   Global timer summary   ##########' , this_module ) call log_message ( 'Overview:' , this_module , self % name ) write ( msg , '(2X,A60,I5)' ) 'Total active timers:' , self % timer_count call log_message ( msg , this_module ) write ( msg , '(2X,A60,I5)' ) 'User defined:' , self % user_count call log_message ( msg , this_module ) write ( msg , '(2X,A60,I5)' ) 'Called timers:' , sum ( ic ) + ic_user call log_message ( msg , this_module ) do i = 1 , self % group_count if ( ic ( i ) > 0 ) then associate ( g => self % groups ( i )) call print_summary_header ( g % name , self % name ) do j = g % istart , g % iend call print_summary ( self % timers ( j )) end do end associate end if end do if ( self % user_count > 0 . and . ic_user > 0 ) then call print_summary_header ( 'User-defined' , self % name ) do i = self % private_count + 1 , self % timer_count call print_summary ( self % timers ( i )) end do end if call logger % log_message ( '#########   Global timer summary   ##########' , this_module ) if ( to_file ) call logger % remove_log_unit ( tmr_unit , close_unit = . true .) end subroutine finalize !-------------------------------------------------------------- !  Helper subroutines for pretty output !-------------------------------------------------------------- subroutine print_summary_header ( section_name , watch_name ) !! Print section headers for the private and user defined timers. character ( len =* ), intent ( in ) :: section_name character ( len =* ), intent ( in ) :: watch_name ! internal character ( len = 128 ) :: msg call log_message ( trim ( section_name ) // ':' , this_module , watch_name ) write ( msg , fmt_h ) 'name' , 'calls' , 'total (s)' , 'avg (s)' , 'min (s)' , 'max (s)' call log_message ( msg , this_module ) call log_message ( '_____________________________________________' , this_module ) end subroutine print_summary_header subroutine print_summary ( t ) !! Print the full timer summary class ( lightkrylov_timer ), intent ( in ) :: t ! internal integer :: i , count , count2 real ( dp ) :: etime , etavg , etmin , etmax character ( len = 128 ) :: msg count = sum ( t % count_data ) count2 = 0 etmin = huge ( 0.0_dp ) etmax = 0.0_dp do i = 1 , t % reset_count if ( t % count_data ( i ) > 0 ) then count2 = count2 + 1 etmin = min ( etmin , t % etmin_data ( i )) etmax = max ( etmax , t % etmax_data ( i )) end if end do if ( count == 1 ) then write ( msg , fmt_1 ) trim ( t % name ), 'total' , count , t % etime_data ( 1 ), '-' , '-' , '-' call log_message ( msg , this_module ) else if ( count > 1 ) then etime = sum ( t % etime_data ) etavg = sum ( t % etavg_data ) / count2 write ( msg , fmt_t ) trim ( t % name ), 'total' , count , etime , etavg , etmin , etmax call log_message ( msg , this_module ) if ( t % reset_count > 1 ) then do i = 1 , t % reset_count etime = t % etime_data ( i ) etmin = t % etmin_data ( i ) etmax = t % etmax_data ( i ) etavg = t % etavg_data ( i ) count = t % count_data ( i ) if ( count > 0 ) then write ( msg , fmt_r ) 'reset' , i , count , etime , etavg , etmin , etmax else write ( msg , fmt_n ) 'reset' , i , count , 'not called' end if call log_message ( msg , this_module ) end do end if end if end subroutine print_summary !-------------------------------------------------------------- !  Helper subroutines for error handling !-------------------------------------------------------------- subroutine timer_not_found ( name , procedure ) character ( len =* ), intent ( in ) :: name character ( len =* ), optional , intent ( in ) :: procedure call stop_error ( 'Timer \"' // trim ( name ) // '\" not found!' , this_module , procedure ) end subroutine timer_not_found subroutine element_exists ( name , element , procedure ) character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: element character ( len =* ), optional , intent ( in ) :: procedure call stop_error ( trim ( element ) // ' \"' // trim ( name ) // '\" already defined!' , this_module , procedure ) end subroutine element_exists end module LightKrylov_Timer_Utils","tags":"","url":"sourcefile/timer_utils.f90.html"},{"title":"qr.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_basekrylov ) qr_solvers implicit none ( type , external ) interface swap_columns module subroutine swap_columns_rsp ( Q , R , Rii , perm , i , j ) implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( inout ) :: Q (:) !! Vector basis whose i-th and j-th columns need swapping. real ( sp ), intent ( inout ) :: R (:, :) !! Upper triangular matrix resulting from QR. real ( sp ), intent ( inout ) :: Rii (:) !! Diagonal entries of R. integer , intent ( inout ) :: perm (:) !! Column ordering. integer , intent ( in ) :: i , j !! Index of the columns to be swapped. end subroutine swap_columns_rsp module subroutine swap_columns_rdp ( Q , R , Rii , perm , i , j ) implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( inout ) :: Q (:) !! Vector basis whose i-th and j-th columns need swapping. real ( dp ), intent ( inout ) :: R (:, :) !! Upper triangular matrix resulting from QR. real ( dp ), intent ( inout ) :: Rii (:) !! Diagonal entries of R. integer , intent ( inout ) :: perm (:) !! Column ordering. integer , intent ( in ) :: i , j !! Index of the columns to be swapped. end subroutine swap_columns_rdp module subroutine swap_columns_csp ( Q , R , Rii , perm , i , j ) implicit none ( type , external ) class ( abstract_vector_csp ), intent ( inout ) :: Q (:) !! Vector basis whose i-th and j-th columns need swapping. complex ( sp ), intent ( inout ) :: R (:, :) !! Upper triangular matrix resulting from QR. complex ( sp ), intent ( inout ) :: Rii (:) !! Diagonal entries of R. integer , intent ( inout ) :: perm (:) !! Column ordering. integer , intent ( in ) :: i , j !! Index of the columns to be swapped. end subroutine swap_columns_csp module subroutine swap_columns_cdp ( Q , R , Rii , perm , i , j ) implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( inout ) :: Q (:) !! Vector basis whose i-th and j-th columns need swapping. complex ( dp ), intent ( inout ) :: R (:, :) !! Upper triangular matrix resulting from QR. complex ( dp ), intent ( inout ) :: Rii (:) !! Diagonal entries of R. integer , intent ( inout ) :: perm (:) !! Column ordering. integer , intent ( in ) :: i , j !! Index of the columns to be swapped. end subroutine swap_columns_cdp end interface contains !------------------------------------ !-----     QR WITH PIVOTING     ----- !------------------------------------ module procedure qr_with_pivoting_rsp character ( len =* ), parameter :: this_procedure = 'qr_with_pivoting_rsp' real ( sp ) :: tolerance real ( sp ) :: beta integer :: idx , i , j , kdim integer :: idxv ( 1 ) real ( sp ) :: Rii ( size ( Q )) character ( len = 128 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ; kdim = size ( Q ) ; R = zero_rsp ! Deals with the optional arguments. tolerance = optval ( tol , atol_sp ) ! Initialize diagonal entries. do i = 1 , kdim perm ( i ) = i Rii ( i ) = Q ( i )% dot ( Q ( i )) enddo qr_step : do j = 1 , kdim idxv = maxloc ( abs ( Rii )) ; idx = idxv ( 1 ) if ( abs ( Rii ( idx )) < tolerance ) then do i = j , kdim call Q ( i )% rand () call double_gram_schmidt_step ( Q ( i ), Q (: i - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) beta = Q ( i )% norm (); call Q ( i )% scal ( one_rsp / beta ) enddo info = j write ( msg , '(A,I0,A,E15.8)' ) 'Breakdown after ' , j , ' steps. R_ii= ' , abs ( Rii ( idx )) call log_information ( msg , this_module , this_procedure ) exit qr_step endif call swap_columns ( Q , R , Rii , perm , j , idx ) ! Check for breakdown. beta = Q ( j )% norm () if ( isnan ( beta )) call stop_error ( '|beta| = NaN detected! Abort' , this_module , this_procedure ) if ( abs ( beta ) < tolerance ) then info = j R ( j , j ) = zero_rsp call Q ( j )% rand () call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rsp / beta ) ! Orthogonalize all columns against new vector. do i = j + 1 , kdim beta = Q ( j )% dot ( Q ( i )) call Q ( i )% axpby ( - beta , Q ( j ), one_rsp ) ! Q(i) = Q(i) - beta*Q(j) R ( j , i ) = beta enddo ! Update Rii. Rii ( j ) = zero_rsp do i = j + 1 , kdim Rii ( i ) = Rii ( i ) - R ( j , i ) ** 2 enddo enddo qr_step if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure qr_with_pivoting_rsp module procedure qr_with_pivoting_rdp character ( len =* ), parameter :: this_procedure = 'qr_with_pivoting_rdp' real ( dp ) :: tolerance real ( dp ) :: beta integer :: idx , i , j , kdim integer :: idxv ( 1 ) real ( dp ) :: Rii ( size ( Q )) character ( len = 128 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ; kdim = size ( Q ) ; R = zero_rdp ! Deals with the optional arguments. tolerance = optval ( tol , atol_dp ) ! Initialize diagonal entries. do i = 1 , kdim perm ( i ) = i Rii ( i ) = Q ( i )% dot ( Q ( i )) enddo qr_step : do j = 1 , kdim idxv = maxloc ( abs ( Rii )) ; idx = idxv ( 1 ) if ( abs ( Rii ( idx )) < tolerance ) then do i = j , kdim call Q ( i )% rand () call double_gram_schmidt_step ( Q ( i ), Q (: i - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) beta = Q ( i )% norm (); call Q ( i )% scal ( one_rdp / beta ) enddo info = j write ( msg , '(A,I0,A,E15.8)' ) 'Breakdown after ' , j , ' steps. R_ii= ' , abs ( Rii ( idx )) call log_information ( msg , this_module , this_procedure ) exit qr_step endif call swap_columns ( Q , R , Rii , perm , j , idx ) ! Check for breakdown. beta = Q ( j )% norm () if ( isnan ( beta )) call stop_error ( '|beta| = NaN detected! Abort' , this_module , this_procedure ) if ( abs ( beta ) < tolerance ) then info = j R ( j , j ) = zero_rdp call Q ( j )% rand () call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rdp / beta ) ! Orthogonalize all columns against new vector. do i = j + 1 , kdim beta = Q ( j )% dot ( Q ( i )) call Q ( i )% axpby ( - beta , Q ( j ), one_rdp ) ! Q(i) = Q(i) - beta*Q(j) R ( j , i ) = beta enddo ! Update Rii. Rii ( j ) = zero_rdp do i = j + 1 , kdim Rii ( i ) = Rii ( i ) - R ( j , i ) ** 2 enddo enddo qr_step if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure qr_with_pivoting_rdp module procedure qr_with_pivoting_csp character ( len =* ), parameter :: this_procedure = 'qr_with_pivoting_csp' real ( sp ) :: tolerance complex ( sp ) :: beta integer :: idx , i , j , kdim integer :: idxv ( 1 ) complex ( sp ) :: Rii ( size ( Q )) character ( len = 128 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ; kdim = size ( Q ) ; R = zero_rsp ! Deals with the optional arguments. tolerance = optval ( tol , atol_sp ) ! Initialize diagonal entries. do i = 1 , kdim perm ( i ) = i Rii ( i ) = Q ( i )% dot ( Q ( i )) enddo qr_step : do j = 1 , kdim idxv = maxloc ( abs ( Rii )) ; idx = idxv ( 1 ) if ( abs ( Rii ( idx )) < tolerance ) then do i = j , kdim call Q ( i )% rand () call double_gram_schmidt_step ( Q ( i ), Q (: i - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) beta = Q ( i )% norm (); call Q ( i )% scal ( one_csp / beta ) enddo info = j write ( msg , '(A,I0,A,E15.8)' ) 'Breakdown after ' , j , ' steps. R_ii= ' , abs ( Rii ( idx )) call log_information ( msg , this_module , this_procedure ) exit qr_step endif call swap_columns ( Q , R , Rii , perm , j , idx ) ! Check for breakdown. beta = Q ( j )% norm () if ( isnan ( abs ( beta ))) call stop_error ( '|beta| = NaN detected! Abort' , this_module , this_procedure ) if ( abs ( beta ) < tolerance ) then info = j R ( j , j ) = zero_rsp call Q ( j )% rand () call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rsp / beta ) ! Orthogonalize all columns against new vector. do i = j + 1 , kdim beta = Q ( j )% dot ( Q ( i )) call Q ( i )% axpby ( - beta , Q ( j ), one_csp ) ! Q(i) = Q(i) - beta*Q(j) R ( j , i ) = beta enddo ! Update Rii. Rii ( j ) = zero_rsp do i = j + 1 , kdim Rii ( i ) = Rii ( i ) - R ( j , i ) ** 2 enddo enddo qr_step if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure qr_with_pivoting_csp module procedure qr_with_pivoting_cdp character ( len =* ), parameter :: this_procedure = 'qr_with_pivoting_cdp' real ( dp ) :: tolerance complex ( dp ) :: beta integer :: idx , i , j , kdim integer :: idxv ( 1 ) complex ( dp ) :: Rii ( size ( Q )) character ( len = 128 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ; kdim = size ( Q ) ; R = zero_rdp ! Deals with the optional arguments. tolerance = optval ( tol , atol_dp ) ! Initialize diagonal entries. do i = 1 , kdim perm ( i ) = i Rii ( i ) = Q ( i )% dot ( Q ( i )) enddo qr_step : do j = 1 , kdim idxv = maxloc ( abs ( Rii )) ; idx = idxv ( 1 ) if ( abs ( Rii ( idx )) < tolerance ) then do i = j , kdim call Q ( i )% rand () call double_gram_schmidt_step ( Q ( i ), Q (: i - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) beta = Q ( i )% norm (); call Q ( i )% scal ( one_cdp / beta ) enddo info = j write ( msg , '(A,I0,A,E15.8)' ) 'Breakdown after ' , j , ' steps. R_ii= ' , abs ( Rii ( idx )) call log_information ( msg , this_module , this_procedure ) exit qr_step endif call swap_columns ( Q , R , Rii , perm , j , idx ) ! Check for breakdown. beta = Q ( j )% norm () if ( isnan ( abs ( beta ))) call stop_error ( '|beta| = NaN detected! Abort' , this_module , this_procedure ) if ( abs ( beta ) < tolerance ) then info = j R ( j , j ) = zero_rdp call Q ( j )% rand () call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rdp / beta ) ! Orthogonalize all columns against new vector. do i = j + 1 , kdim beta = Q ( j )% dot ( Q ( i )) call Q ( i )% axpby ( - beta , Q ( j ), one_cdp ) ! Q(i) = Q(i) - beta*Q(j) R ( j , i ) = beta enddo ! Update Rii. Rii ( j ) = zero_rdp do i = j + 1 , kdim Rii ( i ) = Rii ( i ) - R ( j , i ) ** 2 enddo enddo qr_step if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure qr_with_pivoting_cdp !--------------------------------------------- !-----     STANDARD QR FACTORIZATION     ----- !--------------------------------------------- module procedure qr_no_pivoting_rsp character ( len =* ), parameter :: this_procedure = 'qr_no_pivoting_rsp' real ( sp ) :: tolerance real ( sp ) :: beta integer :: j logical :: flag character ( len = 128 ) :: msg ! Deals with the optional args. tolerance = optval ( tol , atol_sp ) if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ; flag = . false .; R = zero_rsp ; beta = zero_rsp do j = 1 , size ( Q ) if ( j > 1 ) then ! Double Gram-Schmidt orthogonalization call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false ., beta = R (: j - 1 , j )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) end if ! Check for breakdown. beta = Q ( j )% norm () if ( isnan ( beta )) call stop_error ( '|beta| = NaN detected! Abort' , this_module , this_procedure ) if ( abs ( beta ) < tolerance ) then if (. not . flag ) then flag = . true . info = j write ( msg , '(A,I0,A,E15.8)' ) 'Colinear column detected after ' , j , ' steps. beta= ' , abs ( beta ) call log_information ( msg , this_module , this_procedure ) end if R ( j , j ) = zero_rsp call Q ( j )% rand () if ( j > 1 ) then call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) end if beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rsp / beta ) enddo if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure qr_no_pivoting_rsp module procedure qr_no_pivoting_rdp character ( len =* ), parameter :: this_procedure = 'qr_no_pivoting_rdp' real ( dp ) :: tolerance real ( dp ) :: beta integer :: j logical :: flag character ( len = 128 ) :: msg ! Deals with the optional args. tolerance = optval ( tol , atol_dp ) if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ; flag = . false .; R = zero_rdp ; beta = zero_rdp do j = 1 , size ( Q ) if ( j > 1 ) then ! Double Gram-Schmidt orthogonalization call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false ., beta = R (: j - 1 , j )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) end if ! Check for breakdown. beta = Q ( j )% norm () if ( isnan ( beta )) call stop_error ( '|beta| = NaN detected! Abort' , this_module , this_procedure ) if ( abs ( beta ) < tolerance ) then if (. not . flag ) then flag = . true . info = j write ( msg , '(A,I0,A,E15.8)' ) 'Colinear column detected after ' , j , ' steps. beta= ' , abs ( beta ) call log_information ( msg , this_module , this_procedure ) end if R ( j , j ) = zero_rdp call Q ( j )% rand () if ( j > 1 ) then call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) end if beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rdp / beta ) enddo if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure qr_no_pivoting_rdp module procedure qr_no_pivoting_csp character ( len =* ), parameter :: this_procedure = 'qr_no_pivoting_csp' real ( sp ) :: tolerance complex ( sp ) :: beta integer :: j logical :: flag character ( len = 128 ) :: msg ! Deals with the optional args. tolerance = optval ( tol , atol_sp ) if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ; flag = . false .; R = zero_rsp ; beta = zero_rsp do j = 1 , size ( Q ) if ( j > 1 ) then ! Double Gram-Schmidt orthogonalization call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false ., beta = R (: j - 1 , j )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) end if ! Check for breakdown. beta = Q ( j )% norm () if ( isnan ( abs ( beta ))) call stop_error ( '|beta| = NaN detected! Abort' , this_module , this_procedure ) if ( abs ( beta ) < tolerance ) then if (. not . flag ) then flag = . true . info = j write ( msg , '(A,I0,A,E15.8)' ) 'Colinear column detected after ' , j , ' steps. beta= ' , abs ( beta ) call log_information ( msg , this_module , this_procedure ) end if R ( j , j ) = zero_rsp call Q ( j )% rand () if ( j > 1 ) then call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) end if beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rsp / beta ) enddo if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure qr_no_pivoting_csp module procedure qr_no_pivoting_cdp character ( len =* ), parameter :: this_procedure = 'qr_no_pivoting_cdp' real ( dp ) :: tolerance complex ( dp ) :: beta integer :: j logical :: flag character ( len = 128 ) :: msg ! Deals with the optional args. tolerance = optval ( tol , atol_dp ) if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ; flag = . false .; R = zero_rdp ; beta = zero_rdp do j = 1 , size ( Q ) if ( j > 1 ) then ! Double Gram-Schmidt orthogonalization call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false ., beta = R (: j - 1 , j )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) end if ! Check for breakdown. beta = Q ( j )% norm () if ( isnan ( abs ( beta ))) call stop_error ( '|beta| = NaN detected! Abort' , this_module , this_procedure ) if ( abs ( beta ) < tolerance ) then if (. not . flag ) then flag = . true . info = j write ( msg , '(A,I0,A,E15.8)' ) 'Colinear column detected after ' , j , ' steps. beta= ' , abs ( beta ) call log_information ( msg , this_module , this_procedure ) end if R ( j , j ) = zero_rdp call Q ( j )% rand () if ( j > 1 ) then call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) end if beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rdp / beta ) enddo if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure qr_no_pivoting_cdp !------------------------------------- !-----     Utility functions     ----- !------------------------------------- module procedure swap_columns_rsp class ( abstract_vector_rsp ), allocatable :: Qwrk real ( sp ), allocatable :: Rwrk (:) integer :: iwrk , m , n , iostat character ( len = 100 ) :: errmsg ! Sanity checks. m = size ( Q ) ; n = min ( i , j ) - 1 ! Allocations. allocate ( Qwrk , mold = Q ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"swap_columns_rsp\" ) allocate ( Rwrk ( max ( 1 , n )), source = zero_rsp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"swap_columns_rsp\" ) ! Swap columns. call copy ( Qwrk , Q ( j )) call copy ( Q ( j ), Q ( i )) call copy ( Q ( i ), Qwrk ) Rwrk ( 1 ) = Rii ( j ); Rii ( j ) = Rii ( i ); Rii ( i ) = Rwrk ( 1 ) iwrk = perm ( j ); perm ( j ) = perm ( i ) ; perm ( i ) = iwrk if ( n > 0 ) then Rwrk = R (: n , j ) ; R (: n , j ) = R (: n , i ) ; R (: n , i ) = Rwrk endif end procedure swap_columns_rsp module procedure swap_columns_rdp class ( abstract_vector_rdp ), allocatable :: Qwrk real ( dp ), allocatable :: Rwrk (:) integer :: iwrk , m , n , iostat character ( len = 100 ) :: errmsg ! Sanity checks. m = size ( Q ) ; n = min ( i , j ) - 1 ! Allocations. allocate ( Qwrk , mold = Q ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"swap_columns_rdp\" ) allocate ( Rwrk ( max ( 1 , n )), source = zero_rdp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"swap_columns_rdp\" ) ! Swap columns. call copy ( Qwrk , Q ( j )) call copy ( Q ( j ), Q ( i )) call copy ( Q ( i ), Qwrk ) Rwrk ( 1 ) = Rii ( j ); Rii ( j ) = Rii ( i ); Rii ( i ) = Rwrk ( 1 ) iwrk = perm ( j ); perm ( j ) = perm ( i ) ; perm ( i ) = iwrk if ( n > 0 ) then Rwrk = R (: n , j ) ; R (: n , j ) = R (: n , i ) ; R (: n , i ) = Rwrk endif end procedure swap_columns_rdp module procedure swap_columns_csp class ( abstract_vector_csp ), allocatable :: Qwrk complex ( sp ), allocatable :: Rwrk (:) integer :: iwrk , m , n , iostat character ( len = 100 ) :: errmsg ! Sanity checks. m = size ( Q ) ; n = min ( i , j ) - 1 ! Allocations. allocate ( Qwrk , mold = Q ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"swap_columns_csp\" ) allocate ( Rwrk ( max ( 1 , n )), source = zero_csp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"swap_columns_csp\" ) ! Swap columns. call copy ( Qwrk , Q ( j )) call copy ( Q ( j ), Q ( i )) call copy ( Q ( i ), Qwrk ) Rwrk ( 1 ) = Rii ( j ); Rii ( j ) = Rii ( i ); Rii ( i ) = Rwrk ( 1 ) iwrk = perm ( j ); perm ( j ) = perm ( i ) ; perm ( i ) = iwrk if ( n > 0 ) then Rwrk = R (: n , j ) ; R (: n , j ) = R (: n , i ) ; R (: n , i ) = Rwrk endif end procedure swap_columns_csp module procedure swap_columns_cdp class ( abstract_vector_cdp ), allocatable :: Qwrk complex ( dp ), allocatable :: Rwrk (:) integer :: iwrk , m , n , iostat character ( len = 100 ) :: errmsg ! Sanity checks. m = size ( Q ) ; n = min ( i , j ) - 1 ! Allocations. allocate ( Qwrk , mold = Q ( 1 ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"swap_columns_cdp\" ) allocate ( Rwrk ( max ( 1 , n )), source = zero_cdp , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"swap_columns_cdp\" ) ! Swap columns. call copy ( Qwrk , Q ( j )) call copy ( Q ( j ), Q ( i )) call copy ( Q ( i ), Qwrk ) Rwrk ( 1 ) = Rii ( j ); Rii ( j ) = Rii ( i ); Rii ( i ) = Rwrk ( 1 ) iwrk = perm ( j ); perm ( j ) = perm ( i ) ; perm ( i ) = iwrk if ( n > 0 ) then Rwrk = R (: n , j ) ; R (: n , j ) = R (: n , i ) ; R (: n , i ) = Rwrk endif end procedure swap_columns_cdp end submodule qr_solvers","tags":"","url":"sourcefile/qr.f90.html"},{"title":"submodule_utility_functions.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_utils ) utility_functions !------------------------------- !-----     LightKrylov     ----- !------------------------------- use stdlib_optval , only : optval use stdlib_linalg_constants , only : ilp use stdlib_linalg_lapack , only : geev , trsen , lartg , lasr use stdlib_linalg , only : hermitian , svd , diag , eye , mnorm , inv , norm use LightKrylov_Timing , only : timer => global_lightkrylov_timer , time_lightkrylov implicit none ( type , external ) contains module procedure check_allocation if ( iostat /= 0 ) call stop_error ( msg , module = module , procedure = procedure ) end procedure check_allocation module procedure log2_rsp y = log ( x ) / log ( 2.0_sp ) end procedure log2_rsp module procedure log2_rdp y = log ( x ) / log ( 2.0_dp ) end procedure log2_rdp !--------------------------------------------- !-----     Shape Assertion Utilities     ----- !--------------------------------------------- module procedure assert_shape_vector_rsp if ( any ( shape ( v ) /= size )) then write ( output_unit , * ) \"Vector \" // vecname // \" has illegal length\" , shape ( v ), & & \". Expected length is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( \"Vector length assertion error\" , module , procedure ) endif end procedure assert_shape_vector_rsp module procedure assert_shape_matrix_rsp if ( any ( shape ( A ) /= size )) then write ( output_unit , * ) \"Matrix \" // matname // \" has illegal shape\" , shape ( A ), & & \". Expected shape is \" , size , \". Aborting due to illegal matrix shape.\" call stop_error ( \"Matrix shape assertion error\" , module , procedure ) endif end procedure assert_shape_matrix_rsp module procedure assert_shape_vector_rdp if ( any ( shape ( v ) /= size )) then write ( output_unit , * ) \"Vector \" // vecname // \" has illegal length\" , shape ( v ), & & \". Expected length is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( \"Vector length assertion error\" , module , procedure ) endif end procedure assert_shape_vector_rdp module procedure assert_shape_matrix_rdp if ( any ( shape ( A ) /= size )) then write ( output_unit , * ) \"Matrix \" // matname // \" has illegal shape\" , shape ( A ), & & \". Expected shape is \" , size , \". Aborting due to illegal matrix shape.\" call stop_error ( \"Matrix shape assertion error\" , module , procedure ) endif end procedure assert_shape_matrix_rdp module procedure assert_shape_vector_csp if ( any ( shape ( v ) /= size )) then write ( output_unit , * ) \"Vector \" // vecname // \" has illegal length\" , shape ( v ), & & \". Expected length is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( \"Vector length assertion error\" , module , procedure ) endif end procedure assert_shape_vector_csp module procedure assert_shape_matrix_csp if ( any ( shape ( A ) /= size )) then write ( output_unit , * ) \"Matrix \" // matname // \" has illegal shape\" , shape ( A ), & & \". Expected shape is \" , size , \". Aborting due to illegal matrix shape.\" call stop_error ( \"Matrix shape assertion error\" , module , procedure ) endif end procedure assert_shape_matrix_csp module procedure assert_shape_vector_cdp if ( any ( shape ( v ) /= size )) then write ( output_unit , * ) \"Vector \" // vecname // \" has illegal length\" , shape ( v ), & & \". Expected length is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( \"Vector length assertion error\" , module , procedure ) endif end procedure assert_shape_vector_cdp module procedure assert_shape_matrix_cdp if ( any ( shape ( A ) /= size )) then write ( output_unit , * ) \"Matrix \" // matname // \" has illegal shape\" , shape ( A ), & & \". Expected shape is \" , size , \". Aborting due to illegal matrix shape.\" call stop_error ( \"Matrix shape assertion error\" , module , procedure ) endif end procedure assert_shape_matrix_cdp !-------------------------------------------- !-----     Linear Algebra Utilities     ----- !-------------------------------------------- !----- Eigenvalue Decomposition ----- module procedure eig_rsp character ( len =* ), parameter :: this_procedure = 'eig_rsp' ! Lapack variables. character , parameter :: jobvl = \"n\" , jobvr = \"v\" integer ( ilp ) :: n , lwork , info , lda , ldvl , ldvr real ( sp ) :: A_tilde ( size ( A , 1 ), size ( A , 2 )), vl ( 1 , size ( A , 2 )) real ( sp ) :: work ( 4 * size ( A , 1 )), wr ( size ( A , 1 )), wi ( size ( A , 1 )) ! Setup variables. n = size ( A , 1 ) ; lda = n ; ldvl = 1 ; ldvr = n ; a_tilde = a lwork = 4 * n ! Eigendecomposition. call geev ( jobvl , jobvr , n , a_tilde , lda , wr , wi , vl , ldvl , vecs , ldvr , work , lwork , info ) call check_info ( info , \"GEEV\" , this_module , \"eig_rsp\" ) ! Complex eigenvalues. vals = one_csp * wr + one_im_csp * wi end procedure eig_rsp module procedure eig_rdp character ( len =* ), parameter :: this_procedure = 'eig_rdp' ! Lapack variables. character , parameter :: jobvl = \"n\" , jobvr = \"v\" integer ( ilp ) :: n , lwork , info , lda , ldvl , ldvr real ( dp ) :: A_tilde ( size ( A , 1 ), size ( A , 2 )), vl ( 1 , size ( A , 2 )) real ( dp ) :: work ( 4 * size ( A , 1 )), wr ( size ( A , 1 )), wi ( size ( A , 1 )) ! Setup variables. n = size ( A , 1 ) ; lda = n ; ldvl = 1 ; ldvr = n ; a_tilde = a lwork = 4 * n ! Eigendecomposition. call geev ( jobvl , jobvr , n , a_tilde , lda , wr , wi , vl , ldvl , vecs , ldvr , work , lwork , info ) call check_info ( info , \"GEEV\" , this_module , \"eig_rdp\" ) ! Complex eigenvalues. vals = one_cdp * wr + one_im_cdp * wi end procedure eig_rdp module procedure eig_csp character ( len =* ), parameter :: this_procedure = 'eig_csp' ! Lapack variables. character , parameter :: jobvl = \"n\" , jobvr = \"v\" integer ( ilp ) :: n , lwork , info , lda , ldvl , ldvr complex ( sp ) :: A_tilde ( size ( A , 1 ), size ( A , 2 )), vl ( 1 , size ( A , 2 )) complex ( sp ) :: work ( 2 * size ( A , 1 )) real ( sp ) :: rwork ( 2 * size ( A , 1 )) ! Setup variables. n = size ( A , 1 ) ; lda = n ; ldvl = 1 ; ldvr = n ; a_tilde = a lwork = 2 * n ! Eigendecomposition. call geev ( jobvl , jobvr , n , a_tilde , lda , vals , vl , ldvl , vecs , ldvr , work , lwork , rwork , & & info ) call check_info ( info , \"GEEV\" , this_module , \"eig_csp\" ) end procedure eig_csp module procedure eig_cdp character ( len =* ), parameter :: this_procedure = 'eig_cdp' ! Lapack variables. character , parameter :: jobvl = \"n\" , jobvr = \"v\" integer ( ilp ) :: n , lwork , info , lda , ldvl , ldvr complex ( dp ) :: A_tilde ( size ( A , 1 ), size ( A , 2 )), vl ( 1 , size ( A , 2 )) complex ( dp ) :: work ( 2 * size ( A , 1 )) real ( dp ) :: rwork ( 2 * size ( A , 1 )) ! Setup variables. n = size ( A , 1 ) ; lda = n ; ldvl = 1 ; ldvr = n ; a_tilde = a lwork = 2 * n ! Eigendecomposition. call geev ( jobvl , jobvr , n , a_tilde , lda , vals , vl , ldvl , vecs , ldvr , work , lwork , rwork , & & info ) call check_info ( info , \"GEEV\" , this_module , \"eig_cdp\" ) end procedure eig_cdp !----- Schur Factorization ------ !----- OrdSchur Factorization ----- module procedure ordschur_rsp ! Lapack variables. character , parameter :: job = \"n\" , compq = \"v\" integer ( ilp ) :: info , ldq , ldt , lwork , m , n real ( sp ) :: s , sep integer ( ilp ) :: iwork ( size ( T , 1 )), liwork real ( sp ) :: wi ( size ( T , 1 )), wr ( size ( T , 1 )), work ( size ( T , 1 )) ! Setup variables. n = size ( T , 2 ) ; ldt = n ; ldq = n ; lwork = max ( 1 , n ) if ( time_lightkrylov ()) call timer % start ( 'trsen' ) liwork = 1 call trsen ( job , compq , selected , n , T , ldt , Q , ldq , wr , wi , m , s , sep , work , lwork , & & iwork , liwork , info ) call check_info ( info , \"TRSEN\" , this_module , \"ordschur_rsp\" ) if ( time_lightkrylov ()) call timer % stop ( 'trsen' ) end procedure ordschur_rsp module procedure ordschur_rdp ! Lapack variables. character , parameter :: job = \"n\" , compq = \"v\" integer ( ilp ) :: info , ldq , ldt , lwork , m , n real ( dp ) :: s , sep integer ( ilp ) :: iwork ( size ( T , 1 )), liwork real ( dp ) :: wi ( size ( T , 1 )), wr ( size ( T , 1 )), work ( size ( T , 1 )) ! Setup variables. n = size ( T , 2 ) ; ldt = n ; ldq = n ; lwork = max ( 1 , n ) if ( time_lightkrylov ()) call timer % start ( 'trsen' ) liwork = 1 call trsen ( job , compq , selected , n , T , ldt , Q , ldq , wr , wi , m , s , sep , work , lwork , & & iwork , liwork , info ) call check_info ( info , \"TRSEN\" , this_module , \"ordschur_rdp\" ) if ( time_lightkrylov ()) call timer % stop ( 'trsen' ) end procedure ordschur_rdp module procedure ordschur_csp ! Lapack variables. character , parameter :: job = \"n\" , compq = \"v\" integer ( ilp ) :: info , ldq , ldt , lwork , m , n real ( sp ) :: s , sep complex ( sp ) :: w ( size ( T , 1 )), work ( size ( T , 1 )) ! Setup variables. n = size ( T , 2 ) ; ldt = n ; ldq = n ; lwork = max ( 1 , n ) if ( time_lightkrylov ()) call timer % start ( 'trsen' ) call trsen ( job , compq , selected , n , T , ldt , Q , ldq , w , m , s , sep , work , lwork , info ) call check_info ( info , \"TRSEN\" , this_module , \"ordschur_csp\" ) if ( time_lightkrylov ()) call timer % stop ( 'trsen' ) end procedure ordschur_csp module procedure ordschur_cdp ! Lapack variables. character , parameter :: job = \"n\" , compq = \"v\" integer ( ilp ) :: info , ldq , ldt , lwork , m , n real ( dp ) :: s , sep complex ( dp ) :: w ( size ( T , 1 )), work ( size ( T , 1 )) ! Setup variables. n = size ( T , 2 ) ; ldt = n ; ldq = n ; lwork = max ( 1 , n ) if ( time_lightkrylov ()) call timer % start ( 'trsen' ) call trsen ( job , compq , selected , n , T , ldt , Q , ldq , w , m , s , sep , work , lwork , info ) call check_info ( info , \"TRSEN\" , this_module , \"ordschur_cdp\" ) if ( time_lightkrylov ()) call timer % stop ( 'trsen' ) end procedure ordschur_cdp !----- Matrix Square-Root ----- module procedure sqrtm_rsp character ( len =* ), parameter :: this_procedure = 'sqrtm_rsp' ! Singular value decomposition. real ( sp ) :: S ( size ( A , 1 )) real ( sp ) :: U ( size ( A , 1 ), size ( A , 1 )), UT ( size ( A , 1 ), size ( A , 1 )) integer ( ilp ) :: i real ( sp ) :: symmetry_error character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! Symmetry error. symmetry_error = 0.5_sp * maxval ( abs ( A - hermitian ( A )) ) if ( symmetry_error > rtol_sp ) then write ( msg , \"(2(A,E9.2))\" ) \"Input matrix is not Hermitian. 0.5*max(A - A.H) =\" , & & symmetry_error , \", tol = \" , rtol_sp call stop_error ( msg , this_module , \"sqrtm_rsp\" ) else if ( symmetry_error > 10 * atol_sp ) then write ( msg , \"(A, E9.2)\" ) \"Input matrix is not exactly Hermitian. 0.5*max(A - A.H) =\" , & & symmetry_error call log_warning ( msg , this_module , \"sqrtm_rsp\" ) endif ! Perform SVD. if ( time_lightkrylov ()) call timer % start ( 'svd' ) call svd ( A , S , U , UT ) if ( time_lightkrylov ()) call timer % stop ( 'svd' ) ! Check if matrix is pos. def. (up to tol). do i = 1 , size ( S ) if ( S ( i ) > 10 * atol_sp ) then S ( i ) = sqrt ( S ( i )) else S ( i ) = zero_rsp ; info = 1 endif enddo ! Reconstruct the square root matrix. sqrtA = matmul ( U , matmul ( diag ( S ), hermitian ( U ))) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure sqrtm_rsp module procedure sqrtm_rdp character ( len =* ), parameter :: this_procedure = 'sqrtm_rdp' ! Singular value decomposition. real ( dp ) :: S ( size ( A , 1 )) real ( dp ) :: U ( size ( A , 1 ), size ( A , 1 )), UT ( size ( A , 1 ), size ( A , 1 )) integer ( ilp ) :: i real ( dp ) :: symmetry_error character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! Symmetry error. symmetry_error = 0.5_dp * maxval ( abs ( A - hermitian ( A )) ) if ( symmetry_error > rtol_dp ) then write ( msg , \"(2(A,E9.2))\" ) \"Input matrix is not Hermitian. 0.5*max(A - A.H) =\" , & & symmetry_error , \", tol = \" , rtol_dp call stop_error ( msg , this_module , \"sqrtm_rdp\" ) else if ( symmetry_error > 10 * atol_dp ) then write ( msg , \"(A, E9.2)\" ) \"Input matrix is not exactly Hermitian. 0.5*max(A - A.H) =\" , & & symmetry_error call log_warning ( msg , this_module , \"sqrtm_rdp\" ) endif ! Perform SVD. if ( time_lightkrylov ()) call timer % start ( 'svd' ) call svd ( A , S , U , UT ) if ( time_lightkrylov ()) call timer % stop ( 'svd' ) ! Check if matrix is pos. def. (up to tol). do i = 1 , size ( S ) if ( S ( i ) > 10 * atol_dp ) then S ( i ) = sqrt ( S ( i )) else S ( i ) = zero_rdp ; info = 1 endif enddo ! Reconstruct the square root matrix. sqrtA = matmul ( U , matmul ( diag ( S ), hermitian ( U ))) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure sqrtm_rdp module procedure sqrtm_csp character ( len =* ), parameter :: this_procedure = 'sqrtm_csp' ! Singular value decomposition. real ( sp ) :: S ( size ( A , 1 )) complex ( sp ) :: U ( size ( A , 1 ), size ( A , 1 )), UT ( size ( A , 1 ), size ( A , 1 )) integer ( ilp ) :: i real ( sp ) :: symmetry_error character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! Symmetry error. symmetry_error = 0.5_sp * maxval ( abs ( A - hermitian ( A )) ) if ( symmetry_error > rtol_sp ) then write ( msg , \"(2(A,E9.2))\" ) \"Input matrix is not Hermitian. 0.5*max(A - A.H) =\" , & & symmetry_error , \", tol = \" , rtol_sp call stop_error ( msg , this_module , \"sqrtm_csp\" ) else if ( symmetry_error > 10 * atol_sp ) then write ( msg , \"(A, E9.2)\" ) \"Input matrix is not exactly Hermitian. 0.5*max(A - A.H) =\" , & & symmetry_error call log_warning ( msg , this_module , \"sqrtm_csp\" ) endif ! Perform SVD. if ( time_lightkrylov ()) call timer % start ( 'svd' ) call svd ( A , S , U , UT ) if ( time_lightkrylov ()) call timer % stop ( 'svd' ) ! Check if matrix is pos. def. (up to tol). do i = 1 , size ( S ) if ( S ( i ) > 10 * atol_sp ) then S ( i ) = sqrt ( S ( i )) else S ( i ) = zero_rsp ; info = 1 endif enddo ! Reconstruct the square root matrix. sqrtA = matmul ( U , matmul ( diag ( S ), hermitian ( U ))) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure sqrtm_csp module procedure sqrtm_cdp character ( len =* ), parameter :: this_procedure = 'sqrtm_cdp' ! Singular value decomposition. real ( dp ) :: S ( size ( A , 1 )) complex ( dp ) :: U ( size ( A , 1 ), size ( A , 1 )), UT ( size ( A , 1 ), size ( A , 1 )) integer ( ilp ) :: i real ( dp ) :: symmetry_error character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! Symmetry error. symmetry_error = 0.5_dp * maxval ( abs ( A - hermitian ( A )) ) if ( symmetry_error > rtol_dp ) then write ( msg , \"(2(A,E9.2))\" ) \"Input matrix is not Hermitian. 0.5*max(A - A.H) =\" , & & symmetry_error , \", tol = \" , rtol_dp call stop_error ( msg , this_module , \"sqrtm_cdp\" ) else if ( symmetry_error > 10 * atol_dp ) then write ( msg , \"(A, E9.2)\" ) \"Input matrix is not exactly Hermitian. 0.5*max(A - A.H) =\" , & & symmetry_error call log_warning ( msg , this_module , \"sqrtm_cdp\" ) endif ! Perform SVD. if ( time_lightkrylov ()) call timer % start ( 'svd' ) call svd ( A , S , U , UT ) if ( time_lightkrylov ()) call timer % stop ( 'svd' ) ! Check if matrix is pos. def. (up to tol). do i = 1 , size ( S ) if ( S ( i ) > 10 * atol_dp ) then S ( i ) = sqrt ( S ( i )) else S ( i ) = zero_rdp ; info = 1 endif enddo ! Reconstruct the square root matrix. sqrtA = matmul ( U , matmul ( diag ( S ), hermitian ( U ))) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure sqrtm_cdp !----- Givens rotations ----- module procedure givens_rotation_rsp g = x / norm ( x , 2 ) end procedure givens_rotation_rsp module procedure apply_givens_rotation_rsp integer ( ilp ) :: k real ( sp ) :: r real ( sp ), pointer :: hmat (:, :) !> Size of the column. k = size ( h ) - 1 !> Apply previous Givens rotations to this new column. hmat ( 1 : k , 1 : 1 ) => h (: k ) call lasr ( \"L\" , \"V\" , \"F\" , k , 1 , c (: k - 1 ), s (: k - 1 ), hmat , k ) !> Compute the sine and cosine compoennts for the next rotation. call lartg ( h ( k ), h ( k + 1 ), c ( k ), s ( k ), r ) !> Eliminiate H(k+1, k). h ( k ) = r ; h ( k + 1 ) = 0.0_sp end procedure apply_givens_rotation_rsp module procedure givens_rotation_rdp g = x / norm ( x , 2 ) end procedure givens_rotation_rdp module procedure apply_givens_rotation_rdp integer ( ilp ) :: k real ( dp ) :: r real ( dp ), pointer :: hmat (:, :) !> Size of the column. k = size ( h ) - 1 !> Apply previous Givens rotations to this new column. hmat ( 1 : k , 1 : 1 ) => h (: k ) call lasr ( \"L\" , \"V\" , \"F\" , k , 1 , c (: k - 1 ), s (: k - 1 ), hmat , k ) !> Compute the sine and cosine compoennts for the next rotation. call lartg ( h ( k ), h ( k + 1 ), c ( k ), s ( k ), r ) !> Eliminiate H(k+1, k). h ( k ) = r ; h ( k + 1 ) = 0.0_dp end procedure apply_givens_rotation_rdp module procedure givens_rotation_csp g = x / norm ( x , 2 ) end procedure givens_rotation_csp module procedure apply_givens_rotation_csp integer ( ilp ) :: i , k complex ( sp ) :: t , r , g ( 2 ) !> Size of the column. k = size ( h ) - 1 !> Apply previous Givens rotations to this new column. do i = 1 , k - 1 t = c ( i ) * h ( i ) + s ( i ) * h ( i + 1 ) h ( i + 1 ) = - s ( i ) * h ( i ) + c ( i ) * h ( i + 1 ) h ( i ) = t enddo !> Compute the sine and cosine compoennts for the next rotation. g = givens_rotation ([ h ( k ), h ( k + 1 )]) ; c ( k ) = g ( 1 ) ; s ( k ) = g ( 2 ) !> Eliminiate H(k+1, k). h ( k ) = c ( k ) * h ( k ) + s ( k ) * h ( k + 1 ) ; h ( k + 1 ) = 0.0_sp end procedure apply_givens_rotation_csp module procedure givens_rotation_cdp g = x / norm ( x , 2 ) end procedure givens_rotation_cdp module procedure apply_givens_rotation_cdp integer ( ilp ) :: i , k complex ( dp ) :: t , r , g ( 2 ) !> Size of the column. k = size ( h ) - 1 !> Apply previous Givens rotations to this new column. do i = 1 , k - 1 t = c ( i ) * h ( i ) + s ( i ) * h ( i + 1 ) h ( i + 1 ) = - s ( i ) * h ( i ) + c ( i ) * h ( i + 1 ) h ( i ) = t enddo !> Compute the sine and cosine compoennts for the next rotation. g = givens_rotation ([ h ( k ), h ( k + 1 )]) ; c ( k ) = g ( 1 ) ; s ( k ) = g ( 2 ) !> Eliminiate H(k+1, k). h ( k ) = c ( k ) * h ( k ) + s ( k ) * h ( k + 1 ) ; h ( k + 1 ) = 0.0_dp end procedure apply_givens_rotation_cdp end submodule utility_functions","tags":"","url":"sourcefile/submodule_utility_functions.f90.html"},{"title":"IterativeSolvers.f90 – LightKrylov","text":"Source Code module LightKrylov_IterativeSolvers !!  This module provides some of the most important computational routines provided by !!  `LightKrylov`. These include: !! !!  - `eigs`    :   Compute the leading eigenpairs of a square linear operator  A . !!  - `eighs`   :   Compute the leading eigenpairs of a symmetric positive definite !!                  operator  A . !!  - `svds`    :   Compute the leading singular triplets of a linear operator  A . !!  - `gmres`   :   Solve the linear system  Ax = b  using the *generalized minimum residual method*. !!  - `cg`      :   Solve the linear system  Ax = b  where  A  is symmetric !!                  positive definite using the *Conjugate Gradient* method. !! !!  It also provides abstract interfaces to pass user-defined solvers and preconditioners !!  to `LightKrylov`. Note that these features are still experimental for now. !-------------------------------------------- !-----     Fortran Standard Library     ----- !-------------------------------------------- use iso_fortran_env , only : output_unit use stdlib_sorting , only : sort_index use stdlib_optval , only : optval use stdlib_io_npy , only : save_npy use stdlib_stats , only : median !------------------------------- !-----     LightKrylov     ----- !------------------------------- use LightKrylov_Constants use LightKrylov_Utils use LightKrylov_Logger , only : log_information , log_message , log_debug , & & type_error , stop_error , check_info use LightKrylov_Timing , only : timer => global_lightkrylov_timer , time_lightkrylov use LightKrylov_AbstractVectors use LightKrylov_AbstractLinops use LightKrylov_BaseKrylov implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_Solvers' character ( len =* ), parameter :: this_module_long = 'LightKrylov_IterativeSolvers' character ( len =* ), parameter :: eigs_output = 'eigs_output.txt' public :: abstract_linear_solver_rsp public :: abstract_linear_solver_rdp public :: abstract_linear_solver_csp public :: abstract_linear_solver_cdp public :: save_eigenspectrum public :: eigs public :: eighs public :: svds public :: gmres public :: gmres_rsp public :: gmres_rdp public :: gmres_csp public :: gmres_cdp public :: fgmres public :: fgmres_rsp public :: fgmres_rdp public :: fgmres_csp public :: fgmres_cdp public :: cg public :: cg_rsp public :: cg_rdp public :: cg_csp public :: cg_cdp public :: write_results_rsp public :: write_results_rdp public :: write_results_csp public :: write_results_cdp !------------------------------------------------------ !-----     ABSTRACT PRECONDITIONER DEFINITION     ----- !------------------------------------------------------ type , abstract , public :: abstract_precond_rsp contains private procedure ( abstract_apply_rsp ), pass ( self ), public , deferred :: apply end type abstract_precond_rsp abstract interface subroutine abstract_apply_rsp ( self , vec , iter , current_residual , target_residual ) !! Abstract interface to apply a preconditioner in `LightKrylov`. import abstract_precond_rsp , abstract_vector_rsp import sp implicit none ( type , external ) class ( abstract_precond_rsp ), intent ( inout ) :: self !! Preconditioner. class ( abstract_vector_rsp ), intent ( inout ) :: vec !! Input/Output vector. integer , optional , intent ( in ) :: iter !! Current iteration number. real ( sp ), optional , intent ( in ) :: current_residual real ( sp ), optional , intent ( in ) :: target_residual end subroutine abstract_apply_rsp end interface type , abstract , public :: abstract_precond_rdp contains private procedure ( abstract_apply_rdp ), pass ( self ), public , deferred :: apply end type abstract_precond_rdp abstract interface subroutine abstract_apply_rdp ( self , vec , iter , current_residual , target_residual ) !! Abstract interface to apply a preconditioner in `LightKrylov`. import abstract_precond_rdp , abstract_vector_rdp import dp implicit none ( type , external ) class ( abstract_precond_rdp ), intent ( inout ) :: self !! Preconditioner. class ( abstract_vector_rdp ), intent ( inout ) :: vec !! Input/Output vector. integer , optional , intent ( in ) :: iter !! Current iteration number. real ( dp ), optional , intent ( in ) :: current_residual real ( dp ), optional , intent ( in ) :: target_residual end subroutine abstract_apply_rdp end interface type , abstract , public :: abstract_precond_csp contains private procedure ( abstract_apply_csp ), pass ( self ), public , deferred :: apply end type abstract_precond_csp abstract interface subroutine abstract_apply_csp ( self , vec , iter , current_residual , target_residual ) !! Abstract interface to apply a preconditioner in `LightKrylov`. import abstract_precond_csp , abstract_vector_csp import sp implicit none ( type , external ) class ( abstract_precond_csp ), intent ( inout ) :: self !! Preconditioner. class ( abstract_vector_csp ), intent ( inout ) :: vec !! Input/Output vector. integer , optional , intent ( in ) :: iter !! Current iteration number. real ( sp ), optional , intent ( in ) :: current_residual real ( sp ), optional , intent ( in ) :: target_residual end subroutine abstract_apply_csp end interface type , abstract , public :: abstract_precond_cdp contains private procedure ( abstract_apply_cdp ), pass ( self ), public , deferred :: apply end type abstract_precond_cdp abstract interface subroutine abstract_apply_cdp ( self , vec , iter , current_residual , target_residual ) !! Abstract interface to apply a preconditioner in `LightKrylov`. import abstract_precond_cdp , abstract_vector_cdp import dp implicit none ( type , external ) class ( abstract_precond_cdp ), intent ( inout ) :: self !! Preconditioner. class ( abstract_vector_cdp ), intent ( inout ) :: vec !! Input/Output vector. integer , optional , intent ( in ) :: iter !! Current iteration number. real ( dp ), optional , intent ( in ) :: current_residual real ( dp ), optional , intent ( in ) :: target_residual end subroutine abstract_apply_cdp end interface !-------------------------------------------------------- !-----     GENERIC INTERFACE FOR LINEAR SOLVERS     ----- !-------------------------------------------------------- abstract interface subroutine abstract_linear_solver_rsp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) !! Abstract interface to use a user-defined linear solver in `LightKrylov`. import abstract_linop_rsp , abstract_vector_rsp , abstract_opts , abstract_metadata , abstract_precond_rsp , sp implicit none ( type , external ) class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to invert. class ( abstract_vector_rsp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rsp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( inout ) :: preconditioner !! Preconditioner. class ( abstract_opts ), optional , intent ( in ) :: options !! Options passed to the linear solver. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} (`.false.`) or \\mathbf{A}&#94;T (`.true.`) is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine abstract_linear_solver_rsp subroutine abstract_linear_solver_rdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) !! Abstract interface to use a user-defined linear solver in `LightKrylov`. import abstract_linop_rdp , abstract_vector_rdp , abstract_opts , abstract_metadata , abstract_precond_rdp , dp implicit none ( type , external ) class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to invert. class ( abstract_vector_rdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner. class ( abstract_opts ), optional , intent ( in ) :: options !! Options passed to the linear solver. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} (`.false.`) or \\mathbf{A}&#94;T (`.true.`) is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine abstract_linear_solver_rdp subroutine abstract_linear_solver_csp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) !! Abstract interface to use a user-defined linear solver in `LightKrylov`. import abstract_linop_csp , abstract_vector_csp , abstract_opts , abstract_metadata , abstract_precond_csp , sp implicit none ( type , external ) class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to invert. class ( abstract_vector_csp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_csp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( inout ) :: preconditioner !! Preconditioner. class ( abstract_opts ), optional , intent ( in ) :: options !! Options passed to the linear solver. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} (`.false.`) or \\mathbf{A}&#94;T (`.true.`) is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine abstract_linear_solver_csp subroutine abstract_linear_solver_cdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) !! Abstract interface to use a user-defined linear solver in `LightKrylov`. import abstract_linop_cdp , abstract_vector_cdp , abstract_opts , abstract_metadata , abstract_precond_cdp , dp implicit none ( type , external ) class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to invert. class ( abstract_vector_cdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_cdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner. class ( abstract_opts ), optional , intent ( in ) :: options !! Options passed to the linear solver. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} (`.false.`) or \\mathbf{A}&#94;T (`.true.`) is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine abstract_linear_solver_cdp end interface !------------------------------------------------------- !-----                                             ----- !-----     GENERALIZED MINIMUM RESIDUAL METHOD     ----- !-----                                             ----- !------------------------------------------------------- !----- Options and Metadata ----- type , extends ( abstract_opts ), public :: gmres_sp_opts !! GMRES options. integer :: kdim = 30 !! Dimension of the Krylov subspace (default: 30). integer :: maxiter = 10 !! Maximum number of `gmres` restarts (default: 10). logical :: if_print_metadata = . false . !! Print iteration metadata on exit (default: .false.). logical :: sanity_check = . true . !! Performs extra matrix-vector product for sanity check. end type gmres_sp_opts type , extends ( abstract_metadata ), public :: gmres_sp_metadata !! GMRES metadata. integer :: n_iter = 0 !! Total iteration counter. integer :: n_inner = 0 !! Number of inner iterations. integer :: n_outer = 0 !! Number of outer iterations (i.e. restarts) real ( sp ), dimension (:), allocatable :: res !! Residual history. logical :: converged = . false . !! Convergence flag. integer :: info = 0 !! Copy of the information flag for completeness. contains procedure , pass ( self ), public :: print => print_gmres_sp procedure , pass ( self ), public :: reset => reset_gmres_sp end type gmres_sp_metadata interface module subroutine print_gmres_sp ( self , reset_counters , verbose ) implicit none ( type , external ) class ( gmres_sp_metadata ), intent ( inout ) :: self logical , optional , intent ( in ) :: reset_counters !! Reset all counters to zero after printing? logical , optional , intent ( in ) :: verbose !! Print the full residual history? end subroutine print_gmres_sp module subroutine reset_gmres_sp ( self ) implicit none ( type , external ) class ( gmres_sp_metadata ), intent ( inout ) :: self end subroutine reset_gmres_sp end interface type , extends ( abstract_opts ), public :: gmres_dp_opts !! GMRES options. integer :: kdim = 30 !! Dimension of the Krylov subspace (default: 30). integer :: maxiter = 10 !! Maximum number of `gmres` restarts (default: 10). logical :: if_print_metadata = . false . !! Print iteration metadata on exit (default: .false.). logical :: sanity_check = . true . !! Performs extra matrix-vector product for sanity check. end type gmres_dp_opts type , extends ( abstract_metadata ), public :: gmres_dp_metadata !! GMRES metadata. integer :: n_iter = 0 !! Total iteration counter. integer :: n_inner = 0 !! Number of inner iterations. integer :: n_outer = 0 !! Number of outer iterations (i.e. restarts) real ( dp ), dimension (:), allocatable :: res !! Residual history. logical :: converged = . false . !! Convergence flag. integer :: info = 0 !! Copy of the information flag for completeness. contains procedure , pass ( self ), public :: print => print_gmres_dp procedure , pass ( self ), public :: reset => reset_gmres_dp end type gmres_dp_metadata interface module subroutine print_gmres_dp ( self , reset_counters , verbose ) implicit none ( type , external ) class ( gmres_dp_metadata ), intent ( inout ) :: self logical , optional , intent ( in ) :: reset_counters !! Reset all counters to zero after printing? logical , optional , intent ( in ) :: verbose !! Print the full residual history? end subroutine print_gmres_dp module subroutine reset_gmres_dp ( self ) implicit none ( type , external ) class ( gmres_dp_metadata ), intent ( inout ) :: self end subroutine reset_gmres_dp end interface !----- Interfaces for the GMRES solvers ----- interface gmres !!  ### Description !! !!  Solve a square linear system of equations !! !!   !!      Ax = b !!   !! !!  using the *Generalized Minimum RESidual* (GMRES) method. !! !!  **References** !! !!  - Saad Y. and Schultz M. H. \"GMRES: A generalized minimal residual algorithm for !!  solving nonsymmetric linear systems.\" SIAM Journal on Scientific and Statistical !!  Computing, 7(3), 1986. !! !!  ### Syntax !! !!  ```fortran !!      call gmres(A, b, x, info [, rtol] [, atol] [, preconditioner] [, options] [, transpose]) !!  ``` !! !!  ### Arguments !! !!  - `A`   :   Linear operator derived from one of the `abstract_linop` types provided by the !!              `AbstractLinops` module. It is an `intent(inout)` argument. !! !!  - `b`   :   Right-hand side vector derived from one the `abstract_vector` types provided !!              by the `AbstractVectors` module. It needs to have the same type and kind as `A`. !!              It is an `intent(in)` argument. !! !!  - `x`   :   On entry, initial guess for the solution. On exit, the solution computed by !!              gmres. It is a vector derived from one the `abstract_vector` types provided by the !!              `AbstractVectors` module. It needs to have the same type and kind as `A`. It is !!              an `intent(inout)` argument. !! !!  - `info`    :   `integer` information flag. !! !!  - `rtol` (optional) :   `real` relative tolerance for the solver. !! !!  - `atol` (optional) :   `real` absolute tolerance for the solver. !! !!  - `preconditioner` (optional)   :   Right preconditioner used to solve the system. It needs !!                                      to be consistent with the `abstract_preconditioner` interface. !!                                      It is an optional `intent(in)` argument. !! !!  - `options` (optional)  :   Container for the gmres options given by the `gmres_opts` type. !!                              It is an optional `intent(in)` argument. !! !!  - `transpose` (optional):   `logical` flag controlling whether  Ax = b or  A&#94;H x = b  is being solved. !! !!  - `meta` (optional) :   Container for the gmres metadata. It needs to be of type `gmres_metadata`. ! --- Interface for GMRES with Abstract Linops and Abstract Vectors --- module subroutine gmres_rsp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_rsp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rsp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine gmres_rsp module subroutine dense_gmres_rsp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) real ( sp ), intent ( in ) :: A (:, :) !! Linear operator to be inverted. real ( sp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( sp ), intent ( inout ) :: x (:) !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine dense_gmres_rsp module subroutine gmres_rdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_rdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine gmres_rdp module subroutine dense_gmres_rdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) real ( dp ), intent ( in ) :: A (:, :) !! Linear operator to be inverted. real ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( dp ), intent ( inout ) :: x (:) !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine dense_gmres_rdp module subroutine gmres_csp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_csp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_csp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine gmres_csp module subroutine dense_gmres_csp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: A (:, :) !! Linear operator to be inverted. complex ( sp ), intent ( in ) :: b (:) !! Right-hand side vector. complex ( sp ), intent ( inout ) :: x (:) !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine dense_gmres_csp module subroutine gmres_cdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_cdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_cdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine gmres_cdp module subroutine dense_gmres_cdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: A (:, :) !! Linear operator to be inverted. complex ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. complex ( dp ), intent ( inout ) :: x (:) !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine dense_gmres_cdp end interface !---------------------------------------------------------------- !-----                                                      ----- !-----     FLEXIBLE GENERALIZED MINIMUM RESIDUAL METHOD     ----- !-----                                                      ----- !---------------------------------------------------------------- !----- Options and Metadata ----- type , extends ( abstract_opts ), public :: fgmres_sp_opts !! FGMRES options. integer :: kdim = 30 !! Dimension of the Krylov subspace (default: 30). integer :: maxiter = 10 !! Maximum number of `fgmres` restarts (default: 10). logical :: if_print_metadata = . false . !! Print iteration metadata on exit (default: .false.). logical :: sanity_check = . true . !! Performs extra matrix-vector product for sanity check. end type fgmres_sp_opts type , extends ( abstract_metadata ), public :: fgmres_sp_metadata !! FGMRES metadata. integer :: n_iter = 0 !! Total iteration counter. integer :: n_inner = 0 !! Number of inner iterations. integer :: n_outer = 0 !! Number of outer iterations (i.e. restarts) real ( sp ), dimension (:), allocatable :: res !! Residual history. logical :: converged = . false . !! Convergence flag. integer :: info = 0 !! Copy of the information flag for completeness. contains procedure , pass ( self ), public :: print => print_fgmres_sp procedure , pass ( self ), public :: reset => reset_fgmres_sp end type fgmres_sp_metadata interface module subroutine print_fgmres_sp ( self , reset_counters , verbose ) implicit none ( type , external ) class ( fgmres_sp_metadata ), intent ( inout ) :: self logical , optional , intent ( in ) :: reset_counters !! Reset all counters to zero after printing? logical , optional , intent ( in ) :: verbose !! Print the full residual history? end subroutine print_fgmres_sp module subroutine reset_fgmres_sp ( self ) implicit none ( type , external ) class ( fgmres_sp_metadata ), intent ( inout ) :: self end subroutine reset_fgmres_sp end interface type , extends ( abstract_opts ), public :: fgmres_dp_opts !! FGMRES options. integer :: kdim = 30 !! Dimension of the Krylov subspace (default: 30). integer :: maxiter = 10 !! Maximum number of `fgmres` restarts (default: 10). logical :: if_print_metadata = . false . !! Print iteration metadata on exit (default: .false.). logical :: sanity_check = . true . !! Performs extra matrix-vector product for sanity check. end type fgmres_dp_opts type , extends ( abstract_metadata ), public :: fgmres_dp_metadata !! FGMRES metadata. integer :: n_iter = 0 !! Total iteration counter. integer :: n_inner = 0 !! Number of inner iterations. integer :: n_outer = 0 !! Number of outer iterations (i.e. restarts) real ( dp ), dimension (:), allocatable :: res !! Residual history. logical :: converged = . false . !! Convergence flag. integer :: info = 0 !! Copy of the information flag for completeness. contains procedure , pass ( self ), public :: print => print_fgmres_dp procedure , pass ( self ), public :: reset => reset_fgmres_dp end type fgmres_dp_metadata interface module subroutine print_fgmres_dp ( self , reset_counters , verbose ) implicit none ( type , external ) class ( fgmres_dp_metadata ), intent ( inout ) :: self logical , optional , intent ( in ) :: reset_counters !! Reset all counters to zero after printing? logical , optional , intent ( in ) :: verbose !! Print the full residual history? end subroutine print_fgmres_dp module subroutine reset_fgmres_dp ( self ) implicit none ( type , external ) class ( fgmres_dp_metadata ), intent ( inout ) :: self end subroutine reset_fgmres_dp end interface !----- Interfaces for the FGMRES solvers ----- interface fgmres !!  ### Description !! !!  Solve a square linear system of equations !! !!   !!      Ax = b !!   !! !!  using the *Flexible Generalized Minimum RESidual* (FGMRES) method. !! !!  **References** !! !!  - Saad Y. and Schultz M. H. \"GMRES: A generalized minimal residual algorithm for !!  solving nonsymmetric linear systems.\" SIAM Journal on Scientific and Statistical !!  Computing, 7(3), 1986. !! !!  ### Syntax !! !!  ```fortran !!      call fgmres(A, b, x, info [, rtol] [, atol] [, preconditioner] [, options] [, transpose]) !!  ``` !! !!  ### Arguments !! !!  - `A`   :   Linear operator derived from one of the `abstract_linop` types provided by the !!              `AbstractLinops` module. It is an `intent(inout)` argument. !! !!  - `b`   :   Right-hand side vector derived from one the `abstract_vector` types provided !!              by the `AbstractVectors` module. It needs to have the same type and kind as `A`. !!              It is an `intent(in)` argument. !! !!  - `x`   :   On entry, initial guess for the solution. On exit, the solution computed by !!              gmres. It is a vector derived from one the `abstract_vector` types provided by the !!              `AbstractVectors` module. It needs to have the same type and kind as `A`. It is !!              an `intent(inout)` argument. !! !!  - `info`    :   `integer` information flag. !! !!  - `rtol` (optional) :   `real` relative tolerance for the solver. !! !!  - `atol` (optional) :   `real` absolute tolerance for the solver. !! !!  - `preconditioner` (optional)   :   Right preconditioner used to solve the system. It needs to be !!                                      consistent with the `abstract_preconditioner` interface. !!                                      It is an optional `intent(in)` argument. !! !!  - `options` (optional)  :   Container for the gmres options given by the `gmres_opts` type. !!                              It is an optional `intent(in)` argument. !! !!  - `transpose` (optional):   `logical` flag controlling whether  Ax = b or !!                               A&#94;H x = b  is being solved. module subroutine fgmres_rsp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_rsp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rsp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine fgmres_rsp module subroutine dense_fgmres_rsp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) real ( sp ), intent ( in ) :: A (:, :) !! Linear operator to be inverted. real ( sp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( sp ), intent ( inout ) :: x (:) !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine dense_fgmres_rsp module subroutine fgmres_rdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_rdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine fgmres_rdp module subroutine dense_fgmres_rdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) real ( dp ), intent ( in ) :: A (:, :) !! Linear operator to be inverted. real ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( dp ), intent ( inout ) :: x (:) !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine dense_fgmres_rdp module subroutine fgmres_csp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_csp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_csp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine fgmres_csp module subroutine dense_fgmres_csp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: A (:, :) !! Linear operator to be inverted. complex ( sp ), intent ( in ) :: b (:) !! Right-hand side vector. complex ( sp ), intent ( inout ) :: x (:) !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine dense_fgmres_csp module subroutine fgmres_cdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_cdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_cdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine fgmres_cdp module subroutine dense_fgmres_cdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose , meta ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: A (:, :) !! Linear operator to be inverted. complex ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. complex ( dp ), intent ( inout ) :: x (:) !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine dense_fgmres_cdp end interface !--------------------------------------------- !-----                                   ----- !-----     CONJUGATE GRADIENT METHOD     ----- !-----                                   ----- !--------------------------------------------- !----- Options and Metadata ----- type , extends ( abstract_opts ), public :: cg_sp_opts !! Conjugate gradient options. integer :: maxiter = 100 !! Maximum number of `cg` iterations (default: 100). logical :: if_print_metadata = . false . !! Print interation metadata on exit (default = .false.) end type cg_sp_opts type , extends ( abstract_metadata ), public :: cg_sp_metadata !! Conjugate gradient metadata. integer :: n_iter = 0 !! Iteration counter real ( sp ), dimension (:), allocatable :: res !! Residual history logical :: converged = . false . !! Convergence flag integer :: info = 0 !! Copy of the information flag for completeness contains procedure , pass ( self ), public :: print => print_cg_sp procedure , pass ( self ), public :: reset => reset_cg_sp end type cg_sp_metadata interface module subroutine print_cg_sp ( self , reset_counters , verbose ) implicit none ( type , external ) class ( cg_sp_metadata ), intent ( inout ) :: self logical , optional , intent ( in ) :: reset_counters !! Reset all counters to zero after printing? logical , optional , intent ( in ) :: verbose !! Print the residual full residual history? end subroutine print_cg_sp module subroutine reset_cg_sp ( self ) implicit none ( type , external ) class ( cg_sp_metadata ), intent ( inout ) :: self end subroutine reset_cg_sp end interface type , extends ( abstract_opts ), public :: cg_dp_opts !! Conjugate gradient options. integer :: maxiter = 100 !! Maximum number of `cg` iterations (default: 100). logical :: if_print_metadata = . false . !! Print interation metadata on exit (default = .false.) end type cg_dp_opts type , extends ( abstract_metadata ), public :: cg_dp_metadata !! Conjugate gradient metadata. integer :: n_iter = 0 !! Iteration counter real ( dp ), dimension (:), allocatable :: res !! Residual history logical :: converged = . false . !! Convergence flag integer :: info = 0 !! Copy of the information flag for completeness contains procedure , pass ( self ), public :: print => print_cg_dp procedure , pass ( self ), public :: reset => reset_cg_dp end type cg_dp_metadata interface module subroutine print_cg_dp ( self , reset_counters , verbose ) implicit none ( type , external ) class ( cg_dp_metadata ), intent ( inout ) :: self logical , optional , intent ( in ) :: reset_counters !! Reset all counters to zero after printing? logical , optional , intent ( in ) :: verbose !! Print the residual full residual history? end subroutine print_cg_dp module subroutine reset_cg_dp ( self ) implicit none ( type , external ) class ( cg_dp_metadata ), intent ( inout ) :: self end subroutine reset_cg_dp end interface !----- Interfaces for the Conjugate Gradient solvers ----- interface cg !!  ### Description !! !!  Given a symmetric (positive definite) matrix  A , solves the linear system !! !!   !!      Ax = b !!   !! !!  using the *Conjugate Gradient* method. !! !!  **References** !! !!  - Hestenes, M. R., and Stiefel, E. (1952). \"Methods of Conjugate Gradients for Solving !!  Linear Systems,\" Journal of Research of the National Bureau of Standards, !!  49(6), 409–436. !! !!  ### Syntax !! !!  ```fortran !!      call cg(A, b, x, info [, rtol] [, atol] [, preconditioner] [, options]) !!  ``` !! !!  ### Arguments !! !!  - `A`   :   Linear operator derived from one of the `abstract_sym_linop` or `abstract_hermitian_linop` !!              types provided by the `AbstractLinops` module. It is an `intent(inout)` argument. !! !!  - `b`   :   Right-hand side vector derived from one the `abstract_vector` types provided !!              by the `AbstractVectors` module. It needs to have the same type and kind as `A`. !!              It is an `intent(in)` argument. !! !!  - `x`   :   On entry, initial guess for the solution. On exit, the solution computed by !!              cg. It is a vector derived from one the `abstract_vector` types provided by the !!              `AbstractVectors` module. It needs to have the same type and kind as `A`. It is !!              an `intent(inout)` argument. !! !!  - `info`    :   `integer` information flag. !! !!  - `rtol` (optional) :   `real` relative tolerance for the solver. !! !!  - `atol` (optional) :   `real` absolute tolerance for the solver. !! !!  - `preconditioner` (optional)   :   Right preconditioner used to solve the system. It needs to be !!                                      consistent with the `abstract_preconditioner` interface. !!                                      It is an optional `intent(in)` argument. !! !!  - `options` (optional)  :   Container for the gmres options given by the `cg_opts` type. !!                              It is an optional `intent(in)` argument. module subroutine cg_rsp ( A , b , x , info , rtol , atol , preconditioner , options , meta ) implicit none ( type , external ) class ( abstract_sym_linop_rsp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_rsp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rsp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_sp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine cg_rsp module subroutine cg_rdp ( A , b , x , info , rtol , atol , preconditioner , options , meta ) implicit none ( type , external ) class ( abstract_sym_linop_rdp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_rdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_dp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine cg_rdp module subroutine cg_csp ( A , b , x , info , rtol , atol , preconditioner , options , meta ) implicit none ( type , external ) class ( abstract_hermitian_linop_csp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_csp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_csp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_sp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine cg_csp module subroutine cg_cdp ( A , b , x , info , rtol , atol , preconditioner , options , meta ) implicit none ( type , external ) class ( abstract_hermitian_linop_cdp ), intent ( inout ) :: A !! Linear operator to be inverted. class ( abstract_vector_cdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_cdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( inout ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_dp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. class ( abstract_metadata ), optional , intent ( out ) :: meta !! Metadata. end subroutine cg_cdp end interface !------------------------------------------ !-----                                ----- !-----     SINGULAR VALUE SOLVERS     ----- !-----                                ----- !------------------------------------------ interface svds !!  ### Description !! !!  Computes the leading singular triplets of an arbitrary linear operator A !!  using the Lanczos iterative process. Given a linear operator A, it finds !!  the leading singular values and singular vectors such that: !! !!   !!      \\begin{aligned} !!      Av & = \\sigma u \\\\ !!      A&#94;H u & = \\sigma v. !!      \\end{aligned} !!   !! !!  The subspaces U and V are constructed via Lanczos factorization, resulting in !!  a bidiagonal matrix B. The singular values of A are approximated by those of !!  B and the singular vectors are computed accordingly. !! !!  **References** !! !!  - Golub, G. H., & Kahan, W. (1965). \"Calculating the Singular Values and !!   Pseudo-Inverse of a Matrix.\" !!  - Baglama, J., & Reichel, L. (2005). \"Augmented implicitly restarted Lanczos !!   bidiagonalization methods.\" !!  - R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\" !!   Technical Report, 1998. !! !!  ### Syntax !! !!  ```fortran !!      call svds(A, U, S, V, residuals, info [, kdim] [,tolerance]) !!  ``` !! !!  ### Arguments !! !!  - `A`   :   Linear operator derived from `abstract_sym_linop_rsp`, `abstract_sym_linop_rdp`, !!              `abstract_hermitian_linop_csp` or `abstract_hermitian_linop_cdp` whose leading !!              eigenpairs need to be computed. It is an `intent(inout)` argument. !! !!  - `U`   :   Array of `abstract_vectors` with the same type and kind as `A`. On exit, it !!              contains the left singular vectors of `A`. Note that the dimension of `U` fixes !!              the number of eigenpairs computed. It is an `intent(out)` argument. !! !!  - `S`   :   Rank-1 array of `real` numbers. On exit, it contains the leading !!              singular values of `A`. It is an `intent(out)` argument. !! !!  - `V`   :   Array of `abstract_vectors` with the same type and kind as `A`. On exit, it !!              contains the left singular vectors of `A`. Note that the dimension of `U` fixes !!              the number of eigenpairs computed. It is an `intent(out)` argument. !! !!  - `residuals`   :   Rank-1 array of `real` numbers. On exit, it contains the residuals !!                      associated with each singular triplet. It is an `intent(out)` argument. !! !!  - `info`    :   `integer` Information flag. !! !!  - `kdim` (*optional*)   :   `integer`, maximum dimension of the Krylov subspace used to !!                              approximate the leading singular triplets. It is an optional !!                              `intent(in)` argument. By default, `kdim = 4*size(X)`. !! !!  - `tolerance` (*optional*)  :   `real` tolerance below which a triplet is considered as being converged. It is an !!                                  optional `intent(in)` argument. By default, tolerance = rtol_sp` or `tolerance = rtol_dp`. !!  @note !!  This implementation does not currently include an automatic restarting procedure !!  such as `krylov_schur` for `eigs`. This is work in progress. !!  @endnote module subroutine svds_rsp ( A , U , S , V , residuals , info , u0 , kdim , tolerance , write_intermediate ) implicit none ( type , external ) class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator whose leading singular triplets need to be computed. class ( abstract_vector_rsp ), intent ( out ) :: U (:) !! Leading left singular vectors. real ( sp ), allocatable , intent ( out ) :: S (:) !! Leading singular values. class ( abstract_vector_rsp ), intent ( out ) :: V (:) !! Leading right singular vectors. real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_rsp ), optional , intent ( in ) :: u0 integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? end subroutine svds_rsp module subroutine svds_rdp ( A , U , S , V , residuals , info , u0 , kdim , tolerance , write_intermediate ) implicit none ( type , external ) class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator whose leading singular triplets need to be computed. class ( abstract_vector_rdp ), intent ( out ) :: U (:) !! Leading left singular vectors. real ( dp ), allocatable , intent ( out ) :: S (:) !! Leading singular values. class ( abstract_vector_rdp ), intent ( out ) :: V (:) !! Leading right singular vectors. real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_rdp ), optional , intent ( in ) :: u0 integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? end subroutine svds_rdp module subroutine svds_csp ( A , U , S , V , residuals , info , u0 , kdim , tolerance , write_intermediate ) implicit none ( type , external ) class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator whose leading singular triplets need to be computed. class ( abstract_vector_csp ), intent ( out ) :: U (:) !! Leading left singular vectors. real ( sp ), allocatable , intent ( out ) :: S (:) !! Leading singular values. class ( abstract_vector_csp ), intent ( out ) :: V (:) !! Leading right singular vectors. real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_csp ), optional , intent ( in ) :: u0 integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? end subroutine svds_csp module subroutine svds_cdp ( A , U , S , V , residuals , info , u0 , kdim , tolerance , write_intermediate ) implicit none ( type , external ) class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator whose leading singular triplets need to be computed. class ( abstract_vector_cdp ), intent ( out ) :: U (:) !! Leading left singular vectors. real ( dp ), allocatable , intent ( out ) :: S (:) !! Leading singular values. class ( abstract_vector_cdp ), intent ( out ) :: V (:) !! Leading right singular vectors. real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_cdp ), optional , intent ( in ) :: u0 integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? end subroutine svds_cdp end interface !------------------------------------------------ !-----                                      ----- !-----     HERMITIAN EIGENVALUE SOLVERS     ----- !-----                                      ----- !------------------------------------------------ interface eighs !!  ### Description !! !!  Computes the leading eigenpairs of a symmetric operator A using the !!  Lanczos iterative process. Given a square linear operator A, it finds !!  the leading eigvalues and eigvectors such that: !! !!   !!      Ax = \\lambda x !!   !! !!  The subspace X is constructed via Lanczos factorization, resulting in a symmetric !!  tridiagonal matrix T. The eigenvalues of A are approximated by those of T !!  and the eigenvectors are computed accordingly. !! !!  **References** !! !!  - Lanczos, C. (1950). \"An Iteration Method for the Solution of the Eigenvalue Problem !!  of Linear Differential and Integral Operators\". United States Governm. Press Office. !! !!  ### Syntax !! !!  ```fortran !!      call eighs(A, X, eigvals, residuals, info [, kdim] [,tolerance]) !!  ``` !! !!  ### Arguments !! !!  - `A`   :   Linear operator derived from `abstract_sym_linop_rsp`, `abstract_sym_linop_rdp`, !!              `abstract_hermitian_linop_csp` or `abstract_hermitian_linop_cdp` whose leading !!              eigenpairs need to be computed. It is an `intent(inout)` argument. !! !!  - `X`   :   Array of `abstract_vectors` with the same type and kind as `A`. On exit, it !!              contains the leading eigenvectors of `A`. Note that the dimension of `X` fixes !!              the number of eigenpairs computed. It is an `intent(out)` argument. !! !!  - `eigvals` :   Rank-1 array of `real` numbers. On exit, it contains the leading !!                  eigenvalues of `A`. It is an `intent(out)` argument. !! !!  - `residuals`   :   Rank-1 array of `real` numbers. On exit, it contains the residuals !!                      associated with each eigenpairs. It is an `intent(out)` argument. !! !!  - `info`    :   `integer` Information flag. !! !!  - `kdim` (*optional*)   :   `integer`, maximum dimension of the Krylov subspace used to !!                              approximate the leading eigenpairs. It is an optional `intent(in)` !!                              argument. By default, `kdim = 4*size(X)`. !! !!  - `tolerance` (*optional*)  :   `real` tolerance below which an eigenpair is considered as !!                                  being converged. It is an optional `intent(in)` argument. By default, !!                                  `tolerance = rtol_sp` or `tolerance = rtol_dp`. !!  @note !!  This implementation does not currently include an automatic restarting procedure !!  such as `krylov_schur` for `eigs`. This is work in progress. !!  @endnote module subroutine eighs_rsp ( A , X , eigvals , residuals , info , x0 , kdim , tolerance , write_intermediate ) implicit none ( type , external ) class ( abstract_sym_linop_rsp ), intent ( inout ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_rsp ), intent ( out ) :: X (:) !! Leading eigevectors of  \\mathbf{A} . real ( sp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of  \\mathbf{A} . real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpairs. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_rsp ), optional , intent ( in ) :: x0 !! Optional starting vector to generate the Krylov subspace. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? end subroutine eighs_rsp module subroutine eighs_rdp ( A , X , eigvals , residuals , info , x0 , kdim , tolerance , write_intermediate ) implicit none ( type , external ) class ( abstract_sym_linop_rdp ), intent ( inout ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_rdp ), intent ( out ) :: X (:) !! Leading eigevectors of  \\mathbf{A} . real ( dp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of  \\mathbf{A} . real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpairs. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_rdp ), optional , intent ( in ) :: x0 !! Optional starting vector to generate the Krylov subspace. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? end subroutine eighs_rdp module subroutine eighs_csp ( A , X , eigvals , residuals , info , x0 , kdim , tolerance , write_intermediate ) implicit none ( type , external ) class ( abstract_hermitian_linop_csp ), intent ( inout ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_csp ), intent ( out ) :: X (:) !! Leading eigevectors of  \\mathbf{A} . real ( sp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of  \\mathbf{A} . real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpairs. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_csp ), optional , intent ( in ) :: x0 !! Optional starting vector to generate the Krylov subspace. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? end subroutine eighs_csp module subroutine eighs_cdp ( A , X , eigvals , residuals , info , x0 , kdim , tolerance , write_intermediate ) implicit none ( type , external ) class ( abstract_hermitian_linop_cdp ), intent ( inout ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_cdp ), intent ( out ) :: X (:) !! Leading eigevectors of  \\mathbf{A} . real ( dp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of  \\mathbf{A} . real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpairs. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_cdp ), optional , intent ( in ) :: x0 !! Optional starting vector to generate the Krylov subspace. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? end subroutine eighs_cdp end interface !------------------------------------- !-----     Utility functions     ----- !------------------------------------- interface save_eigenspectrum !!  ### Description !! !!  Utility function to save the eigenspectrum computed from the Arnoldi factorization. !!  It outpost a .npy file. !! !!  ### Syntax !! !!  ```fortran !!      call save_eigenspectrum(eigvals, residuals, fname) !!  ``` !! !!  ### Arguments !! !!  - `eigvals`     :   `complex` rank-1 array containing the eigenvalues. It is an !!                      `intent(in)` argument. !! !!  - `residuals`   :   `real` rank-1 array containing the residuals associated to each !!                      eigenvalues. It is an `intent(in)` argument. !! !!  `fname` : Name of the file to save the eigenspectrum. It is an `intent(in)` argument. module subroutine save_eigenspectrum_rsp ( lambda , residuals , fname ) !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format. implicit none ( type , external ) real ( sp ), intent ( in ) :: lambda (:) !! Eigenalues. real ( sp ), intent ( in ) :: residuals (:) !! Residual of the corresponding Ritz eigenpairs. character ( len =* ), intent ( in ) :: fname !! Name of the output file. end subroutine save_eigenspectrum_rsp module subroutine save_eigenspectrum_rdp ( lambda , residuals , fname ) !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format. implicit none ( type , external ) real ( dp ), intent ( in ) :: lambda (:) !! Eigenalues. real ( dp ), intent ( in ) :: residuals (:) !! Residual of the corresponding Ritz eigenpairs. character ( len =* ), intent ( in ) :: fname !! Name of the output file. end subroutine save_eigenspectrum_rdp module subroutine save_eigenspectrum_csp ( lambda , residuals , fname ) !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format. implicit none ( type , external ) complex ( sp ), intent ( in ) :: lambda (:) !! Eigenalues. real ( sp ), intent ( in ) :: residuals (:) !! Residual of the corresponding Ritz eigenpairs. character ( len =* ), intent ( in ) :: fname !! Name of the output file. end subroutine save_eigenspectrum_csp module subroutine save_eigenspectrum_cdp ( lambda , residuals , fname ) !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format. implicit none ( type , external ) complex ( dp ), intent ( in ) :: lambda (:) !! Eigenalues. real ( dp ), intent ( in ) :: residuals (:) !! Residual of the corresponding Ritz eigenpairs. character ( len =* ), intent ( in ) :: fname !! Name of the output file. end subroutine save_eigenspectrum_cdp end interface interface eigs !!  ### Description !! !!  Computes the leading eigenpairs of a square linear operator A !!  using the Arnoldi iterative process. Given a square linear operator A, it finds !!  the leading eigenvalues and eigenvectors such that: !! !!   !!      Ax = \\lambda x !!   !! !!  or !! !!   !!      A&#94;H x = \\lambda x. !!   !! !!  The subspace X is constructed via Arnoldi factorization, resulting in an upper !!  Hessenberg matrix H. The eigenvalues of A are approximated by those of H !!  and the eigenvectors are computed accordingly. !! !!  **References** !! !!  - Arnoldi, W. E. (1951). \"The Principle of Minimized Iterations in the Solution of !!    the Matrix Eigenvalue Problem.\" Quarterly of Applied Mathematics, 9(1), 17–29. !! !!  ### Syntax !! !!  ```fortran !!      call eigs(A, X, eigvals, residuals, info [, kdim] [, select] [,tolerance] [, transpose]) !!  ``` !! !!  ### Arguments !! !!  - `A`   :   Linear operator derived from `abstract_sym_linop_rsp`, `abstract_sym_linop_rdp`, !!              `abstract_hermitian_linop_csp` or `abstract_hermitian_linop_cdp` whose leading !!              eigenpairs need to be computed. It is an `intent(inout)` argument. !! !!  - `X`   :   Array of `abstract_vectors` with the same type and kind as `A`. On exit, it !!              contains the leading eigenvectors of `A`. Note that the dimension of `X` fixes !!              the number of eigenpairs computed. It is an `intent(out)` argument. !! !!  - `eigvals` :   Rank-1 array of `real` numbers. On exit, it contains the leading !!                  eigenvalues of `A`. It is an `intent(out)` argument. !! !!  - `residuals`   :   Rank-1 array of `real` numbers. On exit, it contains the residuals !!                      associated with each eigenpairs. It is an `intent(out)` argument. !! !!  - `info`    :   `integer` Information flag. !! !!  - `kdim` (*optional*)   :   `integer`, maximum dimension of the Krylov subspace used to !!                              approximate the leading eigenpairs. It is an optional `intent(in)` !!                              argument. By default, `kdim = 4*size(X)`. !! !!  - `select` (*optional*) : Function to select which eigenvalues to compute. !! !!  - `tolerance` (*optional*)  :   `real` tolerance below which an eigenpair is considered as !!                                  being converged. It is an optional `intent(in)` argument. !!                                  By default, `tolerance = rtol_sp` or `tolerance = rtol_dp`. !! !!  - `transpose` (*optional*)  :   `logical` flag determining whether the eigenvalues of A !!                                  or A&#94;H need to be computed. It is an optional `intent(in)` !!                                  argument. module procedure eigs_rsp module procedure eigs_rdp module procedure eigs_csp module procedure eigs_cdp end interface contains !------------------------------------- !-----     UTILITY FUNCTIONS     ----- !------------------------------------- subroutine write_results_rsp ( filename , vals , res , tol ) !! Prints the intermediate results of iterative eigenvalue/singular value decompositions implicit none ( type , external ) character ( len =* ), intent ( in ) :: filename !! Output filename. This file will be overwritten real ( sp ), intent ( in ) :: vals (:) !! Intermediate values real ( sp ), intent ( inout ) :: res (:) !! Residuals real ( sp ), intent ( in ) :: tol !! Convergence tolerance ! internals integer :: i , k , idx , iostat integer , allocatable :: indices (:) character ( len = 100 ) :: errmsg character ( len =* ), parameter :: fmt = '(I6,2(2X,E16.9),2X,L4)' k = size ( vals ) if ( io_rank ()) then ! only IO rank writes allocate ( indices ( k ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"write_results_rsp\" ) call sort_index ( res , indices ) ! res is returned in sorted order open ( 1234 , file = filename , status = 'replace' , action = 'write' ) write ( 1234 , '(A6,2(A18),A6)' ) 'Iter' , 'value' , 'residual' , 'conv' do i = 1 , k idx = indices ( i ) write ( 1234 , fmt ) k , vals ( idx ), res ( i ), res ( i ) < tol end do close ( 1234 ) end if end subroutine write_results_rsp subroutine write_results_rdp ( filename , vals , res , tol ) !! Prints the intermediate results of iterative eigenvalue/singular value decompositions implicit none ( type , external ) character ( len =* ), intent ( in ) :: filename !! Output filename. This file will be overwritten real ( dp ), intent ( in ) :: vals (:) !! Intermediate values real ( dp ), intent ( inout ) :: res (:) !! Residuals real ( dp ), intent ( in ) :: tol !! Convergence tolerance ! internals integer :: i , k , idx , iostat integer , allocatable :: indices (:) character ( len = 100 ) :: errmsg character ( len =* ), parameter :: fmt = '(I6,2(2X,E16.9),2X,L4)' k = size ( vals ) if ( io_rank ()) then ! only IO rank writes allocate ( indices ( k ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"write_results_rdp\" ) call sort_index ( res , indices ) ! res is returned in sorted order open ( 1234 , file = filename , status = 'replace' , action = 'write' ) write ( 1234 , '(A6,2(A18),A6)' ) 'Iter' , 'value' , 'residual' , 'conv' do i = 1 , k idx = indices ( i ) write ( 1234 , fmt ) k , vals ( idx ), res ( i ), res ( i ) < tol end do close ( 1234 ) end if end subroutine write_results_rdp subroutine write_results_csp ( filename , vals , res , tol ) !! Prints the intermediate results of iterative eigenvalue/singular value decompositions implicit none ( type , external ) character ( len =* ), intent ( in ) :: filename !! Output filename. This file will be overwritten complex ( sp ), intent ( in ) :: vals (:) !! Intermediate values real ( sp ), intent ( inout ) :: res (:) !! Residuals real ( sp ), intent ( in ) :: tol !! Convergence tolerance ! internals integer :: i , k , idx , iostat integer , allocatable :: indices (:) character ( len = 100 ) :: errmsg real ( sp ) :: modulus character ( len =* ), parameter :: fmt = '(I6,4(2X,E16.9),2X,L4)' k = size ( vals ) if ( io_rank ()) then ! only IO rank writes allocate ( indices ( k ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"write_results_csp\" ) call sort_index ( res , indices ) ! res is returned in sorted order open ( 1234 , file = filename , status = 'replace' , action = 'write' ) write ( 1234 , '(A6,4(A18),A6)' ) 'Iter' , 'Re' , 'Im' , 'modulus' , 'residual' , 'conv' do i = 1 , k idx = indices ( i ) modulus = sqrt ( vals ( idx )% re ** 2 + vals ( idx )% im ** 2 ) write ( 1234 , fmt ) k , vals ( idx )% re , vals ( idx )% im , modulus , res ( i ), res ( i ) < tol end do close ( 1234 ) end if end subroutine write_results_csp subroutine write_results_cdp ( filename , vals , res , tol ) !! Prints the intermediate results of iterative eigenvalue/singular value decompositions implicit none ( type , external ) character ( len =* ), intent ( in ) :: filename !! Output filename. This file will be overwritten complex ( dp ), intent ( in ) :: vals (:) !! Intermediate values real ( dp ), intent ( inout ) :: res (:) !! Residuals real ( dp ), intent ( in ) :: tol !! Convergence tolerance ! internals integer :: i , k , idx , iostat integer , allocatable :: indices (:) character ( len = 100 ) :: errmsg real ( dp ) :: modulus character ( len =* ), parameter :: fmt = '(I6,4(2X,E16.9),2X,L4)' k = size ( vals ) if ( io_rank ()) then ! only IO rank writes allocate ( indices ( k ), stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"write_results_cdp\" ) call sort_index ( res , indices ) ! res is returned in sorted order open ( 1234 , file = filename , status = 'replace' , action = 'write' ) write ( 1234 , '(A6,4(A18),A6)' ) 'Iter' , 'Re' , 'Im' , 'modulus' , 'residual' , 'conv' do i = 1 , k idx = indices ( i ) modulus = sqrt ( vals ( idx )% re ** 2 + vals ( idx )% im ** 2 ) write ( 1234 , fmt ) k , vals ( idx )% re , vals ( idx )% im , modulus , res ( i ), res ( i ) < tol end do close ( 1234 ) end if end subroutine write_results_cdp elemental pure function compute_residual_rsp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. real ( sp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. real ( sp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( sp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function compute_residual_rsp elemental pure function compute_residual_rdp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. real ( dp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. real ( dp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( dp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function compute_residual_rdp elemental pure function compute_residual_csp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. complex ( sp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. complex ( sp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( sp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function compute_residual_csp elemental pure function compute_residual_cdp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. complex ( dp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. complex ( dp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( dp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function compute_residual_cdp module procedure save_eigenspectrum_rsp ! Internal variables. real ( sp ) :: array ( size ( lambda ), 2 ) array (:, 1 ) = lambda ; array (:, 2 ) = residuals ! Save the eigenspectrum to disk. call save_npy ( fname , array ) end procedure save_eigenspectrum_rsp module procedure save_eigenspectrum_rdp ! Internal variables. real ( dp ) :: array ( size ( lambda ), 2 ) array (:, 1 ) = lambda ; array (:, 2 ) = residuals ! Save the eigenspectrum to disk. call save_npy ( fname , array ) end procedure save_eigenspectrum_rdp module procedure save_eigenspectrum_csp ! Internal variables. real ( sp ) :: array ( size ( lambda ), 3 ) array (:, 1 ) = lambda % re ; array (:, 2 ) = lambda % im ; array (:, 3 ) = residuals ! Save the eigenspectrum to disk. call save_npy ( fname , array ) end procedure save_eigenspectrum_csp module procedure save_eigenspectrum_cdp ! Internal variables. real ( dp ) :: array ( size ( lambda ), 3 ) array (:, 1 ) = lambda % re ; array (:, 2 ) = lambda % im ; array (:, 3 ) = residuals ! Save the eigenspectrum to disk. call save_npy ( fname , array ) end procedure save_eigenspectrum_cdp !--------------------------------------------------- !-----     GENERAL EIGENVALUE COMPUTATIONS     ----- !--------------------------------------------------- subroutine eigs_rsp ( A , X , eigvals , residuals , info , x0 , kdim , tolerance , transpose , write_intermediate ) implicit none ( type , external ) class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_rsp ), intent ( out ) :: X (:) !! Leading eigenvectors of \\mathbf{A}. complex ( sp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of \\mathbf{A}. real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_rsp ), optional , intent ( in ) :: x0 !! Optional starting vector for generating the Krylov subspace. integer , optional , intent ( in ) :: kdim !! Maximum dimension of the Krylov subspace (optional). real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Krylov subspace and Krylov subspace dimension. class ( abstract_vector_rsp ), allocatable :: Xwrk (:) integer :: kdim_ , kstart ! Hessenberg matrix. real ( sp ), allocatable :: H (:, :) ! Working arrays for the eigenvectors and eigenvalues. real ( sp ), allocatable :: eigvecs_wrk (:, :) complex ( sp ), allocatable :: eigvals_wrk (:) real ( sp ), allocatable :: residuals_wrk (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'eigs_rsp' integer :: nev , conv integer :: i , j , k , niter , krst , iostat real ( sp ) :: tol , x0_norm real ( sp ) :: beta real ( sp ) :: alpha logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with optional parameters. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_sp ) outpost = optval ( write_intermediate , . true .) ! Allocate eigenvalues. allocate ( eigvals ( nev ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Xwrk ) if ( present ( x0 )) then call copy ( Xwrk ( 1 ), x0 ) x0_norm = x0 % norm (); call Xwrk ( 1 )% scal ( one_rsp / x0_norm ) else call Xwrk ( 1 )% rand (. true .) endif allocate ( H ( kdim_ + 1 , kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvecs_wrk ( kdim_ , kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvals_wrk ( kdim_ ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Ritz eigenpairs computation. H = 0.0_sp kstart = 1 ; conv = 0 ; niter = 0 ; krst = 1 krylovschur : do while ( conv < nev ) arnoldi_factorization : do k = kstart , kdim_ ! Arnoldi step. call arnoldi ( A , Xwrk , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) ! Spectral decomposition of the k x k Hessenberg matrix. eigvals_wrk = 0.0_sp ; eigvecs_wrk = 0.0_sp if ( time_lightkrylov ()) call timer % start ( 'eig' ) call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) if ( time_lightkrylov ()) call timer % stop ( 'eig' ) ! Compute residuals. beta = H ( k + 1 , k ) do i = 1 , k if ( eigvals_wrk ( i )% im > 0 ) then alpha = abs ( cmplx ( eigvecs_wrk ( k , i ), eigvecs_wrk ( k , i + 1 ), kind = sp )) else if ( eigvals_wrk ( i )% im < 0 ) then alpha = abs ( cmplx ( eigvecs_wrk ( k , i - 1 ), eigvecs_wrk ( k , i ), kind = sp )) else alpha = abs ( eigvecs_wrk ( k , i )) endif residuals_wrk ( i ) = compute_residual_rsp ( beta , alpha ) enddo ! Check convergence. niter = niter + 1 conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , niter , & & ' steps of the Arnoldi process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_csp ( eigs_output , eigvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nev ) exit arnoldi_factorization enddo arnoldi_factorization write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , krst , & & ' Krylov-Schur restarts of the Arnoldi process.' call log_information ( msg , this_module , this_procedure ) ! Krylov-Schur restarting procedure. krst = krst + 1 call krylov_schur ( kstart , Xwrk , H , median_selector ) ; kstart = kstart + 1 end do krylovschur !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) real ( sp ) :: abs_eigvals ( kdim_ ) ! Re-compute eigenvalues and eigenvectors. k = min ( k , kdim_ ); if ( time_lightkrylov ()) call timer % start ( 'eig' ) call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) if ( time_lightkrylov ()) call timer % stop ( 'eig' ) ! Sort eigenvalues. abs_eigvals = abs ( eigvals_wrk ) ; call sort_index ( abs_eigvals , indices , reverse = . true .) eigvals_wrk = eigvals_wrk ( indices ) ; eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( eigvecs_wrk ( j , i ), Xwrk ( j ), one_rsp ) enddo enddo info = niter if ( time_lightkrylov ()) call timer % stop ( this_procedure ) contains function median_selector ( lambda ) result ( selected ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: lambda (:) logical , allocatable :: selected (:) selected = abs ( lambda ) > median ( abs ( lambda )) end function median_selector end subroutine eigs_rsp subroutine eigs_rdp ( A , X , eigvals , residuals , info , x0 , kdim , tolerance , transpose , write_intermediate ) implicit none ( type , external ) class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_rdp ), intent ( out ) :: X (:) !! Leading eigenvectors of \\mathbf{A}. complex ( dp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of \\mathbf{A}. real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_rdp ), optional , intent ( in ) :: x0 !! Optional starting vector for generating the Krylov subspace. integer , optional , intent ( in ) :: kdim !! Maximum dimension of the Krylov subspace (optional). real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Krylov subspace and Krylov subspace dimension. class ( abstract_vector_rdp ), allocatable :: Xwrk (:) integer :: kdim_ , kstart ! Hessenberg matrix. real ( dp ), allocatable :: H (:, :) ! Working arrays for the eigenvectors and eigenvalues. real ( dp ), allocatable :: eigvecs_wrk (:, :) complex ( dp ), allocatable :: eigvals_wrk (:) real ( dp ), allocatable :: residuals_wrk (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'eigs_rdp' integer :: nev , conv integer :: i , j , k , niter , krst , iostat real ( dp ) :: tol , x0_norm real ( dp ) :: beta real ( dp ) :: alpha logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with optional parameters. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_dp ) outpost = optval ( write_intermediate , . true .) ! Allocate eigenvalues. allocate ( eigvals ( nev ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Xwrk ) if ( present ( x0 )) then call copy ( Xwrk ( 1 ), x0 ) x0_norm = x0 % norm (); call Xwrk ( 1 )% scal ( one_rdp / x0_norm ) else call Xwrk ( 1 )% rand (. true .) endif allocate ( H ( kdim_ + 1 , kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvecs_wrk ( kdim_ , kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvals_wrk ( kdim_ ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Ritz eigenpairs computation. H = 0.0_dp kstart = 1 ; conv = 0 ; niter = 0 ; krst = 1 krylovschur : do while ( conv < nev ) arnoldi_factorization : do k = kstart , kdim_ ! Arnoldi step. call arnoldi ( A , Xwrk , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) ! Spectral decomposition of the k x k Hessenberg matrix. eigvals_wrk = 0.0_dp ; eigvecs_wrk = 0.0_dp if ( time_lightkrylov ()) call timer % start ( 'eig' ) call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) if ( time_lightkrylov ()) call timer % stop ( 'eig' ) ! Compute residuals. beta = H ( k + 1 , k ) do i = 1 , k if ( eigvals_wrk ( i )% im > 0 ) then alpha = abs ( cmplx ( eigvecs_wrk ( k , i ), eigvecs_wrk ( k , i + 1 ), kind = dp )) else if ( eigvals_wrk ( i )% im < 0 ) then alpha = abs ( cmplx ( eigvecs_wrk ( k , i - 1 ), eigvecs_wrk ( k , i ), kind = dp )) else alpha = abs ( eigvecs_wrk ( k , i )) endif residuals_wrk ( i ) = compute_residual_rdp ( beta , alpha ) enddo ! Check convergence. niter = niter + 1 conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , niter , & & ' steps of the Arnoldi process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_cdp ( eigs_output , eigvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nev ) exit arnoldi_factorization enddo arnoldi_factorization write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , krst , & & ' Krylov-Schur restarts of the Arnoldi process.' call log_information ( msg , this_module , this_procedure ) ! Krylov-Schur restarting procedure. krst = krst + 1 call krylov_schur ( kstart , Xwrk , H , median_selector ) ; kstart = kstart + 1 end do krylovschur !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) real ( dp ) :: abs_eigvals ( kdim_ ) ! Re-compute eigenvalues and eigenvectors. k = min ( k , kdim_ ); if ( time_lightkrylov ()) call timer % start ( 'eig' ) call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) if ( time_lightkrylov ()) call timer % stop ( 'eig' ) ! Sort eigenvalues. abs_eigvals = abs ( eigvals_wrk ) ; call sort_index ( abs_eigvals , indices , reverse = . true .) eigvals_wrk = eigvals_wrk ( indices ) ; eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( eigvecs_wrk ( j , i ), Xwrk ( j ), one_rdp ) enddo enddo info = niter if ( time_lightkrylov ()) call timer % stop ( this_procedure ) contains function median_selector ( lambda ) result ( selected ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: lambda (:) logical , allocatable :: selected (:) selected = abs ( lambda ) > median ( abs ( lambda )) end function median_selector end subroutine eigs_rdp subroutine eigs_csp ( A , X , eigvals , residuals , info , x0 , kdim , tolerance , transpose , write_intermediate ) implicit none ( type , external ) class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_csp ), intent ( out ) :: X (:) !! Leading eigenvectors of \\mathbf{A}. complex ( sp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of \\mathbf{A}. real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_csp ), optional , intent ( in ) :: x0 !! Optional starting vector for generating the Krylov subspace. integer , optional , intent ( in ) :: kdim !! Maximum dimension of the Krylov subspace (optional). real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Krylov subspace and Krylov subspace dimension. class ( abstract_vector_csp ), allocatable :: Xwrk (:) integer :: kdim_ , kstart ! Hessenberg matrix. complex ( sp ), allocatable :: H (:, :) ! Working arrays for the eigenvectors and eigenvalues. complex ( sp ), allocatable :: eigvecs_wrk (:, :) complex ( sp ), allocatable :: eigvals_wrk (:) real ( sp ), allocatable :: residuals_wrk (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'eigs_csp' integer :: nev , conv integer :: i , j , k , niter , krst , iostat real ( sp ) :: tol , x0_norm complex ( sp ) :: beta logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with optional parameters. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_sp ) outpost = optval ( write_intermediate , . true .) ! Allocate eigenvalues. allocate ( eigvals ( nev ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Xwrk ) if ( present ( x0 )) then call copy ( Xwrk ( 1 ), x0 ) x0_norm = x0 % norm (); call Xwrk ( 1 )% scal ( one_csp / x0_norm ) else call Xwrk ( 1 )% rand (. true .) endif allocate ( H ( kdim_ + 1 , kdim_ ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvecs_wrk ( kdim_ , kdim_ ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvals_wrk ( kdim_ ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Ritz eigenpairs computation. H = 0.0_sp kstart = 1 ; conv = 0 ; niter = 0 ; krst = 1 krylovschur : do while ( conv < nev ) arnoldi_factorization : do k = kstart , kdim_ ! Arnoldi step. call arnoldi ( A , Xwrk , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) ! Spectral decomposition of the k x k Hessenberg matrix. eigvals_wrk = 0.0_sp ; eigvecs_wrk = 0.0_sp if ( time_lightkrylov ()) call timer % start ( 'eig' ) call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) if ( time_lightkrylov ()) call timer % stop ( 'eig' ) ! Compute residuals. beta = H ( k + 1 , k ) residuals_wrk (: k ) = compute_residual_csp ( beta , eigvecs_wrk ( k ,: k )) ! Check convergence. niter = niter + 1 conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , niter , & & ' steps of the Arnoldi process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_csp ( eigs_output , eigvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nev ) exit arnoldi_factorization enddo arnoldi_factorization write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , krst , & & ' Krylov-Schur restarts of the Arnoldi process.' call log_information ( msg , this_module , this_procedure ) ! Krylov-Schur restarting procedure. krst = krst + 1 call krylov_schur ( kstart , Xwrk , H , median_selector ) ; kstart = kstart + 1 end do krylovschur !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) real ( sp ) :: abs_eigvals ( kdim_ ) ! Re-compute eigenvalues and eigenvectors. k = min ( k , kdim_ ); if ( time_lightkrylov ()) call timer % start ( 'eig' ) call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) if ( time_lightkrylov ()) call timer % stop ( 'eig' ) ! Sort eigenvalues. abs_eigvals = abs ( eigvals_wrk ) ; call sort_index ( abs_eigvals , indices , reverse = . true .) eigvals_wrk = eigvals_wrk ( indices ) ; eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( eigvecs_wrk ( j , i ), Xwrk ( j ), one_csp ) enddo enddo info = niter if ( time_lightkrylov ()) call timer % stop ( this_procedure ) contains function median_selector ( lambda ) result ( selected ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: lambda (:) logical , allocatable :: selected (:) selected = abs ( lambda ) > median ( abs ( lambda )) end function median_selector end subroutine eigs_csp subroutine eigs_cdp ( A , X , eigvals , residuals , info , x0 , kdim , tolerance , transpose , write_intermediate ) implicit none ( type , external ) class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_cdp ), intent ( out ) :: X (:) !! Leading eigenvectors of \\mathbf{A}. complex ( dp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of \\mathbf{A}. real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. class ( abstract_vector_cdp ), optional , intent ( in ) :: x0 !! Optional starting vector for generating the Krylov subspace. integer , optional , intent ( in ) :: kdim !! Maximum dimension of the Krylov subspace (optional). real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. logical , optional , intent ( in ) :: write_intermediate !! Write intermediate eigenvalues to file during iteration? !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Krylov subspace and Krylov subspace dimension. class ( abstract_vector_cdp ), allocatable :: Xwrk (:) integer :: kdim_ , kstart ! Hessenberg matrix. complex ( dp ), allocatable :: H (:, :) ! Working arrays for the eigenvectors and eigenvalues. complex ( dp ), allocatable :: eigvecs_wrk (:, :) complex ( dp ), allocatable :: eigvals_wrk (:) real ( dp ), allocatable :: residuals_wrk (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'eigs_cdp' integer :: nev , conv integer :: i , j , k , niter , krst , iostat real ( dp ) :: tol , x0_norm complex ( dp ) :: beta logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with optional parameters. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_dp ) outpost = optval ( write_intermediate , . true .) ! Allocate eigenvalues. allocate ( eigvals ( nev ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Xwrk ) if ( present ( x0 )) then call copy ( Xwrk ( 1 ), x0 ) x0_norm = x0 % norm (); call Xwrk ( 1 )% scal ( one_cdp / x0_norm ) else call Xwrk ( 1 )% rand (. true .) endif allocate ( H ( kdim_ + 1 , kdim_ ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvecs_wrk ( kdim_ , kdim_ ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvals_wrk ( kdim_ ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Ritz eigenpairs computation. H = 0.0_dp kstart = 1 ; conv = 0 ; niter = 0 ; krst = 1 krylovschur : do while ( conv < nev ) arnoldi_factorization : do k = kstart , kdim_ ! Arnoldi step. call arnoldi ( A , Xwrk , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) ! Spectral decomposition of the k x k Hessenberg matrix. eigvals_wrk = 0.0_dp ; eigvecs_wrk = 0.0_dp if ( time_lightkrylov ()) call timer % start ( 'eig' ) call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) if ( time_lightkrylov ()) call timer % stop ( 'eig' ) ! Compute residuals. beta = H ( k + 1 , k ) residuals_wrk (: k ) = compute_residual_cdp ( beta , eigvecs_wrk ( k ,: k )) ! Check convergence. niter = niter + 1 conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , niter , & & ' steps of the Arnoldi process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_cdp ( eigs_output , eigvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nev ) exit arnoldi_factorization enddo arnoldi_factorization write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , krst , & & ' Krylov-Schur restarts of the Arnoldi process.' call log_information ( msg , this_module , this_procedure ) ! Krylov-Schur restarting procedure. krst = krst + 1 call krylov_schur ( kstart , Xwrk , H , median_selector ) ; kstart = kstart + 1 end do krylovschur !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) real ( dp ) :: abs_eigvals ( kdim_ ) ! Re-compute eigenvalues and eigenvectors. k = min ( k , kdim_ ); if ( time_lightkrylov ()) call timer % start ( 'eig' ) call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) if ( time_lightkrylov ()) call timer % stop ( 'eig' ) ! Sort eigenvalues. abs_eigvals = abs ( eigvals_wrk ) ; call sort_index ( abs_eigvals , indices , reverse = . true .) eigvals_wrk = eigvals_wrk ( indices ) ; eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( eigvecs_wrk ( j , i ), Xwrk ( j ), one_cdp ) enddo enddo info = niter if ( time_lightkrylov ()) call timer % stop ( this_procedure ) contains function median_selector ( lambda ) result ( selected ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: lambda (:) logical , allocatable :: selected (:) selected = abs ( lambda ) > median ( abs ( lambda )) end function median_selector end subroutine eigs_cdp end module LightKrylov_IterativeSolvers","tags":"","url":"sourcefile/iterativesolvers.f90.html"},{"title":"AbstractSystems.f90 – LightKrylov","text":"Source Code module LightKrylov_AbstractSystems !!  This module provides the abstract types necessary to define an algebraic system of !!  nonlinear equations to be solved using the Newton method. use stdlib_optval , only : optval use LightKrylov_Logger use LightKrylov_Constants use LightKrylov_Timer_Utils , only : lightkrylov_timer use LightKrylov_AbstractVectors use LightKrylov_AbstractLinops implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_Systems' character ( len =* ), parameter :: this_module_long = 'LK_AbstractSystems' ! Base type for abstract systems. type , abstract , public :: abstract_system !!  Base type to define an abstract system. All other system types defined !!  in `LightKrylov` derive from this fundamental one. !! !!  @warning !!  Users should not extend this abstract class to define their own types. !!  @endwarning private integer :: eval_counter = 0 type ( lightkrylov_timer ) :: eval_timer = lightkrylov_timer ( 'system eval timer' ) contains procedure , pass ( self ), public :: get_eval_counter !! Return eval counter value procedure , pass ( self ), public :: reset_eval_counter !! Reset eval counter procedure , pass ( self ), public :: print_timer_info !! Print current timing data procedure , pass ( self ), public :: reset_timer => reset_eval_timer !! Reset current timing data procedure , pass ( self ), public :: finalize_timer => finalize_eval_timer !! Finalize timer and print complete history end type abstract_system !---------------------------------------------------------------------------- !-----     ABSTRACT GENERAL real(sp) SYSTEM DEFINITION WITH kind=sp     ----- !---------------------------------------------------------------------------- ! Abstract Jacobian linop for kind=sp type , abstract , extends ( abstract_linop_rsp ), public :: abstract_jacobian_linop_rsp !! Abstract type for the local linearization of the system around the state X. !! This type is intended for use within the abstract_system type. class ( abstract_vector_rsp ), allocatable :: X !! System state around which the equatons are linearized. contains end type abstract_jacobian_linop_rsp ! Abstract system for kind=sp. type , abstract , extends ( abstract_system ), public :: abstract_system_rsp !! Base type to extend in order to define a real(sp)-valued system for !! Newton fixed-point iteration via the Jacobian. class ( abstract_jacobian_linop_rsp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_rsp ), pass ( self ), deferred , public :: response !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . ! Wrapper including counter increment procedure , pass ( self ), public :: eval => eval_rsp !! Wrapper for response including the counter increment end type abstract_system_rsp abstract interface subroutine abstract_eval_rsp ( self , vec_in , vec_out , atol ) !! Interface for the evaluation of the system response. use LightKrylov_AbstractVectors import abstract_system_rsp , sp implicit none ( type , external ) class ( abstract_system_rsp ), intent ( inout ) :: self !! System class ( abstract_vector_rsp ), intent ( in ) :: vec_in !! State class ( abstract_vector_rsp ), intent ( out ) :: vec_out !! Response real ( sp ), intent ( in ) :: atol !! Solver tolerance end subroutine abstract_eval_rsp end interface !---------------------------------------------------------------------------- !-----     ABSTRACT GENERAL real(dp) SYSTEM DEFINITION WITH kind=dp     ----- !---------------------------------------------------------------------------- ! Abstract Jacobian linop for kind=dp type , abstract , extends ( abstract_linop_rdp ), public :: abstract_jacobian_linop_rdp !! Abstract type for the local linearization of the system around the state X. !! This type is intended for use within the abstract_system type. class ( abstract_vector_rdp ), allocatable :: X !! System state around which the equatons are linearized. contains end type abstract_jacobian_linop_rdp ! Abstract system for kind=dp. type , abstract , extends ( abstract_system ), public :: abstract_system_rdp !! Base type to extend in order to define a real(dp)-valued system for !! Newton fixed-point iteration via the Jacobian. class ( abstract_jacobian_linop_rdp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_rdp ), pass ( self ), deferred , public :: response !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . ! Wrapper including counter increment procedure , pass ( self ), public :: eval => eval_rdp !! Wrapper for response including the counter increment end type abstract_system_rdp abstract interface subroutine abstract_eval_rdp ( self , vec_in , vec_out , atol ) !! Interface for the evaluation of the system response. use LightKrylov_AbstractVectors import abstract_system_rdp , dp implicit none ( type , external ) class ( abstract_system_rdp ), intent ( inout ) :: self !! System class ( abstract_vector_rdp ), intent ( in ) :: vec_in !! State class ( abstract_vector_rdp ), intent ( out ) :: vec_out !! Response real ( dp ), intent ( in ) :: atol !! Solver tolerance end subroutine abstract_eval_rdp end interface !---------------------------------------------------------------------------- !-----     ABSTRACT GENERAL complex(sp) SYSTEM DEFINITION WITH kind=sp     ----- !---------------------------------------------------------------------------- ! Abstract Jacobian linop for kind=sp type , abstract , extends ( abstract_linop_csp ), public :: abstract_jacobian_linop_csp !! Abstract type for the local linearization of the system around the state X. !! This type is intended for use within the abstract_system type. class ( abstract_vector_csp ), allocatable :: X !! System state around which the equatons are linearized. contains end type abstract_jacobian_linop_csp ! Abstract system for kind=sp. type , abstract , extends ( abstract_system ), public :: abstract_system_csp !! Base type to extend in order to define a complex(sp)-valued system for !! Newton fixed-point iteration via the Jacobian. class ( abstract_jacobian_linop_csp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_csp ), pass ( self ), deferred , public :: response !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . ! Wrapper including counter increment procedure , pass ( self ), public :: eval => eval_csp !! Wrapper for response including the counter increment end type abstract_system_csp abstract interface subroutine abstract_eval_csp ( self , vec_in , vec_out , atol ) !! Interface for the evaluation of the system response. use LightKrylov_AbstractVectors import abstract_system_csp , sp implicit none ( type , external ) class ( abstract_system_csp ), intent ( inout ) :: self !! System class ( abstract_vector_csp ), intent ( in ) :: vec_in !! State class ( abstract_vector_csp ), intent ( out ) :: vec_out !! Response real ( sp ), intent ( in ) :: atol !! Solver tolerance end subroutine abstract_eval_csp end interface !---------------------------------------------------------------------------- !-----     ABSTRACT GENERAL complex(dp) SYSTEM DEFINITION WITH kind=dp     ----- !---------------------------------------------------------------------------- ! Abstract Jacobian linop for kind=dp type , abstract , extends ( abstract_linop_cdp ), public :: abstract_jacobian_linop_cdp !! Abstract type for the local linearization of the system around the state X. !! This type is intended for use within the abstract_system type. class ( abstract_vector_cdp ), allocatable :: X !! System state around which the equatons are linearized. contains end type abstract_jacobian_linop_cdp ! Abstract system for kind=dp. type , abstract , extends ( abstract_system ), public :: abstract_system_cdp !! Base type to extend in order to define a complex(dp)-valued system for !! Newton fixed-point iteration via the Jacobian. class ( abstract_jacobian_linop_cdp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_cdp ), pass ( self ), deferred , public :: response !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . ! Wrapper including counter increment procedure , pass ( self ), public :: eval => eval_cdp !! Wrapper for response including the counter increment end type abstract_system_cdp abstract interface subroutine abstract_eval_cdp ( self , vec_in , vec_out , atol ) !! Interface for the evaluation of the system response. use LightKrylov_AbstractVectors import abstract_system_cdp , dp implicit none ( type , external ) class ( abstract_system_cdp ), intent ( inout ) :: self !! System class ( abstract_vector_cdp ), intent ( in ) :: vec_in !! State class ( abstract_vector_cdp ), intent ( out ) :: vec_out !! Response real ( dp ), intent ( in ) :: atol !! Solver tolerance end subroutine abstract_eval_cdp end interface contains !--------------------------------------------------------------- !-----     Getter/Setter routines for abstract_systems     ----- !--------------------------------------------------------------- pure integer function get_eval_counter ( self ) result ( count ) !! Getter function for the number of system evaluations. implicit none ( type , external ) class ( abstract_system ), intent ( in ) :: self count = self % eval_counter end function get_eval_counter subroutine reset_eval_counter ( self , procedure , counter , reset_timer , soft_reset , clean_timer ) !! Setter function to reset the system evaluation counter. implicit none ( type , external ) class ( abstract_system ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: procedure !! name of the caller routine integer , optional , intent ( in ) :: counter !! optional flag to reset to an integer other than zero. logical , optional , intent ( in ) :: reset_timer !! optional flag to reset also the timer logical , optional , intent ( in ) :: soft_reset !! optional flag to choose whether to save previous timing data (default: .true.) logical , optional , intent ( in ) :: clean_timer !! optional flag to choose whether to fully reset the timer (default: .false.) ! internals integer :: counter_ , count_old logical :: reset_timer_ character ( len = 128 ) :: msg counter_ = optval ( counter , 0 ) count_old = self % get_eval_counter () reset_timer_ = optval ( reset_timer , . true .) if ( count_old /= 0 . or . counter_ /= 0 ) then write ( msg , '(A,I0,A,I0,A)' ) 'Total number of evals: ' , count_old , '. Resetting counter to ' , counter_ , '.' call log_message ( msg , this_module , 'reset_eval_counter(' // trim ( procedure ) // ')' ) self % eval_counter = counter_ end if if ( reset_timer_ ) call self % reset_timer ( soft_reset , clean_timer ) return end subroutine reset_eval_counter subroutine print_timer_info ( self ) !! Print the current timing data for the system evaluation. !! Note: Wrapper of the corresponding routine from lightkrylov_timer implicit none ( type , external ) class ( abstract_system ), intent ( inout ) :: self call self % eval_timer % print_info () end subroutine print_timer_info subroutine reset_eval_timer ( self , soft , clean ) !! Setter routine to reset the system evaluation timer. !! Note: Wrapper of the corresponding routine from lightkrylov_timer implicit none ( type , external ) class ( abstract_system ), intent ( inout ) :: self logical , optional , intent ( in ) :: soft logical , optional , intent ( in ) :: clean call self % eval_timer % reset ( soft , clean , verbose = . true .) end subroutine reset_eval_timer subroutine finalize_eval_timer ( self ) !! Finalize the system evaluation timer and print summary. !! Note: Wrapper of the corresponding routine from lightkrylov_timer implicit none ( type , external ) class ( abstract_system ), intent ( inout ) :: self call self % eval_timer % finalize () end subroutine finalize_eval_timer !---------------------------------------------------------------------- !-----     Wrappers for system response to increment counters     ----- !---------------------------------------------------------------------- subroutine eval_rsp ( self , vec_in , vec_out , atol ) implicit none ( type , external ) class ( abstract_system_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out real ( sp ), intent ( in ) :: atol ! internal character ( len = 128 ) :: msg self % eval_counter = self % eval_counter + 1 write ( msg , '(I0,1X,A)' ) self % eval_counter , 'start' call log_debug ( msg , this_module , 'response' ) call self % eval_timer % start () call self % response ( vec_in , vec_out , atol ) call self % eval_timer % stop () write ( msg , '(I0,1X,A)' ) self % eval_counter , 'end' call log_debug ( msg , this_module , 'response' ) return end subroutine eval_rsp subroutine eval_rdp ( self , vec_in , vec_out , atol ) implicit none ( type , external ) class ( abstract_system_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out real ( dp ), intent ( in ) :: atol ! internal character ( len = 128 ) :: msg self % eval_counter = self % eval_counter + 1 write ( msg , '(I0,1X,A)' ) self % eval_counter , 'start' call log_debug ( msg , this_module , 'response' ) call self % eval_timer % start () call self % response ( vec_in , vec_out , atol ) call self % eval_timer % stop () write ( msg , '(I0,1X,A)' ) self % eval_counter , 'end' call log_debug ( msg , this_module , 'response' ) return end subroutine eval_rdp subroutine eval_csp ( self , vec_in , vec_out , atol ) implicit none ( type , external ) class ( abstract_system_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out real ( sp ), intent ( in ) :: atol ! internal character ( len = 128 ) :: msg self % eval_counter = self % eval_counter + 1 write ( msg , '(I0,1X,A)' ) self % eval_counter , 'start' call log_debug ( msg , this_module , 'response' ) call self % eval_timer % start () call self % response ( vec_in , vec_out , atol ) call self % eval_timer % stop () write ( msg , '(I0,1X,A)' ) self % eval_counter , 'end' call log_debug ( msg , this_module , 'response' ) return end subroutine eval_csp subroutine eval_cdp ( self , vec_in , vec_out , atol ) implicit none ( type , external ) class ( abstract_system_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out real ( dp ), intent ( in ) :: atol ! internal character ( len = 128 ) :: msg self % eval_counter = self % eval_counter + 1 write ( msg , '(I0,1X,A)' ) self % eval_counter , 'start' call log_debug ( msg , this_module , 'response' ) call self % eval_timer % start () call self % response ( vec_in , vec_out , atol ) call self % eval_timer % stop () write ( msg , '(I0,1X,A)' ) self % eval_counter , 'end' call log_debug ( msg , this_module , 'response' ) return end subroutine eval_cdp end module LightKrylov_AbstractSystems","tags":"","url":"sourcefile/abstractsystems.f90.html"},{"title":"AbstractLinops.f90 – LightKrylov","text":"Source Code module LightKrylov_AbstractLinops !!  This module provides the base classes `abtract_linop_rsp`, `abstract_linop_rdp`, !!  `abstract_linop_csp` and `abstract_linop_cdp` which can be used to define your own !!  linear operators. To do so, you simply need to provide two type-bound procedures: !! !!  - `matvec(self, vec_in, vec_out)`   :   Computes the matrix-vector product. !!  - `rmatvec(self, vec_in, vec_out)   :   Computes the transpose matrix-vector product. !! !!  It also provides extended types to define the identity operator, symmetric linear !!  operators, scalar-multiplication of a linear multiplication, as well as addition !!  of two linear operators. use stdlib_optval , only : optval use stdlib_linalg_blas , only : gemv use LightKrylov_Logger use LightKrylov_Constants use LightKrylov_Utils use LightKrylov_Timer_Utils , only : lightkrylov_timer use LightKrylov_AbstractVectors implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_Linops' character ( len =* ), parameter :: this_module_long = 'Lightkrylov_AbstractLinops' type , abstract , public :: abstract_linop !!  Base type to define an abstract linear operator. All other operator types defined !!  in `LightKrylov` derive from this fundamental one. !! !!  @warning !!  Users should not extend this abstract class to define their own types. !!  @endwarning integer , private :: matvec_counter = 0 integer , private :: rmatvec_counter = 0 type ( lightkrylov_timer ) :: matvec_timer = lightkrylov_timer ( 'matvec timer' ) type ( lightkrylov_timer ) :: rmatvec_timer = lightkrylov_timer ( 'rmatvec timer' ) contains procedure , pass ( self ), public :: get_counter !! Return matvec/rmatvec counter value procedure , pass ( self ), public :: reset_counter !! Reset matvec/rmatvec counter procedure , pass ( self ), public :: print_timer_info !! Print current timing data procedure , pass ( self ), public :: reset_timer => reset_linop_timer !! Reset current timing data procedure , pass ( self ), public :: finalize_timer => finalize_linop_timer !! Finalize timers and print complete history_info end type abstract_linop type , abstract , extends ( abstract_linop ), public :: abstract_sym_linop end type abstract_sym_linop !------------------------------------------------------------------------------ !-----     Definition of an abstract real(sp) operator with kind=sp     ----- !------------------------------------------------------------------------------ type , abstract , extends ( abstract_linop ), public :: abstract_linop_rsp !! Base type to extend in order to define a real(sp)-valued linear operator. contains private ! User defined procedures procedure ( abstract_matvec_rsp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_rsp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_matvec_rsp !! Wrapper for matvec including the counter increment procedure , pass ( self ), public :: apply_rmatvec => apply_rmatvec_rsp !! Wrapper for rmatvec including the counter increment end type abstract_linop_rsp abstract interface subroutine abstract_matvec_rsp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use lightkrylov_AbstractVectors import abstract_linop_rsp implicit none ( type , external ) class ( abstract_linop_rsp ) , intent ( inout ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_rsp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_rsp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_matvec_rsp end interface type , extends ( abstract_linop_rsp ), public :: adjoint_linop_rsp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` switched. class ( abstract_linop_rsp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_rsp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_rsp end type adjoint_linop_rsp !-------------------------------------------------------------------------------------------- !-----     Definition of an abstract real(sp) exponential propagator with kind=sp     ----- !-------------------------------------------------------------------------------------------- type , abstract , extends ( abstract_linop_rsp ), public :: abstract_exptA_linop_rsp !! Utility type to define the exponential propagator  \\mathbf{\\Phi}_\\tau  which is the linear map !! corresponding to the matrix exponential of the (possibly time-dependent) system Jacobian !!  \\mathbf{L}(t)  over a time horizon  \\tau  as: !! !!  \\mathbf{\\Phi}_\\tau = \\int_0&#94;\\tau \\mathbf{L}(t) \\: \\text{d}t  !! !! Note that explicit knowledge or definition of the Jacobian is not required. This utility function !! is intended for the use in conjuction with a time-stepper algorithm that computes the integral !! directly. !! !!  @warning !!  While it is not necessary to use this utility operator, it is strongly recommended for operators !!  that correspond to exponential propagators to extend from this abstract type to allow for more !!  rigorous type checks in the application. !!  @endwarning real ( sp ), public :: tau !! Time horizon for the temporal integration. This variable must be set when the operator is instantiated. end type abstract_exptA_linop_rsp !------------------------------------------------------------------------------ !-----     Definition of an abstract real(dp) operator with kind=dp     ----- !------------------------------------------------------------------------------ type , abstract , extends ( abstract_linop ), public :: abstract_linop_rdp !! Base type to extend in order to define a real(dp)-valued linear operator. contains private ! User defined procedures procedure ( abstract_matvec_rdp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_rdp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_matvec_rdp !! Wrapper for matvec including the counter increment procedure , pass ( self ), public :: apply_rmatvec => apply_rmatvec_rdp !! Wrapper for rmatvec including the counter increment end type abstract_linop_rdp abstract interface subroutine abstract_matvec_rdp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use lightkrylov_AbstractVectors import abstract_linop_rdp implicit none ( type , external ) class ( abstract_linop_rdp ) , intent ( inout ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_rdp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_rdp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_matvec_rdp end interface type , extends ( abstract_linop_rdp ), public :: adjoint_linop_rdp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` switched. class ( abstract_linop_rdp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_rdp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_rdp end type adjoint_linop_rdp !-------------------------------------------------------------------------------------------- !-----     Definition of an abstract real(dp) exponential propagator with kind=dp     ----- !-------------------------------------------------------------------------------------------- type , abstract , extends ( abstract_linop_rdp ), public :: abstract_exptA_linop_rdp !! Utility type to define the exponential propagator  \\mathbf{\\Phi}_\\tau  which is the linear map !! corresponding to the matrix exponential of the (possibly time-dependent) system Jacobian !!  \\mathbf{L}(t)  over a time horizon  \\tau  as: !! !!  \\mathbf{\\Phi}_\\tau = \\int_0&#94;\\tau \\mathbf{L}(t) \\: \\text{d}t  !! !! Note that explicit knowledge or definition of the Jacobian is not required. This utility function !! is intended for the use in conjuction with a time-stepper algorithm that computes the integral !! directly. !! !!  @warning !!  While it is not necessary to use this utility operator, it is strongly recommended for operators !!  that correspond to exponential propagators to extend from this abstract type to allow for more !!  rigorous type checks in the application. !!  @endwarning real ( dp ), public :: tau !! Time horizon for the temporal integration. This variable must be set when the operator is instantiated. end type abstract_exptA_linop_rdp !------------------------------------------------------------------------------ !-----     Definition of an abstract complex(sp) operator with kind=sp     ----- !------------------------------------------------------------------------------ type , abstract , extends ( abstract_linop ), public :: abstract_linop_csp !! Base type to extend in order to define a complex(sp)-valued linear operator. contains private ! User defined procedures procedure ( abstract_matvec_csp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_csp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_matvec_csp !! Wrapper for matvec including the counter increment procedure , pass ( self ), public :: apply_rmatvec => apply_rmatvec_csp !! Wrapper for rmatvec including the counter increment end type abstract_linop_csp abstract interface subroutine abstract_matvec_csp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use lightkrylov_AbstractVectors import abstract_linop_csp implicit none ( type , external ) class ( abstract_linop_csp ) , intent ( inout ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_csp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_csp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_matvec_csp end interface type , extends ( abstract_linop_csp ), public :: adjoint_linop_csp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` switched. class ( abstract_linop_csp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_csp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_csp end type adjoint_linop_csp !-------------------------------------------------------------------------------------------- !-----     Definition of an abstract complex(sp) exponential propagator with kind=sp     ----- !-------------------------------------------------------------------------------------------- type , abstract , extends ( abstract_linop_csp ), public :: abstract_exptA_linop_csp !! Utility type to define the exponential propagator  \\mathbf{\\Phi}_\\tau  which is the linear map !! corresponding to the matrix exponential of the (possibly time-dependent) system Jacobian !!  \\mathbf{L}(t)  over a time horizon  \\tau  as: !! !!  \\mathbf{\\Phi}_\\tau = \\int_0&#94;\\tau \\mathbf{L}(t) \\: \\text{d}t  !! !! Note that explicit knowledge or definition of the Jacobian is not required. This utility function !! is intended for the use in conjuction with a time-stepper algorithm that computes the integral !! directly. !! !!  @warning !!  While it is not necessary to use this utility operator, it is strongly recommended for operators !!  that correspond to exponential propagators to extend from this abstract type to allow for more !!  rigorous type checks in the application. !!  @endwarning real ( sp ), public :: tau !! Time horizon for the temporal integration. This variable must be set when the operator is instantiated. end type abstract_exptA_linop_csp !------------------------------------------------------------------------------ !-----     Definition of an abstract complex(dp) operator with kind=dp     ----- !------------------------------------------------------------------------------ type , abstract , extends ( abstract_linop ), public :: abstract_linop_cdp !! Base type to extend in order to define a complex(dp)-valued linear operator. contains private ! User defined procedures procedure ( abstract_matvec_cdp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_cdp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_matvec_cdp !! Wrapper for matvec including the counter increment procedure , pass ( self ), public :: apply_rmatvec => apply_rmatvec_cdp !! Wrapper for rmatvec including the counter increment end type abstract_linop_cdp abstract interface subroutine abstract_matvec_cdp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use lightkrylov_AbstractVectors import abstract_linop_cdp implicit none ( type , external ) class ( abstract_linop_cdp ) , intent ( inout ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_cdp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_cdp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_matvec_cdp end interface type , extends ( abstract_linop_cdp ), public :: adjoint_linop_cdp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` switched. class ( abstract_linop_cdp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_cdp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_cdp end type adjoint_linop_cdp !-------------------------------------------------------------------------------------------- !-----     Definition of an abstract complex(dp) exponential propagator with kind=dp     ----- !-------------------------------------------------------------------------------------------- type , abstract , extends ( abstract_linop_cdp ), public :: abstract_exptA_linop_cdp !! Utility type to define the exponential propagator  \\mathbf{\\Phi}_\\tau  which is the linear map !! corresponding to the matrix exponential of the (possibly time-dependent) system Jacobian !!  \\mathbf{L}(t)  over a time horizon  \\tau  as: !! !!  \\mathbf{\\Phi}_\\tau = \\int_0&#94;\\tau \\mathbf{L}(t) \\: \\text{d}t  !! !! Note that explicit knowledge or definition of the Jacobian is not required. This utility function !! is intended for the use in conjuction with a time-stepper algorithm that computes the integral !! directly. !! !!  @warning !!  While it is not necessary to use this utility operator, it is strongly recommended for operators !!  that correspond to exponential propagators to extend from this abstract type to allow for more !!  rigorous type checks in the application. !!  @endwarning real ( dp ), public :: tau !! Time horizon for the temporal integration. This variable must be set when the operator is instantiated. end type abstract_exptA_linop_cdp interface adjoint module procedure initialize_adjoint_rsp module procedure initialize_adjoint_rdp module procedure initialize_adjoint_csp module procedure initialize_adjoint_cdp end interface public :: adjoint !-------------------------------------------------- !-----     Definition of the Identity map     ----- !-------------------------------------------------- type , extends ( abstract_linop_rsp ), public :: Id_rsp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_rsp procedure , pass ( self ), public :: rmatvec => id_matvec_rsp end type Id_rsp type , extends ( abstract_linop_rdp ), public :: Id_rdp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_rdp procedure , pass ( self ), public :: rmatvec => id_matvec_rdp end type Id_rdp type , extends ( abstract_linop_csp ), public :: Id_csp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_csp procedure , pass ( self ), public :: rmatvec => id_matvec_csp end type Id_csp type , extends ( abstract_linop_cdp ), public :: Id_cdp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_cdp procedure , pass ( self ), public :: rmatvec => id_matvec_cdp end type Id_cdp !---------------------------------------------- !-----     Definition of scaled linop     ----- !---------------------------------------------- type , extends ( abstract_linop_rsp ), public :: scaled_linop_rsp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a real-valued operator and !!  \\sigma \\in \\mathbb{R} . The definitions of `matvec` and `rmatvec` are directly inherited from those used to define !! `A` and do not have to be defined by the user. class ( abstract_linop_rsp ), allocatable :: A !! Base linear operator to be scaled. real ( sp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_rsp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_rsp end type scaled_linop_rsp type , extends ( abstract_linop_rdp ), public :: scaled_linop_rdp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a real-valued operator and !!  \\sigma \\in \\mathbb{R} . The definitions of `matvec` and `rmatvec` are directly inherited from those used to define !! `A` and do not have to be defined by the user. class ( abstract_linop_rdp ), allocatable :: A !! Base linear operator to be scaled. real ( dp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_rdp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_rdp end type scaled_linop_rdp type , extends ( abstract_linop_csp ), public :: scaled_linop_csp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a complex(sp)-valued operator !! and  \\sigma \\in \\mathbb{R}\\ ) or  \\mathbb{C} . class ( abstract_linop_csp ), allocatable :: A !! Base linear operator to be scaled. complex ( sp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_csp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_csp end type scaled_linop_csp type , extends ( abstract_linop_cdp ), public :: scaled_linop_cdp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a complex(dp)-valued operator !! and  \\sigma \\in \\mathbb{R}\\ ) or  \\mathbb{C} . class ( abstract_linop_cdp ), allocatable :: A !! Base linear operator to be scaled. complex ( dp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_cdp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_cdp end type scaled_linop_cdp !------------------------------------------------ !-----     Definition of axpby operator     ----- !------------------------------------------------ type , extends ( abstract_linop_rsp ), public :: axpby_linop_rsp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to define `A` and `B`. class ( abstract_linop_rsp ), allocatable :: A , B !! Underlying linear operators. real ( sp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_rsp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_rsp end type axpby_linop_rsp type , extends ( abstract_linop_rdp ), public :: axpby_linop_rdp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to define `A` and `B`. class ( abstract_linop_rdp ), allocatable :: A , B !! Underlying linear operators. real ( dp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_rdp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_rdp end type axpby_linop_rdp type , extends ( abstract_linop_csp ), public :: axpby_linop_csp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to define `A` and `B`. class ( abstract_linop_csp ), allocatable :: A , B !! Underlying linear operators. complex ( sp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_csp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_csp end type axpby_linop_csp type , extends ( abstract_linop_cdp ), public :: axpby_linop_cdp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to define `A` and `B`. class ( abstract_linop_cdp ), allocatable :: A , B !! Underlying linear operators. complex ( dp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_cdp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_cdp end type axpby_linop_cdp !---------------------------------------------------------------- !-----     Definition of an abstract symmetric operator     ----- !---------------------------------------------------------------- type , abstract , extends ( abstract_sym_linop ), public :: abstract_sym_linop_rsp !! Abstract representation of an abstract symmetric (real valued) linear operator. contains private ! User defined procedures procedure ( abstract_sym_matvec_rsp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_sym_matvec_rsp !! Wrapper for matvec including the counter increment end type abstract_sym_linop_rsp abstract interface subroutine abstract_sym_matvec_rsp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use lightkrylov_AbstractVectors import abstract_sym_linop_rsp implicit none ( type , external ) class ( abstract_sym_linop_rsp ) , intent ( inout ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_rsp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_rsp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_sym_matvec_rsp end interface !---------------------------------------------------------------- !-----     Definition of an abstract symmetric operator     ----- !---------------------------------------------------------------- type , abstract , extends ( abstract_sym_linop ), public :: abstract_sym_linop_rdp !! Abstract representation of an abstract symmetric (real valued) linear operator. contains private ! User defined procedures procedure ( abstract_sym_matvec_rdp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_sym_matvec_rdp !! Wrapper for matvec including the counter increment end type abstract_sym_linop_rdp abstract interface subroutine abstract_sym_matvec_rdp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use lightkrylov_AbstractVectors import abstract_sym_linop_rdp implicit none ( type , external ) class ( abstract_sym_linop_rdp ) , intent ( inout ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_rdp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_rdp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_sym_matvec_rdp end interface !---------------------------------------------------------------------------------- !-----     Definition of an abstract Hermitian positive definite operator     ----- !---------------------------------------------------------------------------------- type , abstract , extends ( abstract_sym_linop ), public :: abstract_hermitian_linop_csp !! Abstract representation of an abstract hermitian (complex-valued) linear operator. contains ! User defined procedures procedure ( abstract_herm_matvec_csp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_herm_matvec_csp !! Wrapper for matvec including the counter increment end type abstract_hermitian_linop_csp abstract interface subroutine abstract_herm_matvec_csp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use lightkrylov_AbstractVectors import abstract_hermitian_linop_csp implicit none ( type , external ) class ( abstract_hermitian_linop_csp ) , intent ( inout ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_csp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_csp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_herm_matvec_csp end interface !---------------------------------------------------------------------------------- !-----     Definition of an abstract Hermitian positive definite operator     ----- !---------------------------------------------------------------------------------- type , abstract , extends ( abstract_sym_linop ), public :: abstract_hermitian_linop_cdp !! Abstract representation of an abstract hermitian (complex-valued) linear operator. contains ! User defined procedures procedure ( abstract_herm_matvec_cdp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . ! Wrappers including counter increment procedure , pass ( self ), public :: apply_matvec => apply_herm_matvec_cdp !! Wrapper for matvec including the counter increment end type abstract_hermitian_linop_cdp abstract interface subroutine abstract_herm_matvec_cdp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use lightkrylov_AbstractVectors import abstract_hermitian_linop_cdp implicit none ( type , external ) class ( abstract_hermitian_linop_cdp ) , intent ( inout ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_cdp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_cdp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_herm_matvec_cdp end interface !------------------------------------------------ !-----     Convenience dense linop type     ----- !------------------------------------------------ type , extends ( abstract_linop_rsp ), public :: dense_linop_rsp real ( sp ), allocatable :: data (:, :) contains procedure , pass ( self ), public :: matvec => dense_matvec_rsp procedure , pass ( self ), public :: rmatvec => dense_rmatvec_rsp end type dense_linop_rsp type , extends ( abstract_linop_rdp ), public :: dense_linop_rdp real ( dp ), allocatable :: data (:, :) contains procedure , pass ( self ), public :: matvec => dense_matvec_rdp procedure , pass ( self ), public :: rmatvec => dense_rmatvec_rdp end type dense_linop_rdp type , extends ( abstract_linop_csp ), public :: dense_linop_csp complex ( sp ), allocatable :: data (:, :) contains procedure , pass ( self ), public :: matvec => dense_matvec_csp procedure , pass ( self ), public :: rmatvec => dense_rmatvec_csp end type dense_linop_csp type , extends ( abstract_linop_cdp ), public :: dense_linop_cdp complex ( dp ), allocatable :: data (:, :) contains procedure , pass ( self ), public :: matvec => dense_matvec_cdp procedure , pass ( self ), public :: rmatvec => dense_rmatvec_cdp end type dense_linop_cdp interface dense_linop module procedure initialize_dense_linop_from_array_rsp module procedure initialize_dense_linop_from_array_rdp module procedure initialize_dense_linop_from_array_csp module procedure initialize_dense_linop_from_array_cdp end interface public :: dense_linop contains !-------------------------------------------------------------- !-----     Getter/Setter routines for abstract_linops     ----- !-------------------------------------------------------------- pure integer function get_counter ( self , trans ) result ( count ) !! Getter function for the number of matvec calls implicit none ( type , external ) class ( abstract_linop ), intent ( in ) :: self logical , intent ( in ) :: trans !! matvec or rmatvec? if ( trans ) then count = self % rmatvec_counter else count = self % matvec_counter end if end function get_counter subroutine reset_counter ( self , trans , procedure , counter , reset_timer , soft_reset , clean_timer ) !! Setter routine to reset the matvec counter and reset timers implicit none ( type , external ) class ( abstract_linop ), intent ( inout ) :: self logical , intent ( in ) :: trans !! matvec or rmatvec? character ( len =* ), intent ( in ) :: procedure !! name of the caller routine integer , optional , intent ( in ) :: counter !! optional flag to reset to an integer other than zero. logical , optional , intent ( in ) :: reset_timer !! optional flag to reset also the timers logical , optional , intent ( in ) :: soft_reset !! optional flag to choose whether to save previous timing data (default: .true.) logical , optional , intent ( in ) :: clean_timer !! optional flag to choose whether to fully reset the timer (default: .false.) ! internals integer :: counter_ , count_old logical :: reset_timer_ character ( len = 128 ) :: msg counter_ = optval ( counter , 0 ) count_old = self % get_counter ( trans ) reset_timer_ = optval ( reset_timer , . false .) if ( count_old /= 0 . or . counter_ /= 0 ) then if ( trans ) then write ( msg , '(A,I0,A,I0,A)' ) 'Total number of rmatvecs: ' , count_old , '. Resetting counter to ' , counter_ , '.' call log_message ( msg , this_module , 'reset_counter(' // trim ( procedure ) // ')' ) self % rmatvec_counter = counter_ else write ( msg , '(A,I0,A,I0,A)' ) 'Total number of matvecs: ' , count_old , '. Resetting counter to ' , counter_ , '.' call log_message ( msg , this_module , 'reset_counter(' // trim ( procedure ) // ')' ) self % matvec_counter = counter_ end if end if if ( reset_timer_ ) call self % reset_timer ( trans , soft_reset , clean_timer ) end subroutine reset_counter subroutine print_timer_info ( self , trans ) !! Getter routine to print the current timing information for matvec/rmatvec !! Note: Wrapper of the corresponding routine from lightkrylov_timer implicit none ( type , external ) class ( abstract_linop ), intent ( inout ) :: self logical , optional , intent ( in ) :: trans !! matvec or rmatvec? ! internal logical :: transpose transpose = optval ( trans , . false .) if ( transpose ) then call self % rmatvec_timer % print_info () else call self % matvec_timer % print_info () end if end subroutine print_timer_info subroutine reset_linop_timer ( self , trans , soft , clean ) !! Setter routine to reset the matvec/rmatvec timers !! Note: Wrapper of the corresponding routine from lightkrylov_timer implicit none ( type , external ) class ( abstract_linop ), intent ( inout ) :: self logical , optional , intent ( in ) :: trans !! matvec or rmatvec? logical , optional , intent ( in ) :: soft logical , optional , intent ( in ) :: clean ! internal logical :: transpose transpose = optval ( trans , . false .) if ( present ( trans )) then if ( transpose ) then call self % rmatvec_timer % reset ( soft , clean , verbose = . true .) else call self % matvec_timer % reset ( soft , clean , verbose = . true .) end if else call self % rmatvec_timer % reset ( soft , clean , verbose = . true .) call self % matvec_timer % reset ( soft , clean , verbose = . true .) end if end subroutine reset_linop_timer subroutine finalize_linop_timer ( self ) !! Finalize the matvec/rmatvec timers !! Note: Wrapper of the corresponding routine from lightkrylov_timer implicit none ( type , external ) class ( abstract_linop ), intent ( inout ) :: self call self % matvec_timer % finalize () call self % rmatvec_timer % finalize () end subroutine finalize_linop_timer !--------------------------------------------------------------------- !-----     Wrappers for matvec/rmatvec to increment counters     ----- !--------------------------------------------------------------------- subroutine apply_matvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % matvec_counter = self % matvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'start' call log_debug ( msg , this_module , 'matvec' ) call self % matvec_timer % start () call self % matvec ( vec_in , vec_out ) call self % matvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'end' call log_debug ( msg , this_module , 'matvec' ) return end subroutine apply_matvec_rsp subroutine apply_rmatvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % rmatvec_counter = self % rmatvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % rmatvec_counter , 'start' call log_debug ( msg , this_module , 'rmatvec' ) call self % rmatvec_timer % start () call self % rmatvec ( vec_in , vec_out ) call self % rmatvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % rmatvec_counter , 'end' call log_debug ( msg , this_module , 'rmatvec' ) end subroutine apply_rmatvec_rsp subroutine apply_sym_matvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_sym_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % matvec_counter = self % matvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'start' call log_debug ( msg , this_module , 'matvec' ) call self % matvec_timer % start () call self % matvec ( vec_in , vec_out ) call self % matvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'end' call log_debug ( msg , this_module , 'matvec' ) return end subroutine apply_sym_matvec_rsp subroutine apply_matvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % matvec_counter = self % matvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'start' call log_debug ( msg , this_module , 'matvec' ) call self % matvec_timer % start () call self % matvec ( vec_in , vec_out ) call self % matvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'end' call log_debug ( msg , this_module , 'matvec' ) return end subroutine apply_matvec_rdp subroutine apply_rmatvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % rmatvec_counter = self % rmatvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % rmatvec_counter , 'start' call log_debug ( msg , this_module , 'rmatvec' ) call self % rmatvec_timer % start () call self % rmatvec ( vec_in , vec_out ) call self % rmatvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % rmatvec_counter , 'end' call log_debug ( msg , this_module , 'rmatvec' ) end subroutine apply_rmatvec_rdp subroutine apply_sym_matvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_sym_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % matvec_counter = self % matvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'start' call log_debug ( msg , this_module , 'matvec' ) call self % matvec_timer % start () call self % matvec ( vec_in , vec_out ) call self % matvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'end' call log_debug ( msg , this_module , 'matvec' ) return end subroutine apply_sym_matvec_rdp subroutine apply_matvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % matvec_counter = self % matvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'start' call log_debug ( msg , this_module , 'matvec' ) call self % matvec_timer % start () call self % matvec ( vec_in , vec_out ) call self % matvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'end' call log_debug ( msg , this_module , 'matvec' ) return end subroutine apply_matvec_csp subroutine apply_rmatvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % rmatvec_counter = self % rmatvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % rmatvec_counter , 'start' call log_debug ( msg , this_module , 'rmatvec' ) call self % rmatvec_timer % start () call self % rmatvec ( vec_in , vec_out ) call self % rmatvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % rmatvec_counter , 'end' call log_debug ( msg , this_module , 'rmatvec' ) end subroutine apply_rmatvec_csp subroutine apply_herm_matvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_hermitian_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % matvec_counter = self % matvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'start' call log_debug ( msg , this_module , 'matvec' ) call self % matvec_timer % start () call self % matvec ( vec_in , vec_out ) call self % matvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'end' call log_debug ( msg , this_module , 'matvec' ) return end subroutine apply_herm_matvec_csp subroutine apply_matvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % matvec_counter = self % matvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'start' call log_debug ( msg , this_module , 'matvec' ) call self % matvec_timer % start () call self % matvec ( vec_in , vec_out ) call self % matvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'end' call log_debug ( msg , this_module , 'matvec' ) return end subroutine apply_matvec_cdp subroutine apply_rmatvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % rmatvec_counter = self % rmatvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % rmatvec_counter , 'start' call log_debug ( msg , this_module , 'rmatvec' ) call self % rmatvec_timer % start () call self % rmatvec ( vec_in , vec_out ) call self % rmatvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % rmatvec_counter , 'end' call log_debug ( msg , this_module , 'rmatvec' ) end subroutine apply_rmatvec_cdp subroutine apply_herm_matvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( abstract_hermitian_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out ! internal character ( len = 128 ) :: msg self % matvec_counter = self % matvec_counter + 1 write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'start' call log_debug ( msg , this_module , 'matvec' ) call self % matvec_timer % start () call self % matvec ( vec_in , vec_out ) call self % matvec_timer % stop () write ( msg , '(I0,1X,A)' ) self % matvec_counter , 'end' call log_debug ( msg , this_module , 'matvec' ) return end subroutine apply_herm_matvec_cdp !------------------------------------------------------------------------------ !-----     Concrete matvec/rmatvec implementations for special linops     ----- !------------------------------------------------------------------------------ subroutine id_matvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( Id_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out call copy ( vec_out , vec_in ) end subroutine id_matvec_rsp subroutine id_matvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( Id_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out call copy ( vec_out , vec_in ) end subroutine id_matvec_rdp subroutine id_matvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( Id_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out call copy ( vec_out , vec_in ) end subroutine id_matvec_csp subroutine id_matvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( Id_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out call copy ( vec_out , vec_in ) end subroutine id_matvec_cdp subroutine scaled_matvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( scaled_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out call self % A % apply_matvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) end subroutine scaled_matvec_rsp subroutine scaled_rmatvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( scaled_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out call self % A % apply_rmatvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) end subroutine scaled_rmatvec_rsp subroutine scaled_matvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( scaled_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out call self % A % apply_matvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) end subroutine scaled_matvec_rdp subroutine scaled_rmatvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( scaled_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out call self % A % apply_rmatvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) end subroutine scaled_rmatvec_rdp subroutine scaled_matvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( scaled_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out call self % A % apply_matvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) end subroutine scaled_matvec_csp subroutine scaled_rmatvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( scaled_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out call self % A % apply_rmatvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) end subroutine scaled_rmatvec_csp subroutine scaled_matvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( scaled_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out call self % A % apply_matvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) end subroutine scaled_matvec_cdp subroutine scaled_rmatvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( scaled_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out call self % A % apply_rmatvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) end subroutine scaled_rmatvec_cdp subroutine axpby_matvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( axpby_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_rsp ), allocatable :: wrk integer :: iostat character ( len = 100 ) :: errmsg ! Allocate working array. allocate ( wrk , mold = vec_in , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"axpby_matvec_rsp\" ) call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % apply_rmatvec ( vec_in , wrk ) else call self % A % apply_matvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % apply_rmatvec ( vec_in , vec_out ) else call self % B % apply_matvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % alpha , wrk , self % beta ) end subroutine axpby_matvec_rsp subroutine axpby_rmatvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( axpby_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_rsp ), allocatable :: wrk integer :: iostat character ( len = 100 ) :: errmsg ! Allocate working array. allocate ( wrk , mold = vec_in , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"axpby_rmatvec_rsp\" ) call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % apply_matvec ( vec_in , wrk ) else call self % A % apply_rmatvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % apply_matvec ( vec_in , vec_out ) else call self % B % apply_rmatvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % alpha , wrk , self % beta ) end subroutine axpby_rmatvec_rsp subroutine axpby_matvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( axpby_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_rdp ), allocatable :: wrk integer :: iostat character ( len = 100 ) :: errmsg ! Allocate working array. allocate ( wrk , mold = vec_in , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"axpby_matvec_rdp\" ) call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % apply_rmatvec ( vec_in , wrk ) else call self % A % apply_matvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % apply_rmatvec ( vec_in , vec_out ) else call self % B % apply_matvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % alpha , wrk , self % beta ) end subroutine axpby_matvec_rdp subroutine axpby_rmatvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( axpby_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_rdp ), allocatable :: wrk integer :: iostat character ( len = 100 ) :: errmsg ! Allocate working array. allocate ( wrk , mold = vec_in , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"axpby_rmatvec_rdp\" ) call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % apply_matvec ( vec_in , wrk ) else call self % A % apply_rmatvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % apply_matvec ( vec_in , vec_out ) else call self % B % apply_rmatvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % alpha , wrk , self % beta ) end subroutine axpby_rmatvec_rdp subroutine axpby_matvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( axpby_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_csp ), allocatable :: wrk integer :: iostat character ( len = 100 ) :: errmsg ! Allocate working array. allocate ( wrk , mold = vec_in , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"axpby_matvec_csp\" ) call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % apply_rmatvec ( vec_in , wrk ) else call self % A % apply_matvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % apply_rmatvec ( vec_in , vec_out ) else call self % B % apply_matvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % alpha , wrk , self % beta ) end subroutine axpby_matvec_csp subroutine axpby_rmatvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( axpby_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_csp ), allocatable :: wrk integer :: iostat character ( len = 100 ) :: errmsg ! Allocate working array. allocate ( wrk , mold = vec_in , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"axpby_rmatvec_csp\" ) call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % apply_matvec ( vec_in , wrk ) else call self % A % apply_rmatvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % apply_matvec ( vec_in , vec_out ) else call self % B % apply_rmatvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % alpha , wrk , self % beta ) end subroutine axpby_rmatvec_csp subroutine axpby_matvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( axpby_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_cdp ), allocatable :: wrk integer :: iostat character ( len = 100 ) :: errmsg ! Allocate working array. allocate ( wrk , mold = vec_in , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"axpby_matvec_cdp\" ) call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % apply_rmatvec ( vec_in , wrk ) else call self % A % apply_matvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % apply_rmatvec ( vec_in , vec_out ) else call self % B % apply_matvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % alpha , wrk , self % beta ) end subroutine axpby_matvec_cdp subroutine axpby_rmatvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( axpby_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_cdp ), allocatable :: wrk integer :: iostat character ( len = 100 ) :: errmsg ! Allocate working array. allocate ( wrk , mold = vec_in , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"axpby_rmatvec_cdp\" ) call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % apply_matvec ( vec_in , wrk ) else call self % A % apply_rmatvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % apply_matvec ( vec_in , vec_out ) else call self % B % apply_rmatvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % alpha , wrk , self % beta ) end subroutine axpby_rmatvec_cdp !------------------------------------------------- !-----     ADJOINT TYPE-BOUND PROCEDURES     ----- !------------------------------------------------- function initialize_adjoint_rsp ( A ) result ( B ) implicit none ( type , external ) class ( abstract_linop_rsp ), intent ( in ) :: A class ( adjoint_linop_rsp ), allocatable :: B integer :: iostat character ( len = 100 ) :: errmsg allocate ( B , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"initialize_adjoint_rsp\" ) B % A = A end function initialize_adjoint_rsp subroutine adjoint_matvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( adjoint_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out call self % A % apply_rmatvec ( vec_in , vec_out ) end subroutine adjoint_matvec_rsp subroutine adjoint_rmatvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( adjoint_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out call self % A % apply_matvec ( vec_in , vec_out ) end subroutine adjoint_rmatvec_rsp function initialize_adjoint_rdp ( A ) result ( B ) implicit none ( type , external ) class ( abstract_linop_rdp ), intent ( in ) :: A class ( adjoint_linop_rdp ), allocatable :: B integer :: iostat character ( len = 100 ) :: errmsg allocate ( B , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"initialize_adjoint_rdp\" ) B % A = A end function initialize_adjoint_rdp subroutine adjoint_matvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( adjoint_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out call self % A % apply_rmatvec ( vec_in , vec_out ) end subroutine adjoint_matvec_rdp subroutine adjoint_rmatvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( adjoint_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out call self % A % apply_matvec ( vec_in , vec_out ) end subroutine adjoint_rmatvec_rdp function initialize_adjoint_csp ( A ) result ( B ) implicit none ( type , external ) class ( abstract_linop_csp ), intent ( in ) :: A class ( adjoint_linop_csp ), allocatable :: B integer :: iostat character ( len = 100 ) :: errmsg allocate ( B , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"initialize_adjoint_csp\" ) B % A = A end function initialize_adjoint_csp subroutine adjoint_matvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( adjoint_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out call self % A % apply_rmatvec ( vec_in , vec_out ) end subroutine adjoint_matvec_csp subroutine adjoint_rmatvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( adjoint_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out call self % A % apply_matvec ( vec_in , vec_out ) end subroutine adjoint_rmatvec_csp function initialize_adjoint_cdp ( A ) result ( B ) implicit none ( type , external ) class ( abstract_linop_cdp ), intent ( in ) :: A class ( adjoint_linop_cdp ), allocatable :: B integer :: iostat character ( len = 100 ) :: errmsg allocate ( B , stat = iostat , errmsg = errmsg ) call check_allocation ( iostat , errmsg , this_module , \"initialize_adjoint_cdp\" ) B % A = A end function initialize_adjoint_cdp subroutine adjoint_matvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( adjoint_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out call self % A % apply_rmatvec ( vec_in , vec_out ) end subroutine adjoint_matvec_cdp subroutine adjoint_rmatvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( adjoint_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out call self % A % apply_matvec ( vec_in , vec_out ) end subroutine adjoint_rmatvec_cdp !-------------------------------------------------------------------------- !-----     Type-bound procedures for convenience dense linop type     ----- !-------------------------------------------------------------------------- subroutine dense_matvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( dense_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out select type ( vec_in ) type is ( dense_vector_rsp ) select type ( vec_out ) type is ( dense_vector_rsp ) block integer :: m , n real ( sp ) :: alpha , beta m = size ( self % data , 1 ) ; n = size ( self % data , 2 ) alpha = one_rsp ; beta = zero_rsp vec_out = vec_in call gemv ( \"N\" , m , n , alpha , self % data , m , vec_in % data , 1 , beta , vec_out % data , 1 ) end block class default call type_error ( 'vec_out' , 'dense_vector_rsp' , 'OUT' , this_module , 'dense_matvec_rsp' ) end select class default call type_error ( 'vec_in' , 'dense_vector_rsp' , 'IN' , this_module , 'dense_matvec_rsp' ) end select end subroutine dense_matvec_rsp subroutine dense_rmatvec_rsp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( dense_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out select type ( vec_in ) type is ( dense_vector_rsp ) select type ( vec_out ) type is ( dense_vector_rsp ) block integer :: m , n real ( sp ) :: alpha , beta m = size ( self % data , 1 ) ; n = size ( self % data , 2 ) alpha = one_rsp ; beta = zero_rsp vec_out = vec_in call gemv ( \"T\" , m , n , alpha , self % data , m , vec_in % data , 1 , beta , vec_out % data , 1 ) end block class default call type_error ( 'vec_out' , 'dense_vector_rsp' , 'OUT' , this_module , 'dense_rmatvec_rsp' ) end select class default call type_error ( 'vec_in' , 'dense_vector_rsp' , 'IN' , this_module , 'dense_rmatvec_rsp' ) end select end subroutine dense_rmatvec_rsp subroutine dense_matvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( dense_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out select type ( vec_in ) type is ( dense_vector_rdp ) select type ( vec_out ) type is ( dense_vector_rdp ) block integer :: m , n real ( dp ) :: alpha , beta m = size ( self % data , 1 ) ; n = size ( self % data , 2 ) alpha = one_rdp ; beta = zero_rdp vec_out = vec_in call gemv ( \"N\" , m , n , alpha , self % data , m , vec_in % data , 1 , beta , vec_out % data , 1 ) end block class default call type_error ( 'vec_out' , 'dense_vector_rdp' , 'OUT' , this_module , 'dense_matvec_rdp' ) end select class default call type_error ( 'vec_in' , 'dense_vector_rdp' , 'IN' , this_module , 'dense_matvec_rdp' ) end select end subroutine dense_matvec_rdp subroutine dense_rmatvec_rdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( dense_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out select type ( vec_in ) type is ( dense_vector_rdp ) select type ( vec_out ) type is ( dense_vector_rdp ) block integer :: m , n real ( dp ) :: alpha , beta m = size ( self % data , 1 ) ; n = size ( self % data , 2 ) alpha = one_rdp ; beta = zero_rdp vec_out = vec_in call gemv ( \"T\" , m , n , alpha , self % data , m , vec_in % data , 1 , beta , vec_out % data , 1 ) end block class default call type_error ( 'vec_out' , 'dense_vector_rdp' , 'OUT' , this_module , 'dense_rmatvec_rdp' ) end select class default call type_error ( 'vec_in' , 'dense_vector_rdp' , 'IN' , this_module , 'dense_rmatvec_rdp' ) end select end subroutine dense_rmatvec_rdp subroutine dense_matvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( dense_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out select type ( vec_in ) type is ( dense_vector_csp ) select type ( vec_out ) type is ( dense_vector_csp ) block integer :: m , n complex ( sp ) :: alpha , beta m = size ( self % data , 1 ) ; n = size ( self % data , 2 ) alpha = one_csp ; beta = zero_csp vec_out = vec_in call gemv ( \"N\" , m , n , alpha , self % data , m , vec_in % data , 1 , beta , vec_out % data , 1 ) end block class default call type_error ( 'vec_out' , 'dense_vector_csp' , 'OUT' , this_module , 'dense_matvec_csp' ) end select class default call type_error ( 'vec_in' , 'dense_vector_csp' , 'IN' , this_module , 'dense_matvec_csp' ) end select end subroutine dense_matvec_csp subroutine dense_rmatvec_csp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( dense_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out select type ( vec_in ) type is ( dense_vector_csp ) select type ( vec_out ) type is ( dense_vector_csp ) block integer :: m , n complex ( sp ) :: alpha , beta m = size ( self % data , 1 ) ; n = size ( self % data , 2 ) alpha = one_csp ; beta = zero_csp vec_out = vec_in call gemv ( \"C\" , m , n , alpha , self % data , m , vec_in % data , 1 , beta , vec_out % data , 1 ) end block class default call type_error ( 'vec_out' , 'dense_vector_csp' , 'OUT' , this_module , 'dense_rmatvec_csp' ) end select class default call type_error ( 'vec_in' , 'dense_vector_csp' , 'IN' , this_module , 'dense_rmatvec_csp' ) end select end subroutine dense_rmatvec_csp subroutine dense_matvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( dense_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out select type ( vec_in ) type is ( dense_vector_cdp ) select type ( vec_out ) type is ( dense_vector_cdp ) block integer :: m , n complex ( dp ) :: alpha , beta m = size ( self % data , 1 ) ; n = size ( self % data , 2 ) alpha = one_cdp ; beta = zero_cdp vec_out = vec_in call gemv ( \"N\" , m , n , alpha , self % data , m , vec_in % data , 1 , beta , vec_out % data , 1 ) end block class default call type_error ( 'vec_out' , 'dense_vector_cdp' , 'OUT' , this_module , 'dense_matvec_cdp' ) end select class default call type_error ( 'vec_in' , 'dense_vector_cdp' , 'IN' , this_module , 'dense_matvec_cdp' ) end select end subroutine dense_matvec_cdp subroutine dense_rmatvec_cdp ( self , vec_in , vec_out ) implicit none ( type , external ) class ( dense_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out select type ( vec_in ) type is ( dense_vector_cdp ) select type ( vec_out ) type is ( dense_vector_cdp ) block integer :: m , n complex ( dp ) :: alpha , beta m = size ( self % data , 1 ) ; n = size ( self % data , 2 ) alpha = one_cdp ; beta = zero_cdp vec_out = vec_in call gemv ( \"C\" , m , n , alpha , self % data , m , vec_in % data , 1 , beta , vec_out % data , 1 ) end block class default call type_error ( 'vec_out' , 'dense_vector_cdp' , 'OUT' , this_module , 'dense_rmatvec_cdp' ) end select class default call type_error ( 'vec_in' , 'dense_vector_cdp' , 'IN' , this_module , 'dense_rmatvec_cdp' ) end select end subroutine dense_rmatvec_cdp function initialize_dense_linop_from_array_rsp ( A ) result ( linop ) implicit none ( type , external ) real ( sp ), intent ( in ) :: A (:, :) type ( dense_linop_rsp ) :: linop linop % data = A end function initialize_dense_linop_from_array_rsp function initialize_dense_linop_from_array_rdp ( A ) result ( linop ) implicit none ( type , external ) real ( dp ), intent ( in ) :: A (:, :) type ( dense_linop_rdp ) :: linop linop % data = A end function initialize_dense_linop_from_array_rdp function initialize_dense_linop_from_array_csp ( A ) result ( linop ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: A (:, :) type ( dense_linop_csp ) :: linop linop % data = A end function initialize_dense_linop_from_array_csp function initialize_dense_linop_from_array_cdp ( A ) result ( linop ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: A (:, :) type ( dense_linop_cdp ) :: linop linop % data = A end function initialize_dense_linop_from_array_cdp end module LightKrylov_AbstractLinops","tags":"","url":"sourcefile/abstractlinops.f90.html"},{"title":"Utils.f90 – LightKrylov","text":"Source Code module LightKrylov_Utils !!  This module provides a set of utility functions used throughout `LightKrylov`. !!  It includes: !! !!  - `assert_shape`: Assert that the shape of the argument is the expected shape. !!  - `eig`: Compute the eigenvalue decomposition of a general matrix. !!  - `sqrtm`: Compute the non-negative square root of a symmetric positive definite matrix using its SVD. !!  - `ordschur`: Re-order the Schur factorization to have the selected eigenvalues in the upper left block. !! !!  Note that as the development of `stdlib` progresses, some of these functions !!  will be deprecated in favor of the `stdlib` implementations. !-------------------------------------------- !-----     Standard Fortran Library     ----- !-------------------------------------------- use iso_fortran_env , only : output_unit !------------------------------- !-----     LightKrylov     ----- !------------------------------- use LightKrylov_Constants use LightKrylov_Logger , only : log_warning , log_error , log_message , log_information , & stop_error , check_info implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_Utils' character ( len =* ), parameter :: this_module_long = 'LightKrylov_Utils' !---------------------------------- !-----     Public exports     ----- !---------------------------------- public :: check_allocation public :: assert_shape public :: log2 public :: eig public :: ordschur public :: sqrtm public :: givens_rotation public :: apply_givens_rotation !------------------------------------------------- !-----     Options for iterative solvers     ----- !------------------------------------------------- type , abstract , public :: abstract_opts !! Abstract type for options from which all others are extended. end type abstract_opts type , abstract , public :: abstract_metadata !! Abstract type for solver metadata from which all others are extended. private contains procedure ( abstract_print_metadata ), pass ( self ), deferred , public :: print procedure ( abstract_reset_metadata ), pass ( self ), deferred , public :: reset end type abstract_metadata abstract interface subroutine abstract_print_metadata ( self , reset_counters , verbose ) import abstract_metadata implicit none ( type , external ) class ( abstract_metadata ), intent ( inout ) :: self logical , optional , intent ( in ) :: reset_counters logical , optional , intent ( in ) :: verbose end subroutine abstract_print_metadata subroutine abstract_reset_metadata ( self ) import abstract_metadata implicit none ( type , external ) class ( abstract_metadata ), intent ( inout ) :: self end subroutine abstract_reset_metadata end interface !------------------------------------- !-----     Utility functions     ----- !------------------------------------- ! NOTE : Most of these functions will gradually disappear as more stable !        versions make their ways into the Fortran stdlib library. interface module subroutine check_allocation ( iostat , msg , module , procedure ) integer , intent ( in ) :: iostat character ( len =* ), intent ( in ) :: msg , module , procedure end subroutine check_allocation end interface interface assert_shape !! This interface provides methods to assert tha thte shape of its input vector or !! matrix is as expected. It throws an error if not. module subroutine assert_shape_vector_rsp ( v , size , vecname , module , procedure ) implicit none ( type , external ) real ( sp ), intent ( in ) :: v (:) integer , intent ( in ) :: size (:) character ( len =* ), intent ( in ) :: vecname character ( len =* ), intent ( in ) :: module character ( len =* ), intent ( in ) :: procedure end subroutine assert_shape_vector_rsp module subroutine assert_shape_matrix_rsp ( A , size , matname , module , procedure ) implicit none ( type , external ) real ( sp ), intent ( in ) :: A (:, :) integer , intent ( in ) :: size (:) character ( len =* ), intent ( in ) :: matname character ( len =* ), intent ( in ) :: module character ( len =* ), intent ( in ) :: procedure end subroutine assert_shape_matrix_rsp module subroutine assert_shape_vector_rdp ( v , size , vecname , module , procedure ) implicit none ( type , external ) real ( dp ), intent ( in ) :: v (:) integer , intent ( in ) :: size (:) character ( len =* ), intent ( in ) :: vecname character ( len =* ), intent ( in ) :: module character ( len =* ), intent ( in ) :: procedure end subroutine assert_shape_vector_rdp module subroutine assert_shape_matrix_rdp ( A , size , matname , module , procedure ) implicit none ( type , external ) real ( dp ), intent ( in ) :: A (:, :) integer , intent ( in ) :: size (:) character ( len =* ), intent ( in ) :: matname character ( len =* ), intent ( in ) :: module character ( len =* ), intent ( in ) :: procedure end subroutine assert_shape_matrix_rdp module subroutine assert_shape_vector_csp ( v , size , vecname , module , procedure ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: v (:) integer , intent ( in ) :: size (:) character ( len =* ), intent ( in ) :: vecname character ( len =* ), intent ( in ) :: module character ( len =* ), intent ( in ) :: procedure end subroutine assert_shape_vector_csp module subroutine assert_shape_matrix_csp ( A , size , matname , module , procedure ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: A (:, :) integer , intent ( in ) :: size (:) character ( len =* ), intent ( in ) :: matname character ( len =* ), intent ( in ) :: module character ( len =* ), intent ( in ) :: procedure end subroutine assert_shape_matrix_csp module subroutine assert_shape_vector_cdp ( v , size , vecname , module , procedure ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: v (:) integer , intent ( in ) :: size (:) character ( len =* ), intent ( in ) :: vecname character ( len =* ), intent ( in ) :: module character ( len =* ), intent ( in ) :: procedure end subroutine assert_shape_vector_cdp module subroutine assert_shape_matrix_cdp ( A , size , matname , module , procedure ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: A (:, :) integer , intent ( in ) :: size (:) character ( len =* ), intent ( in ) :: matname character ( len =* ), intent ( in ) :: module character ( len =* ), intent ( in ) :: procedure end subroutine assert_shape_matrix_cdp end interface interface log2 !! Utility function to compute the base-2 logarithm of a real number. elemental real ( sp ) module function log2_rsp ( x ) result ( y ) implicit none ( type , external ) real ( sp ), intent ( in ) :: x end function log2_rsp elemental real ( dp ) module function log2_rdp ( x ) result ( y ) implicit none ( type , external ) real ( dp ), intent ( in ) :: x end function log2_rdp end interface interface eig !!  Computes the eigenvalue decomposition of a general square matrix. !! !!  ### Description !! !!  This interface provides methods to compute the solution to the eigenproblem !!   \\mathbf{Ax} = \\lambda \\mathbf{x} , where $\\mathbf{A}$ is a square `real` !!  or `complex` matrix. !! !!  Result array `lambda` returns the eigenvalues of  \\mathbf{A} , while `vecs` !!  returns the corresponding eigenvectors. Note that it follows the LAPACK convention !!  when  \\mathbf{A}  is `real`. The solver is based on LAPACK's `*GEEV` backends. !! !!  ### Syntax !! !!  `call eig(A, vecs, lambda)` !! !!  ### Arguments !! !!  `A`: `real` or `complex` square array containing the coefficient matrix. It is an !!  `intent(in)` argument. !! !!  `vecs`: Square array of the same size, type, and kind as `A` containing the eigenvectors !!  (following LAPACK's convention for `real` matrices). It is an `intent(out)` argument. !! !!  `lambda`: `complex` rank-1 array of the same kind as `A` containing the eigenvalues. !!  It is an `intent(out)` argument. !! !!  @note !!  Due to the abstrct nature of the vector types defined in `LightKrylov`, it is unlikely !!  that this implementation will be superseeded in favor of the `stdlib` one as the latter !!  does not follow the LAPACK's convention. !!  @endnote module subroutine eig_rsp ( A , vecs , vals ) implicit none ( type , external ) real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( out ) :: vecs (:, :) complex ( sp ), intent ( out ) :: vals (:) end subroutine eig_rsp module subroutine eig_rdp ( A , vecs , vals ) implicit none ( type , external ) real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( out ) :: vecs (:, :) complex ( dp ), intent ( out ) :: vals (:) end subroutine eig_rdp module subroutine eig_csp ( A , vecs , vals ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: A (:, :) complex ( sp ), intent ( out ) :: vecs (:, :) complex ( sp ), intent ( out ) :: vals (:) end subroutine eig_csp module subroutine eig_cdp ( A , vecs , vals ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: A (:, :) complex ( dp ), intent ( out ) :: vecs (:, :) complex ( dp ), intent ( out ) :: vals (:) end subroutine eig_cdp end interface interface ordschur !!  Given the Schur factorization and basis of a matrix, reorders it to have the selected !!  eigenvalues in the upper left block. !! !!  ### Description !! !!  This interface provides methods to re-order the Schur factorization of a `real` or !!  `complex` square matrix. Note that, if  \\mathbf{A}  is `real`, it returns the !!  real Schur form. !! !!  ### Syntax !! !!  `call ordschur(T, Q, selected)` !! !!  ### Arguments !! !!  `T`: `real` or `complex` square array containing the Schur factorization of a matrix. !!  On exit, it is overwritten with its re-ordered counterpart. It is an `intent(inout)` !!  argument. !! !!  `Q`: Two-dimensional square array of the same size, type and kind as `A`. It contains !!  the original Schur basis on entry and the re-ordered one on exit. !!  It is an `intent(inout)` argument. !! !!  `selected`: `logical` rank-1 array selecting which eigenvalues need to be moved in the !!  upper left block of the Schur factorization. It is an `intent(in)` arguement. module subroutine ordschur_rsp ( T , Q , selected ) implicit none ( type , external ) real ( sp ), intent ( inout ) :: T (:, :) real ( sp ), intent ( inout ) :: Q (:, :) logical , intent ( in ) :: selected (:) end subroutine ordschur_rsp module subroutine ordschur_rdp ( T , Q , selected ) implicit none ( type , external ) real ( dp ), intent ( inout ) :: T (:, :) real ( dp ), intent ( inout ) :: Q (:, :) logical , intent ( in ) :: selected (:) end subroutine ordschur_rdp module subroutine ordschur_csp ( T , Q , selected ) implicit none ( type , external ) complex ( sp ), intent ( inout ) :: T (:, :) complex ( sp ), intent ( inout ) :: Q (:, :) logical , intent ( in ) :: selected (:) end subroutine ordschur_csp module subroutine ordschur_cdp ( T , Q , selected ) implicit none ( type , external ) complex ( dp ), intent ( inout ) :: T (:, :) complex ( dp ), intent ( inout ) :: Q (:, :) logical , intent ( in ) :: selected (:) end subroutine ordschur_cdp end interface interface sqrtm !!  Computes the non-negative square root of a symmetric positive definite matrix !!  using its singular value decomposition. !! !!  ### Description !! !!  This interface provides methods to compute the non-negative square root of a symmetric !!  (hermitian) positive definite matrix  \\mathbf{A} . !! !!  ### Syntax !! !!  `call sqrtm(A, sqrtmA, info)` !! !!  ### Arguments !! !!  `A`: Symmetric (hermitian) positive definite matrix whose non-negative square root !!  needs to be computed. It is an `intent(in)` argument. !! !!  `sqrtmA`: Non-negative square root of `A`. It has the same size, kind and type as `A`. !!  It is an `intent(out)` argument. !! !!  `info`: Information flag. It is an `intent(out)` argument. module subroutine sqrtm_rsp ( A , sqrtA , info ) implicit none ( type , external ) real ( sp ), intent ( inout ) :: A (:, :) real ( sp ), intent ( out ) :: sqrtA (:, :) integer , intent ( out ) :: info end subroutine sqrtm_rsp module subroutine sqrtm_rdp ( A , sqrtA , info ) implicit none ( type , external ) real ( dp ), intent ( inout ) :: A (:, :) real ( dp ), intent ( out ) :: sqrtA (:, :) integer , intent ( out ) :: info end subroutine sqrtm_rdp module subroutine sqrtm_csp ( A , sqrtA , info ) implicit none ( type , external ) complex ( sp ), intent ( inout ) :: A (:, :) complex ( sp ), intent ( out ) :: sqrtA (:, :) integer , intent ( out ) :: info end subroutine sqrtm_csp module subroutine sqrtm_cdp ( A , sqrtA , info ) implicit none ( type , external ) complex ( dp ), intent ( inout ) :: A (:, :) complex ( dp ), intent ( out ) :: sqrtA (:, :) integer , intent ( out ) :: info end subroutine sqrtm_cdp end interface interface givens_rotation pure module function givens_rotation_rsp ( x ) result ( g ) implicit none ( type , external ) real ( sp ), intent ( in ) :: x ( 2 ) !! Vector whose second entry needs to be eliminated. real ( sp ) :: g ( 2 ) !! Entries of the Givens rotation matrix. end function givens_rotation_rsp pure module function givens_rotation_rdp ( x ) result ( g ) implicit none ( type , external ) real ( dp ), intent ( in ) :: x ( 2 ) !! Vector whose second entry needs to be eliminated. real ( dp ) :: g ( 2 ) !! Entries of the Givens rotation matrix. end function givens_rotation_rdp pure module function givens_rotation_csp ( x ) result ( g ) implicit none ( type , external ) complex ( sp ), intent ( in ) :: x ( 2 ) !! Vector whose second entry needs to be eliminated. complex ( sp ) :: g ( 2 ) !! Entries of the Givens rotation matrix. end function givens_rotation_csp pure module function givens_rotation_cdp ( x ) result ( g ) implicit none ( type , external ) complex ( dp ), intent ( in ) :: x ( 2 ) !! Vector whose second entry needs to be eliminated. complex ( dp ) :: g ( 2 ) !! Entries of the Givens rotation matrix. end function givens_rotation_cdp end interface interface apply_givens_rotation pure module subroutine apply_givens_rotation_rsp ( h , c , s ) implicit none ( type , external ) real ( sp ), target , contiguous , intent ( inout ) :: h (:) !! k-th column of the Hessenberg matrix. real ( sp ), intent ( inout ) :: c (:) !! Cosine components of the Givens rotations. real ( sp ), intent ( inout ) :: s (:) !! Sine components of the Givens rotations. end subroutine apply_givens_rotation_rsp pure module subroutine apply_givens_rotation_rdp ( h , c , s ) implicit none ( type , external ) real ( dp ), target , contiguous , intent ( inout ) :: h (:) !! k-th column of the Hessenberg matrix. real ( dp ), intent ( inout ) :: c (:) !! Cosine components of the Givens rotations. real ( dp ), intent ( inout ) :: s (:) !! Sine components of the Givens rotations. end subroutine apply_givens_rotation_rdp pure module subroutine apply_givens_rotation_csp ( h , c , s ) implicit none ( type , external ) complex ( sp ), target , contiguous , intent ( inout ) :: h (:) !! k-th column of the Hessenberg matrix. complex ( sp ), intent ( inout ) :: c (:) !! Cosine components of the Givens rotations. complex ( sp ), intent ( inout ) :: s (:) !! Sine components of the Givens rotations. end subroutine apply_givens_rotation_csp pure module subroutine apply_givens_rotation_cdp ( h , c , s ) implicit none ( type , external ) complex ( dp ), target , contiguous , intent ( inout ) :: h (:) !! k-th column of the Hessenberg matrix. complex ( dp ), intent ( inout ) :: c (:) !! Cosine components of the Givens rotations. complex ( dp ), intent ( inout ) :: s (:) !! Sine components of the Givens rotations. end subroutine apply_givens_rotation_cdp end interface end module LightKrylov_Utils","tags":"","url":"sourcefile/utils.f90.html"},{"title":"golub_kahan.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_basekrylov ) golub_kahan_methods implicit none ( type , external ) contains module procedure lanczos_bidiagonalization_rsp character ( len =* ), parameter :: this_procedure = 'lanczos_bidiagonalization_rsp' integer :: k_start , k_end real ( sp ) :: tolerance real ( sp ) :: alpha , beta integer :: k , kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! Krylov subspace dimension. kdim = size ( U ) - 1 ! Deals with the optional args. k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) ! Lanczos bidiagonalization. lanczos : do k = k_start , k_end ! Transpose matrix-vector product. call A % apply_rmatvec ( U ( k ), V ( k )) ! Full re-orthogonalization of the right Krylov subspace. if ( k > 1 ) then call double_gram_schmidt_step ( V ( k ), V (: k - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure // ', right basis' ) end if ! Normalization step. alpha = V ( k )% norm () ; B ( k , k ) = alpha if ( abs ( alpha ) > tolerance ) then call V ( k )% scal ( one_rsp / alpha ) else info = k exit lanczos endif ! Matrix-vector product. call A % apply_matvec ( V ( k ), U ( k + 1 )) ! Full re-orthogonalization of the left Krylov subspace. call double_gram_schmidt_step ( U ( k + 1 ), U (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure // ', left basis' ) ! Normalization step beta = U ( k + 1 )% norm () ; B ( k + 1 , k ) = beta if ( abs ( beta ) > tolerance ) then call U ( k + 1 )% scal ( one_rsp / beta ) else info = k exit lanczos endif enddo lanczos if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure lanczos_bidiagonalization_rsp module procedure lanczos_bidiagonalization_rdp character ( len =* ), parameter :: this_procedure = 'lanczos_bidiagonalization_rdp' integer :: k_start , k_end real ( dp ) :: tolerance real ( dp ) :: alpha , beta integer :: k , kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! Krylov subspace dimension. kdim = size ( U ) - 1 ! Deals with the optional args. k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) ! Lanczos bidiagonalization. lanczos : do k = k_start , k_end ! Transpose matrix-vector product. call A % apply_rmatvec ( U ( k ), V ( k )) ! Full re-orthogonalization of the right Krylov subspace. if ( k > 1 ) then call double_gram_schmidt_step ( V ( k ), V (: k - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure // ', right basis' ) end if ! Normalization step. alpha = V ( k )% norm () ; B ( k , k ) = alpha if ( abs ( alpha ) > tolerance ) then call V ( k )% scal ( one_rdp / alpha ) else info = k exit lanczos endif ! Matrix-vector product. call A % apply_matvec ( V ( k ), U ( k + 1 )) ! Full re-orthogonalization of the left Krylov subspace. call double_gram_schmidt_step ( U ( k + 1 ), U (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure // ', left basis' ) ! Normalization step beta = U ( k + 1 )% norm () ; B ( k + 1 , k ) = beta if ( abs ( beta ) > tolerance ) then call U ( k + 1 )% scal ( one_rdp / beta ) else info = k exit lanczos endif enddo lanczos if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure lanczos_bidiagonalization_rdp module procedure lanczos_bidiagonalization_csp character ( len =* ), parameter :: this_procedure = 'lanczos_bidiagonalization_csp' integer :: k_start , k_end real ( sp ) :: tolerance complex ( sp ) :: alpha , beta integer :: k , kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! Krylov subspace dimension. kdim = size ( U ) - 1 ! Deals with the optional args. k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) ! Lanczos bidiagonalization. lanczos : do k = k_start , k_end ! Transpose matrix-vector product. call A % apply_rmatvec ( U ( k ), V ( k )) ! Full re-orthogonalization of the right Krylov subspace. if ( k > 1 ) then call double_gram_schmidt_step ( V ( k ), V (: k - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure // ', right basis' ) end if ! Normalization step. alpha = V ( k )% norm () ; B ( k , k ) = alpha if ( abs ( alpha ) > tolerance ) then call V ( k )% scal ( one_csp / alpha ) else info = k exit lanczos endif ! Matrix-vector product. call A % apply_matvec ( V ( k ), U ( k + 1 )) ! Full re-orthogonalization of the left Krylov subspace. call double_gram_schmidt_step ( U ( k + 1 ), U (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure // ', left basis' ) ! Normalization step beta = U ( k + 1 )% norm () ; B ( k + 1 , k ) = beta if ( abs ( beta ) > tolerance ) then call U ( k + 1 )% scal ( one_csp / beta ) else info = k exit lanczos endif enddo lanczos if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure lanczos_bidiagonalization_csp module procedure lanczos_bidiagonalization_cdp character ( len =* ), parameter :: this_procedure = 'lanczos_bidiagonalization_cdp' integer :: k_start , k_end real ( dp ) :: tolerance complex ( dp ) :: alpha , beta integer :: k , kdim if ( time_lightkrylov ()) call timer % start ( this_procedure ) info = 0 ! Krylov subspace dimension. kdim = size ( U ) - 1 ! Deals with the optional args. k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) ! Lanczos bidiagonalization. lanczos : do k = k_start , k_end ! Transpose matrix-vector product. call A % apply_rmatvec ( U ( k ), V ( k )) ! Full re-orthogonalization of the right Krylov subspace. if ( k > 1 ) then call double_gram_schmidt_step ( V ( k ), V (: k - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure // ', right basis' ) end if ! Normalization step. alpha = V ( k )% norm () ; B ( k , k ) = alpha if ( abs ( alpha ) > tolerance ) then call V ( k )% scal ( one_cdp / alpha ) else info = k exit lanczos endif ! Matrix-vector product. call A % apply_matvec ( V ( k ), U ( k + 1 )) ! Full re-orthogonalization of the left Krylov subspace. call double_gram_schmidt_step ( U ( k + 1 ), U (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure // ', left basis' ) ! Normalization step beta = U ( k + 1 )% norm () ; B ( k + 1 , k ) = beta if ( abs ( beta ) > tolerance ) then call U ( k + 1 )% scal ( one_cdp / beta ) else info = k exit lanczos endif enddo lanczos if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure lanczos_bidiagonalization_cdp end submodule golub_kahan_methods","tags":"","url":"sourcefile/golub_kahan.f90.html"},{"title":"gmres.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_iterativesolvers ) gmres_solver use stdlib_strings , only : padr use stdlib_linalg_lapack , only : trtrs implicit none ( type , external ) contains !---------------------------------------- !-----     Options and Metadata     ----- !---------------------------------------- module procedure print_gmres_sp ! internals character ( len =* ), parameter :: this_procedure = 'print_gmres_sp' integer :: i logical :: ifreset , ifverbose character ( len = 128 ) :: msg ifreset = optval ( reset_counters , . false .) ifverbose = optval ( verbose , . false .) write ( msg , '(A30,I6,\"  (\",I6,\"/\",I3,\")\")' ) padr ( 'Iterations   (inner/outer): ' , 30 ), & & self % n_iter , self % n_inner , self % n_outer call log_message ( msg , this_module , this_procedure ) if ( ifverbose ) then write ( msg , '(14X,A15)' ) 'Residual' call log_message ( msg , this_module , this_procedure ) write ( msg , '(A14,E15.8)' ) '   INIT:' , self % res ( 1 ) call log_message ( msg , this_module , this_procedure ) do i = 1 , self % n_iter write ( msg , '(A,I3,A,E20.8)' ) '   Step ' , i , ': ' , self % res ( i ) call log_message ( msg , this_module , this_procedure ) end do else write ( msg , '(A30,I20)' ) padr ( 'Number of records: ' , 30 ), size ( self % res ) call log_message ( msg , this_module , this_procedure ) write ( msg , '(A30,E20.8)' ) padr ( 'Residual: ' , 30 ), self % res ( size ( self % res )) call log_message ( msg , this_module , this_procedure ) end if if ( self % converged ) then call log_message ( 'Status: CONVERGED' , this_module , this_procedure ) else call log_message ( 'Status: NOT CONVERGED' , this_module , this_procedure ) end if if ( ifreset ) call self % reset () end procedure module procedure reset_gmres_sp self % n_iter = 0 self % n_inner = 0 self % n_outer = 0 self % converged = . false . self % info = 0 if ( allocated ( self % res )) deallocate ( self % res ) end procedure module procedure print_gmres_dp ! internals character ( len =* ), parameter :: this_procedure = 'print_gmres_dp' integer :: i logical :: ifreset , ifverbose character ( len = 128 ) :: msg ifreset = optval ( reset_counters , . false .) ifverbose = optval ( verbose , . false .) write ( msg , '(A30,I6,\"  (\",I6,\"/\",I3,\")\")' ) padr ( 'Iterations   (inner/outer): ' , 30 ), & & self % n_iter , self % n_inner , self % n_outer call log_message ( msg , this_module , this_procedure ) if ( ifverbose ) then write ( msg , '(14X,A15)' ) 'Residual' call log_message ( msg , this_module , this_procedure ) write ( msg , '(A14,E15.8)' ) '   INIT:' , self % res ( 1 ) call log_message ( msg , this_module , this_procedure ) do i = 1 , self % n_iter write ( msg , '(A,I3,A,E20.8)' ) '   Step ' , i , ': ' , self % res ( i ) call log_message ( msg , this_module , this_procedure ) end do else write ( msg , '(A30,I20)' ) padr ( 'Number of records: ' , 30 ), size ( self % res ) call log_message ( msg , this_module , this_procedure ) write ( msg , '(A30,E20.8)' ) padr ( 'Residual: ' , 30 ), self % res ( size ( self % res )) call log_message ( msg , this_module , this_procedure ) end if if ( self % converged ) then call log_message ( 'Status: CONVERGED' , this_module , this_procedure ) else call log_message ( 'Status: NOT CONVERGED' , this_module , this_procedure ) end if if ( ifreset ) call self % reset () end procedure module procedure reset_gmres_dp self % n_iter = 0 self % n_inner = 0 self % n_outer = 0 self % converged = . false . self % info = 0 if ( allocated ( self % res )) deallocate ( self % res ) end procedure !---------------------------------------------------- !-----     GMRES SOLVERS FOR ABSTRACT TYPES     ----- !---------------------------------------------------- module procedure gmres_rsp ! Options. integer :: kdim , maxiter real ( sp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_sp_opts ) :: opts type ( gmres_sp_metadata ) :: gmres_meta ! Krylov subspace class ( abstract_vector_rsp ), allocatable :: V (:) ! Hessenberg matrix. real ( sp ), allocatable :: H (:, :) ! Least-squares variables. real ( sp ), target , allocatable :: e (:) real ( sp ), pointer :: y (:, :) real ( sp ) :: beta ! Givens rotations. real ( sp ), allocatable :: c (:), s (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'gmres_rsp' integer :: k , iostat class ( abstract_vector_rsp ), allocatable :: dx , wrk character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then select type ( options ) type is ( gmres_sp_opts ) opts = options class default call type_error ( 'options' , 'gmres_sp_opts' , 'IN' , this_module , this_procedure ) end select else opts = gmres_sp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Initialize working variables. allocate ( wrk , source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call wrk % zero () allocate ( V ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( e ( kdim + 1 ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( c ( kdim ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( s ( kdim ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Initialize metadata and & reset matvec counter gmres_meta = gmres_sp_metadata () ; gmres_meta % converged = . false . call A % reset_counter ( trans , 'gmres%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) do while ((. not . gmres_meta % converged ) . and . ( gmres_meta % n_outer <= maxiter )) !> Initialize data H = 0.0_sp ; call zero_basis ( V ) if ( x % norm () /= 0.0_sp ) then if ( trans ) then call A % apply_rmatvec ( x , V ( 1 )) else call A % apply_matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () e = 0.0_sp ; beta = V ( 1 )% norm () ; e ( 1 ) = beta call V ( 1 )% scal ( one_rsp / beta ) c = 0.0_sp ; s = 0.0_sp if ( gmres_meta % n_outer == 0 ) then allocate ( gmres_meta % res ( 1 ), source = abs ( beta ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) write ( msg , '(2(A,E11.4))' ) 'GMRES(k)   init step     : |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if gmres_iter : do k = 1 , kdim !> Preconditioner. wrk = V ( k ) ; if ( ifprecond ) call preconditioner % apply ( wrk , k , beta , tol ) !----------------------------------------- !-----     Arnoldi factorization     ----- !----------------------------------------- !> Matrix vector product. if ( trans ) then call A % apply_rmatvec ( wrk , V ( k + 1 )) else call A % apply_matvec ( wrk , V ( k + 1 )) endif !> Orthogonalization + Hessenberg update. call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) !> Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) call V ( k + 1 )% scal ( one_rsp / H ( k + 1 , k )) !----------------------------------------- !-----     Least-Squares Problem     ----- !----------------------------------------- !> Apply Givens rotations to the Hessenberg matrix. call apply_givens_rotation ( H (: k + 1 , k ), c (: k ), s (: k )) !> Update the right-hand side vector accordingly. e ( k + 1 ) = - s ( k ) * e ( k ) ; e ( k ) = c ( k ) * e ( k ) !> Least-squares residual. beta = abs ( e ( k + 1 )) ! Save metadata. gmres_meta % n_iter = gmres_meta % n_iter + 1 gmres_meta % n_inner = gmres_meta % n_inner + 1 gmres_meta % res = [ gmres_meta % res , abs ( beta ) ] ! Check convergence. write ( msg , '(A,I3,2(A,E11.4))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) if ( abs ( beta ) < tol ) gmres_meta % converged = . true . if ( gmres_meta % converged ) exit gmres_iter enddo gmres_iter ! Update solution. k = min ( k , kdim ) y ( 1 : k , 1 : 1 ) => e (: k ) ; call trtrs ( \"u\" , \"n\" , \"n\" , k , 1 , H (: k , : k ), k , y , k , info ) call linear_combination ( dx , V (: k ), e (: k )) if ( ifprecond ) call preconditioner % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % apply_rmatvec ( x , v ( 1 )) else call A % apply_matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; if ( abs ( beta ) > 0.0_sp ) call v ( 1 )% scal ( one_rsp / beta ) ! Save metadata. gmres_meta % n_iter = gmres_meta % n_iter + 1 gmres_meta % n_outer = gmres_meta % n_outer + 1 gmres_meta % res = [ gmres_meta % res , abs ( beta ) ] write ( msg , '(A,I3,2(A,E11.4))' ) 'GMRES(k) outer step   ' , gmres_meta % n_outer , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) < tol ) then gmres_meta % converged = . true . exit end if enddo end associate ! Returns the number of iterations if converged if ( gmres_meta % converged ) then info = gmres_meta % n_iter else info = - gmres_meta % n_iter end if gmres_meta % info = info if ( opts % if_print_metadata ) call gmres_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( gmres_sp_metadata ) meta = gmres_meta class default call type_error ( 'meta' , 'gmres_sp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter ( trans , 'gmres%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure gmres_rdp ! Options. integer :: kdim , maxiter real ( dp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_dp_opts ) :: opts type ( gmres_dp_metadata ) :: gmres_meta ! Krylov subspace class ( abstract_vector_rdp ), allocatable :: V (:) ! Hessenberg matrix. real ( dp ), allocatable :: H (:, :) ! Least-squares variables. real ( dp ), target , allocatable :: e (:) real ( dp ), pointer :: y (:, :) real ( dp ) :: beta ! Givens rotations. real ( dp ), allocatable :: c (:), s (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'gmres_rdp' integer :: k , iostat class ( abstract_vector_rdp ), allocatable :: dx , wrk character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then select type ( options ) type is ( gmres_dp_opts ) opts = options class default call type_error ( 'options' , 'gmres_dp_opts' , 'IN' , this_module , this_procedure ) end select else opts = gmres_dp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Initialize working variables. allocate ( wrk , source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call wrk % zero () allocate ( V ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( e ( kdim + 1 ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( c ( kdim ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( s ( kdim ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Initialize metadata and & reset matvec counter gmres_meta = gmres_dp_metadata () ; gmres_meta % converged = . false . call A % reset_counter ( trans , 'gmres%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) do while ((. not . gmres_meta % converged ) . and . ( gmres_meta % n_outer <= maxiter )) !> Initialize data H = 0.0_dp ; call zero_basis ( V ) if ( x % norm () /= 0.0_dp ) then if ( trans ) then call A % apply_rmatvec ( x , V ( 1 )) else call A % apply_matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () e = 0.0_dp ; beta = V ( 1 )% norm () ; e ( 1 ) = beta call V ( 1 )% scal ( one_rdp / beta ) c = 0.0_dp ; s = 0.0_dp if ( gmres_meta % n_outer == 0 ) then allocate ( gmres_meta % res ( 1 ), source = abs ( beta ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) write ( msg , '(2(A,E11.4))' ) 'GMRES(k)   init step     : |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if gmres_iter : do k = 1 , kdim !> Preconditioner. wrk = V ( k ) ; if ( ifprecond ) call preconditioner % apply ( wrk , k , beta , tol ) !----------------------------------------- !-----     Arnoldi factorization     ----- !----------------------------------------- !> Matrix vector product. if ( trans ) then call A % apply_rmatvec ( wrk , V ( k + 1 )) else call A % apply_matvec ( wrk , V ( k + 1 )) endif !> Orthogonalization + Hessenberg update. call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) !> Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) call V ( k + 1 )% scal ( one_rdp / H ( k + 1 , k )) !----------------------------------------- !-----     Least-Squares Problem     ----- !----------------------------------------- !> Apply Givens rotations to the Hessenberg matrix. call apply_givens_rotation ( H (: k + 1 , k ), c (: k ), s (: k )) !> Update the right-hand side vector accordingly. e ( k + 1 ) = - s ( k ) * e ( k ) ; e ( k ) = c ( k ) * e ( k ) !> Least-squares residual. beta = abs ( e ( k + 1 )) ! Save metadata. gmres_meta % n_iter = gmres_meta % n_iter + 1 gmres_meta % n_inner = gmres_meta % n_inner + 1 gmres_meta % res = [ gmres_meta % res , abs ( beta ) ] ! Check convergence. write ( msg , '(A,I3,2(A,E11.4))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) if ( abs ( beta ) < tol ) gmres_meta % converged = . true . if ( gmres_meta % converged ) exit gmres_iter enddo gmres_iter ! Update solution. k = min ( k , kdim ) y ( 1 : k , 1 : 1 ) => e (: k ) ; call trtrs ( \"u\" , \"n\" , \"n\" , k , 1 , H (: k , : k ), k , y , k , info ) call linear_combination ( dx , V (: k ), e (: k )) if ( ifprecond ) call preconditioner % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % apply_rmatvec ( x , v ( 1 )) else call A % apply_matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; if ( abs ( beta ) > 0.0_dp ) call v ( 1 )% scal ( one_rdp / beta ) ! Save metadata. gmres_meta % n_iter = gmres_meta % n_iter + 1 gmres_meta % n_outer = gmres_meta % n_outer + 1 gmres_meta % res = [ gmres_meta % res , abs ( beta ) ] write ( msg , '(A,I3,2(A,E11.4))' ) 'GMRES(k) outer step   ' , gmres_meta % n_outer , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) < tol ) then gmres_meta % converged = . true . exit end if enddo end associate ! Returns the number of iterations if converged if ( gmres_meta % converged ) then info = gmres_meta % n_iter else info = - gmres_meta % n_iter end if gmres_meta % info = info if ( opts % if_print_metadata ) call gmres_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( gmres_dp_metadata ) meta = gmres_meta class default call type_error ( 'meta' , 'gmres_dp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter ( trans , 'gmres%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure gmres_csp ! Options. integer :: kdim , maxiter real ( sp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_sp_opts ) :: opts type ( gmres_sp_metadata ) :: gmres_meta ! Krylov subspace class ( abstract_vector_csp ), allocatable :: V (:) ! Hessenberg matrix. complex ( sp ), allocatable :: H (:, :) ! Least-squares variables. complex ( sp ), target , allocatable :: e (:) complex ( sp ), pointer :: y (:, :) real ( sp ) :: beta ! Givens rotations. complex ( sp ), allocatable :: c (:), s (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'gmres_csp' integer :: k , iostat class ( abstract_vector_csp ), allocatable :: dx , wrk character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then select type ( options ) type is ( gmres_sp_opts ) opts = options class default call type_error ( 'options' , 'gmres_sp_opts' , 'IN' , this_module , this_procedure ) end select else opts = gmres_sp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Initialize working variables. allocate ( wrk , source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call wrk % zero () allocate ( V ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( e ( kdim + 1 ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( c ( kdim ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( s ( kdim ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Initialize metadata and & reset matvec counter gmres_meta = gmres_sp_metadata () ; gmres_meta % converged = . false . call A % reset_counter ( trans , 'gmres%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) do while ((. not . gmres_meta % converged ) . and . ( gmres_meta % n_outer <= maxiter )) !> Initialize data H = 0.0_sp ; call zero_basis ( V ) if ( x % norm () /= 0.0_sp ) then if ( trans ) then call A % apply_rmatvec ( x , V ( 1 )) else call A % apply_matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () e = 0.0_sp ; beta = V ( 1 )% norm () ; e ( 1 ) = beta call V ( 1 )% scal ( one_csp / beta ) c = 0.0_sp ; s = 0.0_sp if ( gmres_meta % n_outer == 0 ) then allocate ( gmres_meta % res ( 1 ), source = abs ( beta ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) write ( msg , '(2(A,E11.4))' ) 'GMRES(k)   init step     : |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if gmres_iter : do k = 1 , kdim !> Preconditioner. wrk = V ( k ) ; if ( ifprecond ) call preconditioner % apply ( wrk , k , beta , tol ) !----------------------------------------- !-----     Arnoldi factorization     ----- !----------------------------------------- !> Matrix vector product. if ( trans ) then call A % apply_rmatvec ( wrk , V ( k + 1 )) else call A % apply_matvec ( wrk , V ( k + 1 )) endif !> Orthogonalization + Hessenberg update. call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) !> Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) call V ( k + 1 )% scal ( one_csp / H ( k + 1 , k )) !----------------------------------------- !-----     Least-Squares Problem     ----- !----------------------------------------- !> Apply Givens rotations to the Hessenberg matrix. call apply_givens_rotation ( H (: k + 1 , k ), c (: k ), s (: k )) !> Update the right-hand side vector accordingly. e ( k + 1 ) = - s ( k ) * e ( k ) ; e ( k ) = c ( k ) * e ( k ) !> Least-squares residual. beta = abs ( e ( k + 1 )) ! Save metadata. gmres_meta % n_iter = gmres_meta % n_iter + 1 gmres_meta % n_inner = gmres_meta % n_inner + 1 gmres_meta % res = [ gmres_meta % res , abs ( beta ) ] ! Check convergence. write ( msg , '(A,I3,2(A,E11.4))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) if ( abs ( beta ) < tol ) gmres_meta % converged = . true . if ( gmres_meta % converged ) exit gmres_iter enddo gmres_iter ! Update solution. k = min ( k , kdim ) y ( 1 : k , 1 : 1 ) => e (: k ) ; call trtrs ( \"u\" , \"n\" , \"n\" , k , 1 , H (: k , : k ), k , y , k , info ) call linear_combination ( dx , V (: k ), e (: k )) if ( ifprecond ) call preconditioner % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % apply_rmatvec ( x , v ( 1 )) else call A % apply_matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; if ( abs ( beta ) > 0.0_sp ) call v ( 1 )% scal ( one_csp / beta ) ! Save metadata. gmres_meta % n_iter = gmres_meta % n_iter + 1 gmres_meta % n_outer = gmres_meta % n_outer + 1 gmres_meta % res = [ gmres_meta % res , abs ( beta ) ] write ( msg , '(A,I3,2(A,E11.4))' ) 'GMRES(k) outer step   ' , gmres_meta % n_outer , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) < tol ) then gmres_meta % converged = . true . exit end if enddo end associate ! Returns the number of iterations if converged if ( gmres_meta % converged ) then info = gmres_meta % n_iter else info = - gmres_meta % n_iter end if gmres_meta % info = info if ( opts % if_print_metadata ) call gmres_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( gmres_sp_metadata ) meta = gmres_meta class default call type_error ( 'meta' , 'gmres_sp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter ( trans , 'gmres%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure gmres_cdp ! Options. integer :: kdim , maxiter real ( dp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_dp_opts ) :: opts type ( gmres_dp_metadata ) :: gmres_meta ! Krylov subspace class ( abstract_vector_cdp ), allocatable :: V (:) ! Hessenberg matrix. complex ( dp ), allocatable :: H (:, :) ! Least-squares variables. complex ( dp ), target , allocatable :: e (:) complex ( dp ), pointer :: y (:, :) real ( dp ) :: beta ! Givens rotations. complex ( dp ), allocatable :: c (:), s (:) ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'gmres_cdp' integer :: k , iostat class ( abstract_vector_cdp ), allocatable :: dx , wrk character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then select type ( options ) type is ( gmres_dp_opts ) opts = options class default call type_error ( 'options' , 'gmres_dp_opts' , 'IN' , this_module , this_procedure ) end select else opts = gmres_dp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Initialize working variables. allocate ( wrk , source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call wrk % zero () allocate ( V ( kdim + 1 ), source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( e ( kdim + 1 ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( c ( kdim ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( s ( kdim ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Initialize metadata and & reset matvec counter gmres_meta = gmres_dp_metadata () ; gmres_meta % converged = . false . call A % reset_counter ( trans , 'gmres%init' ) info = 0 associate ( ifprecond => present ( preconditioner )) do while ((. not . gmres_meta % converged ) . and . ( gmres_meta % n_outer <= maxiter )) !> Initialize data H = 0.0_dp ; call zero_basis ( V ) if ( x % norm () /= 0.0_dp ) then if ( trans ) then call A % apply_rmatvec ( x , V ( 1 )) else call A % apply_matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () e = 0.0_dp ; beta = V ( 1 )% norm () ; e ( 1 ) = beta call V ( 1 )% scal ( one_cdp / beta ) c = 0.0_dp ; s = 0.0_dp if ( gmres_meta % n_outer == 0 ) then allocate ( gmres_meta % res ( 1 ), source = abs ( beta ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) write ( msg , '(2(A,E11.4))' ) 'GMRES(k)   init step     : |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) end if gmres_iter : do k = 1 , kdim !> Preconditioner. wrk = V ( k ) ; if ( ifprecond ) call preconditioner % apply ( wrk , k , beta , tol ) !----------------------------------------- !-----     Arnoldi factorization     ----- !----------------------------------------- !> Matrix vector product. if ( trans ) then call A % apply_rmatvec ( wrk , V ( k + 1 )) else call A % apply_matvec ( wrk , V ( k + 1 )) endif !> Orthogonalization + Hessenberg update. call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , this_module , this_procedure ) !> Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) call V ( k + 1 )% scal ( one_cdp / H ( k + 1 , k )) !----------------------------------------- !-----     Least-Squares Problem     ----- !----------------------------------------- !> Apply Givens rotations to the Hessenberg matrix. call apply_givens_rotation ( H (: k + 1 , k ), c (: k ), s (: k )) !> Update the right-hand side vector accordingly. e ( k + 1 ) = - s ( k ) * e ( k ) ; e ( k ) = c ( k ) * e ( k ) !> Least-squares residual. beta = abs ( e ( k + 1 )) ! Save metadata. gmres_meta % n_iter = gmres_meta % n_iter + 1 gmres_meta % n_inner = gmres_meta % n_inner + 1 gmres_meta % res = [ gmres_meta % res , abs ( beta ) ] ! Check convergence. write ( msg , '(A,I3,2(A,E11.4))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) if ( abs ( beta ) < tol ) gmres_meta % converged = . true . if ( gmres_meta % converged ) exit gmres_iter enddo gmres_iter ! Update solution. k = min ( k , kdim ) y ( 1 : k , 1 : 1 ) => e (: k ) ; call trtrs ( \"u\" , \"n\" , \"n\" , k , 1 , H (: k , : k ), k , y , k , info ) call linear_combination ( dx , V (: k ), e (: k )) if ( ifprecond ) call preconditioner % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % apply_rmatvec ( x , v ( 1 )) else call A % apply_matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; if ( abs ( beta ) > 0.0_dp ) call v ( 1 )% scal ( one_cdp / beta ) ! Save metadata. gmres_meta % n_iter = gmres_meta % n_iter + 1 gmres_meta % n_outer = gmres_meta % n_outer + 1 gmres_meta % res = [ gmres_meta % res , abs ( beta ) ] write ( msg , '(A,I3,2(A,E11.4))' ) 'GMRES(k) outer step   ' , gmres_meta % n_outer , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) < tol ) then gmres_meta % converged = . true . exit end if enddo end associate ! Returns the number of iterations if converged if ( gmres_meta % converged ) then info = gmres_meta % n_iter else info = - gmres_meta % n_iter end if gmres_meta % info = info if ( opts % if_print_metadata ) call gmres_meta % print () ! Set metadata output if ( present ( meta )) then select type ( meta ) type is ( gmres_dp_metadata ) meta = gmres_meta class default call type_error ( 'meta' , 'gmres_dp_metadata' , 'OUT' , this_module , this_procedure ) end select end if call A % reset_counter ( trans , 'gmres%post' ) if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure dense_gmres_rsp type ( dense_vector_rsp ) :: b_ , x_ type ( dense_linop_rsp ) :: A_ ! Wrap data into convenience types. A_ = dense_linop ( A ) b_ = dense_vector ( b ) x_ = dense_vector ( x ) ! Call abstract gmres. call gmres ( A_ , b_ , x_ , info , rtol , atol , preconditioner , options , transpose , meta ) ! Extract solution. x = x_ % data end procedure module procedure dense_gmres_rdp type ( dense_vector_rdp ) :: b_ , x_ type ( dense_linop_rdp ) :: A_ ! Wrap data into convenience types. A_ = dense_linop ( A ) b_ = dense_vector ( b ) x_ = dense_vector ( x ) ! Call abstract gmres. call gmres ( A_ , b_ , x_ , info , rtol , atol , preconditioner , options , transpose , meta ) ! Extract solution. x = x_ % data end procedure module procedure dense_gmres_csp type ( dense_vector_csp ) :: b_ , x_ type ( dense_linop_csp ) :: A_ ! Wrap data into convenience types. A_ = dense_linop ( A ) b_ = dense_vector ( b ) x_ = dense_vector ( x ) ! Call abstract gmres. call gmres ( A_ , b_ , x_ , info , rtol , atol , preconditioner , options , transpose , meta ) ! Extract solution. x = x_ % data end procedure module procedure dense_gmres_cdp type ( dense_vector_cdp ) :: b_ , x_ type ( dense_linop_cdp ) :: A_ ! Wrap data into convenience types. A_ = dense_linop ( A ) b_ = dense_vector ( b ) x_ = dense_vector ( x ) ! Call abstract gmres. call gmres ( A_ , b_ , x_ , info , rtol , atol , preconditioner , options , transpose , meta ) ! Extract solution. x = x_ % data end procedure end submodule","tags":"","url":"sourcefile/gmres.f90.html"},{"title":"TestUtils.f90 – LightKrylov","text":"Source Code module LightKrylov_TestUtils ! Fortran Standard Library use stdlib_stats_distribution_normal , only : normal => rvs_normal use stdlib_optval , only : optval use stdlib_linalg , only : eye , hermitian ! LightKrylov use LightKrylov use LightKrylov_Logger use LightKrylov_Constants implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_TUtils' character ( len =* ), parameter :: this_module_long = 'LightKrylov_TestUtils' integer , parameter , public :: test_size = 128 public :: get_data public :: put_data public :: init_rand public :: get_err_str ! Roessler public :: get_state_rsp public :: roessler_analytical_fp_rsp public :: get_state_rdp public :: roessler_analytical_fp_rdp public :: get_state_csp public :: roessler_analytical_fp_csp public :: get_state_cdp public :: roessler_analytical_fp_cdp !----------------------------------------------- !-----     TEST VECTOR TYPE DEFINITION     ----- !----------------------------------------------- type , extends ( abstract_vector_rsp ), public :: vector_rsp real ( sp ), dimension ( test_size ) :: data = 0.0_sp contains private procedure , pass ( self ), public :: zero => init_zero_rsp procedure , pass ( self ), public :: dot => dot_rsp procedure , pass ( self ), public :: scal => scal_rsp procedure , pass ( self ), public :: axpby => axpby_rsp procedure , pass ( self ), public :: rand => rand_rsp procedure , pass ( self ), public :: get_size => get_size_rsp end type vector_rsp type , extends ( abstract_vector_rdp ), public :: vector_rdp real ( dp ), dimension ( test_size ) :: data = 0.0_dp contains private procedure , pass ( self ), public :: zero => init_zero_rdp procedure , pass ( self ), public :: dot => dot_rdp procedure , pass ( self ), public :: scal => scal_rdp procedure , pass ( self ), public :: axpby => axpby_rdp procedure , pass ( self ), public :: rand => rand_rdp procedure , pass ( self ), public :: get_size => get_size_rdp end type vector_rdp type , extends ( abstract_vector_csp ), public :: vector_csp complex ( sp ), dimension ( test_size ) :: data = 0.0_sp contains private procedure , pass ( self ), public :: zero => init_zero_csp procedure , pass ( self ), public :: dot => dot_csp procedure , pass ( self ), public :: scal => scal_csp procedure , pass ( self ), public :: axpby => axpby_csp procedure , pass ( self ), public :: rand => rand_csp procedure , pass ( self ), public :: get_size => get_size_csp end type vector_csp type , extends ( abstract_vector_cdp ), public :: vector_cdp complex ( dp ), dimension ( test_size ) :: data = 0.0_dp contains private procedure , pass ( self ), public :: zero => init_zero_cdp procedure , pass ( self ), public :: dot => dot_cdp procedure , pass ( self ), public :: scal => scal_cdp procedure , pass ( self ), public :: axpby => axpby_cdp procedure , pass ( self ), public :: rand => rand_cdp procedure , pass ( self ), public :: get_size => get_size_cdp end type vector_cdp !---------------------------------------------- !-----     TEST LINOP TYPE DEFINITION     ----- !---------------------------------------------- type , extends ( abstract_linop_rsp ), public :: linop_rsp real ( sp ), dimension ( test_size , test_size ) :: data = 0.0_sp contains private procedure , pass ( self ), public :: matvec => matvec_rsp procedure , pass ( self ), public :: rmatvec => rmatvec_rsp end type linop_rsp interface linop_rsp module function construct_linop_rsp ( data ) result ( A ) implicit none ( type , external ) real ( sp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( linop_rsp ) :: A end function construct_linop_rsp end interface type , extends ( abstract_sym_linop_rsp ), public :: spd_linop_rsp real ( sp ), dimension ( test_size , test_size ) :: data = 0.0_sp contains private procedure , pass ( self ), public :: matvec => sdp_matvec_rsp procedure , pass ( self ), public :: rmatvec => sdp_matvec_rsp end type spd_linop_rsp interface spd_linop_rsp module function construct_spd_linop_rsp ( data ) result ( A ) implicit none ( type , external ) real ( sp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( spd_linop_rsp ) :: A end function construct_spd_linop_rsp end interface type , extends ( abstract_linop_rdp ), public :: linop_rdp real ( dp ), dimension ( test_size , test_size ) :: data = 0.0_dp contains private procedure , pass ( self ), public :: matvec => matvec_rdp procedure , pass ( self ), public :: rmatvec => rmatvec_rdp end type linop_rdp interface linop_rdp module function construct_linop_rdp ( data ) result ( A ) implicit none ( type , external ) real ( dp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( linop_rdp ) :: A end function construct_linop_rdp end interface type , extends ( abstract_sym_linop_rdp ), public :: spd_linop_rdp real ( dp ), dimension ( test_size , test_size ) :: data = 0.0_dp contains private procedure , pass ( self ), public :: matvec => sdp_matvec_rdp procedure , pass ( self ), public :: rmatvec => sdp_matvec_rdp end type spd_linop_rdp interface spd_linop_rdp module function construct_spd_linop_rdp ( data ) result ( A ) implicit none ( type , external ) real ( dp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( spd_linop_rdp ) :: A end function construct_spd_linop_rdp end interface type , extends ( abstract_linop_csp ), public :: linop_csp complex ( sp ), dimension ( test_size , test_size ) :: data = zero_csp contains private procedure , pass ( self ), public :: matvec => matvec_csp procedure , pass ( self ), public :: rmatvec => rmatvec_csp end type linop_csp interface linop_csp module function construct_linop_csp ( data ) result ( A ) implicit none ( type , external ) complex ( sp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( linop_csp ) :: A end function construct_linop_csp end interface type , extends ( abstract_hermitian_linop_csp ), public :: hermitian_linop_csp complex ( sp ), dimension ( test_size , test_size ) :: data = zero_csp contains private procedure , pass ( self ), public :: matvec => hermitian_matvec_csp procedure , pass ( self ), public :: rmatvec => hermitian_matvec_csp end type hermitian_linop_csp interface hermitian_linop_csp module function construct_hermitian_linop_csp ( data ) result ( A ) implicit none ( type , external ) complex ( sp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( hermitian_linop_csp ) :: A end function construct_hermitian_linop_csp end interface type , extends ( abstract_linop_cdp ), public :: linop_cdp complex ( dp ), dimension ( test_size , test_size ) :: data = zero_cdp contains private procedure , pass ( self ), public :: matvec => matvec_cdp procedure , pass ( self ), public :: rmatvec => rmatvec_cdp end type linop_cdp interface linop_cdp module function construct_linop_cdp ( data ) result ( A ) implicit none ( type , external ) complex ( dp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( linop_cdp ) :: A end function construct_linop_cdp end interface type , extends ( abstract_hermitian_linop_cdp ), public :: hermitian_linop_cdp complex ( dp ), dimension ( test_size , test_size ) :: data = zero_cdp contains private procedure , pass ( self ), public :: matvec => hermitian_matvec_cdp procedure , pass ( self ), public :: rmatvec => hermitian_matvec_cdp end type hermitian_linop_cdp interface hermitian_linop_cdp module function construct_hermitian_linop_cdp ( data ) result ( A ) implicit none ( type , external ) complex ( dp ), dimension ( test_size , test_size ), intent ( in ) :: data type ( hermitian_linop_cdp ) :: A end function construct_hermitian_linop_cdp end interface ! ROESSLER SYSTEM real ( sp ), parameter :: a_sp = 0.2_sp real ( sp ), parameter :: b_sp = 0.2_sp real ( sp ), parameter :: c_sp = 5.7_sp type , extends ( abstract_vector_rsp ), public :: state_vector_rsp real ( sp ) :: x = 0.0_sp real ( sp ) :: y = 0.0_sp real ( sp ) :: z = 0.0_sp contains private procedure , pass ( self ), public :: zero => zero_state_rsp procedure , pass ( self ), public :: dot => dot_state_rsp procedure , pass ( self ), public :: scal => scal_state_rsp procedure , pass ( self ), public :: axpby => axpby_state_rsp procedure , pass ( self ), public :: rand => rand_state_rsp procedure , pass ( self ), public :: get_size => get_size_state_rsp end type state_vector_rsp type , extends ( abstract_system_rsp ), public :: roessler_rsp contains private procedure , pass ( self ), public :: response => eval_roessler_rsp end type roessler_rsp type , extends ( abstract_jacobian_linop_rsp ), public :: jacobian_rsp contains private procedure , pass ( self ), public :: matvec => lin_roessler_rsp procedure , pass ( self ), public :: rmatvec => adj_lin_roessler_rsp end type jacobian_rsp real ( dp ), parameter :: a_dp = 0.2_dp real ( dp ), parameter :: b_dp = 0.2_dp real ( dp ), parameter :: c_dp = 5.7_dp type , extends ( abstract_vector_rdp ), public :: state_vector_rdp real ( dp ) :: x = 0.0_dp real ( dp ) :: y = 0.0_dp real ( dp ) :: z = 0.0_dp contains private procedure , pass ( self ), public :: zero => zero_state_rdp procedure , pass ( self ), public :: dot => dot_state_rdp procedure , pass ( self ), public :: scal => scal_state_rdp procedure , pass ( self ), public :: axpby => axpby_state_rdp procedure , pass ( self ), public :: rand => rand_state_rdp procedure , pass ( self ), public :: get_size => get_size_state_rdp end type state_vector_rdp type , extends ( abstract_system_rdp ), public :: roessler_rdp contains private procedure , pass ( self ), public :: response => eval_roessler_rdp end type roessler_rdp type , extends ( abstract_jacobian_linop_rdp ), public :: jacobian_rdp contains private procedure , pass ( self ), public :: matvec => lin_roessler_rdp procedure , pass ( self ), public :: rmatvec => adj_lin_roessler_rdp end type jacobian_rdp ! COMPLEXIFIED ROESSLER SYSTEM type , extends ( abstract_vector_csp ), public :: state_vector_csp complex ( sp ) :: x = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) complex ( sp ) :: y = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) complex ( sp ) :: z = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) contains private procedure , pass ( self ), public :: zero => zero_state_csp procedure , pass ( self ), public :: dot => dot_state_csp procedure , pass ( self ), public :: scal => scal_state_csp procedure , pass ( self ), public :: axpby => axpby_state_csp procedure , pass ( self ), public :: rand => rand_state_csp procedure , pass ( self ), public :: get_size => get_size_state_csp end type state_vector_csp type , extends ( abstract_system_csp ), public :: roessler_csp contains private procedure , pass ( self ), public :: response => eval_roessler_csp end type roessler_csp type , extends ( abstract_jacobian_linop_csp ), public :: jacobian_csp contains private procedure , pass ( self ), public :: matvec => lin_roessler_csp procedure , pass ( self ), public :: rmatvec => adj_lin_roessler_csp end type jacobian_csp type , extends ( abstract_vector_cdp ), public :: state_vector_cdp complex ( dp ) :: x = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) complex ( dp ) :: y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) complex ( dp ) :: z = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) contains private procedure , pass ( self ), public :: zero => zero_state_cdp procedure , pass ( self ), public :: dot => dot_state_cdp procedure , pass ( self ), public :: scal => scal_state_cdp procedure , pass ( self ), public :: axpby => axpby_state_cdp procedure , pass ( self ), public :: rand => rand_state_cdp procedure , pass ( self ), public :: get_size => get_size_state_cdp end type state_vector_cdp type , extends ( abstract_system_cdp ), public :: roessler_cdp contains private procedure , pass ( self ), public :: response => eval_roessler_cdp end type roessler_cdp type , extends ( abstract_jacobian_linop_cdp ), public :: jacobian_cdp contains private procedure , pass ( self ), public :: matvec => lin_roessler_cdp procedure , pass ( self ), public :: rmatvec => adj_lin_roessler_cdp end type jacobian_cdp interface get_data module procedure get_data_vec_rsp module procedure get_data_vec_basis_rsp module procedure get_data_linop_rsp module procedure get_data_vec_rdp module procedure get_data_vec_basis_rdp module procedure get_data_linop_rdp module procedure get_data_vec_csp module procedure get_data_vec_basis_csp module procedure get_data_linop_csp module procedure get_data_vec_cdp module procedure get_data_vec_basis_cdp module procedure get_data_linop_cdp end interface interface put_data module procedure put_data_vec_rsp module procedure put_data_vec_basis_rsp module procedure put_data_linop_rsp module procedure put_data_vec_rdp module procedure put_data_vec_basis_rdp module procedure put_data_linop_rdp module procedure put_data_vec_csp module procedure put_data_vec_basis_csp module procedure put_data_linop_csp module procedure put_data_vec_cdp module procedure put_data_vec_basis_cdp module procedure put_data_linop_cdp end interface interface init_rand module procedure init_rand_vec_rsp module procedure init_rand_basis_rsp module procedure init_rand_linop_rsp module procedure init_rand_spd_linop_rsp module procedure init_rand_vec_rdp module procedure init_rand_basis_rdp module procedure init_rand_linop_rdp module procedure init_rand_spd_linop_rdp module procedure init_rand_vec_csp module procedure init_rand_basis_csp module procedure init_rand_linop_csp module procedure init_rand_hermitian_linop_csp module procedure init_rand_vec_cdp module procedure init_rand_basis_cdp module procedure init_rand_linop_cdp module procedure init_rand_hermitian_linop_cdp end interface interface get_err_str module procedure get_err_str_sp module procedure get_err_str_dp end interface contains !-------------------------------- !-----     CONSTRUCTORS     ----- !-------------------------------- module procedure construct_linop_rsp A % data = data end procedure construct_linop_rsp module procedure construct_spd_linop_rsp A % data = data end procedure construct_spd_linop_rsp module procedure construct_linop_rdp A % data = data end procedure construct_linop_rdp module procedure construct_spd_linop_rdp A % data = data end procedure construct_spd_linop_rdp module procedure construct_linop_csp A % data = data end procedure construct_linop_csp module procedure construct_hermitian_linop_csp A % data = data end procedure construct_hermitian_linop_csp module procedure construct_linop_cdp A % data = data end procedure construct_linop_cdp module procedure construct_hermitian_linop_cdp A % data = data end procedure construct_hermitian_linop_cdp !---------------------------------------------------------- !-----     TYPE-BOUND PROCEDURES FOR TEST VECTORS     ----- !---------------------------------------------------------- subroutine init_zero_rsp ( self ) class ( vector_rsp ), intent ( inout ) :: self self % data = 0.0_sp end subroutine init_zero_rsp function dot_rsp ( self , vec ) result ( alpha ) class ( vector_rsp ), intent ( in ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec real ( sp ) :: alpha select type ( vec ) type is ( vector_rsp ) alpha = dot_product ( self % data , vec % data ) class default call type_error ( 'vec' , 'vector_rsp' , 'IN' , this_module , 'dot_rsp' ) end select end function dot_rsp integer function get_size_rsp ( self ) result ( N ) class ( vector_rsp ), intent ( in ) :: self N = test_size end function get_size_rsp subroutine scal_rsp ( self , alpha ) class ( vector_rsp ), intent ( inout ) :: self real ( sp ), intent ( in ) :: alpha self % data = alpha * self % data end subroutine scal_rsp subroutine axpby_rsp ( alpha , vec , beta , self ) class ( vector_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec real ( sp ), intent ( in ) :: alpha , beta select type ( vec ) type is ( vector_rsp ) self % data = alpha * vec % data + beta * self % data class default call type_error ( 'vec' , 'vector_rsp' , 'IN' , this_module , 'axpby_rsp' ) end select end subroutine axpby_rsp subroutine rand_rsp ( self , ifnorm ) class ( vector_rsp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm logical :: normalized real ( sp ) :: mu ( test_size ), var ( test_size ) real ( sp ) :: alpha mu = 0.0_sp var = 1.0_sp self % data = normal ( mu , var ) normalized = optval ( ifnorm , . false .) if ( normalized ) then alpha = self % norm () call self % scal ( 1.0_sp / alpha ) endif end subroutine rand_rsp subroutine init_zero_rdp ( self ) class ( vector_rdp ), intent ( inout ) :: self self % data = 0.0_dp end subroutine init_zero_rdp function dot_rdp ( self , vec ) result ( alpha ) class ( vector_rdp ), intent ( in ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec real ( dp ) :: alpha select type ( vec ) type is ( vector_rdp ) alpha = dot_product ( self % data , vec % data ) class default call type_error ( 'vec' , 'vector_rdp' , 'IN' , this_module , 'dot_rdp' ) end select end function dot_rdp integer function get_size_rdp ( self ) result ( N ) class ( vector_rdp ), intent ( in ) :: self N = test_size end function get_size_rdp subroutine scal_rdp ( self , alpha ) class ( vector_rdp ), intent ( inout ) :: self real ( dp ), intent ( in ) :: alpha self % data = alpha * self % data end subroutine scal_rdp subroutine axpby_rdp ( alpha , vec , beta , self ) class ( vector_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec real ( dp ), intent ( in ) :: alpha , beta select type ( vec ) type is ( vector_rdp ) self % data = alpha * vec % data + beta * self % data class default call type_error ( 'vec' , 'vector_rdp' , 'IN' , this_module , 'axpby_rdp' ) end select end subroutine axpby_rdp subroutine rand_rdp ( self , ifnorm ) class ( vector_rdp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm logical :: normalized real ( dp ) :: mu ( test_size ), var ( test_size ) real ( dp ) :: alpha mu = 0.0_dp var = 1.0_dp self % data = normal ( mu , var ) normalized = optval ( ifnorm , . false .) if ( normalized ) then alpha = self % norm () call self % scal ( 1.0_dp / alpha ) endif end subroutine rand_rdp subroutine init_zero_csp ( self ) class ( vector_csp ), intent ( inout ) :: self self % data = 0.0_sp end subroutine init_zero_csp function dot_csp ( self , vec ) result ( alpha ) class ( vector_csp ), intent ( in ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec complex ( sp ) :: alpha select type ( vec ) type is ( vector_csp ) alpha = dot_product ( self % data , vec % data ) class default call type_error ( 'vec' , 'vector_csp' , 'IN' , this_module , 'dot_csp' ) end select end function dot_csp integer function get_size_csp ( self ) result ( N ) class ( vector_csp ), intent ( in ) :: self N = test_size end function get_size_csp subroutine scal_csp ( self , alpha ) class ( vector_csp ), intent ( inout ) :: self complex ( sp ), intent ( in ) :: alpha self % data = alpha * self % data end subroutine scal_csp subroutine axpby_csp ( alpha , vec , beta , self ) class ( vector_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec complex ( sp ), intent ( in ) :: alpha , beta select type ( vec ) type is ( vector_csp ) self % data = alpha * vec % data + beta * self % data class default call type_error ( 'vec' , 'vector_csp' , 'IN' , this_module , 'axpby_csp' ) end select end subroutine axpby_csp subroutine rand_csp ( self , ifnorm ) class ( vector_csp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm logical :: normalized complex ( sp ) :: mu ( test_size ), var ( test_size ) complex ( sp ) :: alpha mu = 0.0_sp var = cmplx ( 1.0_sp , 1.0_sp , kind = sp ) self % data = normal ( mu , var ) normalized = optval ( ifnorm , . false .) if ( normalized ) then alpha = self % norm () call self % scal ( 1.0_sp / alpha ) endif end subroutine rand_csp subroutine init_zero_cdp ( self ) class ( vector_cdp ), intent ( inout ) :: self self % data = 0.0_dp end subroutine init_zero_cdp function dot_cdp ( self , vec ) result ( alpha ) class ( vector_cdp ), intent ( in ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec complex ( dp ) :: alpha select type ( vec ) type is ( vector_cdp ) alpha = dot_product ( self % data , vec % data ) class default call type_error ( 'vec' , 'vector_cdp' , 'IN' , this_module , 'dot_cdp' ) end select end function dot_cdp integer function get_size_cdp ( self ) result ( N ) class ( vector_cdp ), intent ( in ) :: self N = test_size end function get_size_cdp subroutine scal_cdp ( self , alpha ) class ( vector_cdp ), intent ( inout ) :: self complex ( dp ), intent ( in ) :: alpha self % data = alpha * self % data end subroutine scal_cdp subroutine axpby_cdp ( alpha , vec , beta , self ) class ( vector_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec complex ( dp ), intent ( in ) :: alpha , beta select type ( vec ) type is ( vector_cdp ) self % data = alpha * vec % data + beta * self % data class default call type_error ( 'vec' , 'vector_cdp' , 'IN' , this_module , 'axpby_cdp' ) end select end subroutine axpby_cdp subroutine rand_cdp ( self , ifnorm ) class ( vector_cdp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm logical :: normalized complex ( dp ) :: mu ( test_size ), var ( test_size ) complex ( dp ) :: alpha mu = 0.0_dp var = cmplx ( 1.0_dp , 1.0_dp , kind = dp ) self % data = normal ( mu , var ) normalized = optval ( ifnorm , . false .) if ( normalized ) then alpha = self % norm () call self % scal ( 1.0_dp / alpha ) endif end subroutine rand_cdp !--------------------------------------------------------- !-----     TYPE-BOUND PROCEDURES FOR TEST LINOPS     ----- !--------------------------------------------------------- subroutine matvec_rsp ( self , vec_in , vec_out ) class ( linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ) , intent ( in ) :: vec_in class ( abstract_vector_rsp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_rsp ) select type ( vec_out ) type is ( vector_rsp ) vec_out % data = matmul ( self % data , vec_in % data ) class default call type_error ( 'vec_out' , 'vector_rsp' , 'OUT' , this_module , 'matvec_rsp' ) end select class default call type_error ( 'vec_in' , 'vector_rsp' , 'IN' , this_module , 'matvec_rsp' ) end select end subroutine matvec_rsp subroutine rmatvec_rsp ( self , vec_in , vec_out ) class ( linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ) , intent ( in ) :: vec_in class ( abstract_vector_rsp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_rsp ) select type ( vec_out ) type is ( vector_rsp ) vec_out % data = matmul ( hermitian ( self % data ), vec_in % data ) class default call type_error ( 'vec_out' , 'vector_rsp' , 'OUT' , this_module , 'rmatvec_rsp' ) end select class default call type_error ( 'vec_in' , 'vector_rsp' , 'IN' , this_module , 'rmatvec_rsp' ) end select end subroutine rmatvec_rsp subroutine sdp_matvec_rsp ( self , vec_in , vec_out ) class ( spd_linop_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ) , intent ( in ) :: vec_in class ( abstract_vector_rsp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_rsp ) select type ( vec_out ) type is ( vector_rsp ) vec_out % data = matmul ( self % data , vec_in % data ) class default call type_error ( 'vec_out' , 'vector_rsp' , 'OUT' , this_module , 'spd_matvec_rsp' ) end select class default call type_error ( 'vec_in' , 'vector_rsp' , 'IN' , this_module , 'spd_matvec_rsp' ) end select end subroutine sdp_matvec_rsp subroutine matvec_rdp ( self , vec_in , vec_out ) class ( linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ) , intent ( in ) :: vec_in class ( abstract_vector_rdp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_rdp ) select type ( vec_out ) type is ( vector_rdp ) vec_out % data = matmul ( self % data , vec_in % data ) class default call type_error ( 'vec_out' , 'vector_rdp' , 'OUT' , this_module , 'matvec_rdp' ) end select class default call type_error ( 'vec_in' , 'vector_rdp' , 'IN' , this_module , 'matvec_rdp' ) end select end subroutine matvec_rdp subroutine rmatvec_rdp ( self , vec_in , vec_out ) class ( linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ) , intent ( in ) :: vec_in class ( abstract_vector_rdp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_rdp ) select type ( vec_out ) type is ( vector_rdp ) vec_out % data = matmul ( hermitian ( self % data ), vec_in % data ) class default call type_error ( 'vec_out' , 'vector_rdp' , 'OUT' , this_module , 'rmatvec_rdp' ) end select class default call type_error ( 'vec_in' , 'vector_rdp' , 'IN' , this_module , 'rmatvec_rdp' ) end select end subroutine rmatvec_rdp subroutine sdp_matvec_rdp ( self , vec_in , vec_out ) class ( spd_linop_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ) , intent ( in ) :: vec_in class ( abstract_vector_rdp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_rdp ) select type ( vec_out ) type is ( vector_rdp ) vec_out % data = matmul ( self % data , vec_in % data ) class default call type_error ( 'vec_out' , 'vector_rdp' , 'OUT' , this_module , 'spd_matvec_rdp' ) end select class default call type_error ( 'vec_in' , 'vector_rdp' , 'IN' , this_module , 'spd_matvec_rdp' ) end select end subroutine sdp_matvec_rdp subroutine matvec_csp ( self , vec_in , vec_out ) class ( linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ) , intent ( in ) :: vec_in class ( abstract_vector_csp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_csp ) select type ( vec_out ) type is ( vector_csp ) vec_out % data = matmul ( self % data , vec_in % data ) class default call type_error ( 'vec_out' , 'vector_csp' , 'OUT' , this_module , 'matvec_csp' ) end select class default call type_error ( 'vec_in' , 'vector_csp' , 'IN' , this_module , 'matvec_csp' ) end select end subroutine matvec_csp subroutine rmatvec_csp ( self , vec_in , vec_out ) class ( linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ) , intent ( in ) :: vec_in class ( abstract_vector_csp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_csp ) select type ( vec_out ) type is ( vector_csp ) vec_out % data = matmul ( hermitian ( self % data ), vec_in % data ) class default call type_error ( 'vec_out' , 'vector_csp' , 'OUT' , this_module , 'rmatvec_csp' ) end select class default call type_error ( 'vec_in' , 'vector_csp' , 'IN' , this_module , 'rmatvec_csp' ) end select end subroutine rmatvec_csp subroutine hermitian_matvec_csp ( self , vec_in , vec_out ) class ( hermitian_linop_csp ), intent ( inout ) :: self class ( abstract_vector_csp ) , intent ( in ) :: vec_in class ( abstract_vector_csp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_csp ) select type ( vec_out ) type is ( vector_csp ) vec_out % data = matmul ( self % data , vec_in % data ) class default call type_error ( 'vec_out' , 'vector_csp' , 'OUT' , this_module , 'hermitian_matvec_csp' ) end select class default call type_error ( 'vec_in' , 'vector_csp' , 'IN' , this_module , 'hermitian_matvec_csp' ) end select end subroutine hermitian_matvec_csp subroutine matvec_cdp ( self , vec_in , vec_out ) class ( linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ) , intent ( in ) :: vec_in class ( abstract_vector_cdp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_cdp ) select type ( vec_out ) type is ( vector_cdp ) vec_out % data = matmul ( self % data , vec_in % data ) class default call type_error ( 'vec_out' , 'vector_cdp' , 'OUT' , this_module , 'matvec_cdp' ) end select class default call type_error ( 'vec_in' , 'vector_cdp' , 'IN' , this_module , 'matvec_cdp' ) end select end subroutine matvec_cdp subroutine rmatvec_cdp ( self , vec_in , vec_out ) class ( linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ) , intent ( in ) :: vec_in class ( abstract_vector_cdp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_cdp ) select type ( vec_out ) type is ( vector_cdp ) vec_out % data = matmul ( hermitian ( self % data ), vec_in % data ) class default call type_error ( 'vec_out' , 'vector_cdp' , 'OUT' , this_module , 'rmatvec_cdp' ) end select class default call type_error ( 'vec_in' , 'vector_cdp' , 'IN' , this_module , 'rmatvec_cdp' ) end select end subroutine rmatvec_cdp subroutine hermitian_matvec_cdp ( self , vec_in , vec_out ) class ( hermitian_linop_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ) , intent ( in ) :: vec_in class ( abstract_vector_cdp ) , intent ( out ) :: vec_out select type ( vec_in ) type is ( vector_cdp ) select type ( vec_out ) type is ( vector_cdp ) vec_out % data = matmul ( self % data , vec_in % data ) class default call type_error ( 'vec_out' , 'vector_cdp' , 'OUT' , this_module , 'hermitian_matvec_cdp' ) end select class default call type_error ( 'vec_in' , 'vector_cdp' , 'IN' , this_module , 'hermitian_matvec_cdp' ) end select end subroutine hermitian_matvec_cdp !---------------------------------------------------- !-----     EXTRACT DATA FROM ABSTRACT TYPES     ----- !---------------------------------------------------- subroutine get_data_vec_rsp ( vec_out , vec_in ) real ( sp ), intent ( out ) :: vec_out (:) type ( vector_rsp ), intent ( in ) :: vec_in vec_out = vec_in % data end subroutine get_data_vec_rsp subroutine get_data_vec_basis_rsp ( basis_out , basis_in ) real ( sp ), intent ( out ) :: basis_out (:, :) type ( vector_rsp ), intent ( in ) :: basis_in (:) ! Internal variables. integer :: k do k = 1 , size ( basis_in ) basis_out (:, k ) = basis_in ( k )% data enddo end subroutine get_data_vec_basis_rsp subroutine get_data_linop_rsp ( mat_out , linop_in ) real ( sp ), intent ( out ) :: mat_out (:, :) type ( linop_rsp ), intent ( in ) :: linop_in mat_out = linop_in % data end subroutine get_data_linop_rsp subroutine get_data_vec_rdp ( vec_out , vec_in ) real ( dp ), intent ( out ) :: vec_out (:) type ( vector_rdp ), intent ( in ) :: vec_in vec_out = vec_in % data end subroutine get_data_vec_rdp subroutine get_data_vec_basis_rdp ( basis_out , basis_in ) real ( dp ), intent ( out ) :: basis_out (:, :) type ( vector_rdp ), intent ( in ) :: basis_in (:) ! Internal variables. integer :: k do k = 1 , size ( basis_in ) basis_out (:, k ) = basis_in ( k )% data enddo end subroutine get_data_vec_basis_rdp subroutine get_data_linop_rdp ( mat_out , linop_in ) real ( dp ), intent ( out ) :: mat_out (:, :) type ( linop_rdp ), intent ( in ) :: linop_in mat_out = linop_in % data end subroutine get_data_linop_rdp subroutine get_data_vec_csp ( vec_out , vec_in ) complex ( sp ), intent ( out ) :: vec_out (:) type ( vector_csp ), intent ( in ) :: vec_in vec_out = vec_in % data end subroutine get_data_vec_csp subroutine get_data_vec_basis_csp ( basis_out , basis_in ) complex ( sp ), intent ( out ) :: basis_out (:, :) type ( vector_csp ), intent ( in ) :: basis_in (:) ! Internal variables. integer :: k do k = 1 , size ( basis_in ) basis_out (:, k ) = basis_in ( k )% data enddo end subroutine get_data_vec_basis_csp subroutine get_data_linop_csp ( mat_out , linop_in ) complex ( sp ), intent ( out ) :: mat_out (:, :) type ( linop_csp ), intent ( in ) :: linop_in mat_out = linop_in % data end subroutine get_data_linop_csp subroutine get_data_vec_cdp ( vec_out , vec_in ) complex ( dp ), intent ( out ) :: vec_out (:) type ( vector_cdp ), intent ( in ) :: vec_in vec_out = vec_in % data end subroutine get_data_vec_cdp subroutine get_data_vec_basis_cdp ( basis_out , basis_in ) complex ( dp ), intent ( out ) :: basis_out (:, :) type ( vector_cdp ), intent ( in ) :: basis_in (:) ! Internal variables. integer :: k do k = 1 , size ( basis_in ) basis_out (:, k ) = basis_in ( k )% data enddo end subroutine get_data_vec_basis_cdp subroutine get_data_linop_cdp ( mat_out , linop_in ) complex ( dp ), intent ( out ) :: mat_out (:, :) type ( linop_cdp ), intent ( in ) :: linop_in mat_out = linop_in % data end subroutine get_data_linop_cdp !---------------------------------------------- !-----     PUT DATA TO ABSTRACT TYPES     ----- !---------------------------------------------- subroutine put_data_vec_rsp ( vec_out , vec_in ) type ( vector_rsp ), intent ( out ) :: vec_out real ( sp ), intent ( in ) :: vec_in vec_out % data = vec_in end subroutine put_data_vec_rsp subroutine put_data_vec_basis_rsp ( basis_out , basis_in ) type ( vector_rsp ), intent ( out ) :: basis_out (:) real ( sp ), intent ( in ) :: basis_in (:, :) ! Internal variables. integer :: k do k = 1 , size ( basis_out ) basis_out ( k )% data = basis_in (:, k ) enddo end subroutine put_data_vec_basis_rsp subroutine put_data_linop_rsp ( linop_out , mat_in ) type ( linop_rsp ), intent ( out ) :: linop_out real ( sp ), intent ( in ) :: mat_in (:, :) ! Internal variables. linop_out % data = mat_in end subroutine put_data_linop_rsp subroutine put_data_vec_rdp ( vec_out , vec_in ) type ( vector_rdp ), intent ( out ) :: vec_out real ( dp ), intent ( in ) :: vec_in vec_out % data = vec_in end subroutine put_data_vec_rdp subroutine put_data_vec_basis_rdp ( basis_out , basis_in ) type ( vector_rdp ), intent ( out ) :: basis_out (:) real ( dp ), intent ( in ) :: basis_in (:, :) ! Internal variables. integer :: k do k = 1 , size ( basis_out ) basis_out ( k )% data = basis_in (:, k ) enddo end subroutine put_data_vec_basis_rdp subroutine put_data_linop_rdp ( linop_out , mat_in ) type ( linop_rdp ), intent ( out ) :: linop_out real ( dp ), intent ( in ) :: mat_in (:, :) ! Internal variables. linop_out % data = mat_in end subroutine put_data_linop_rdp subroutine put_data_vec_csp ( vec_out , vec_in ) type ( vector_csp ), intent ( out ) :: vec_out complex ( sp ), intent ( in ) :: vec_in vec_out % data = vec_in end subroutine put_data_vec_csp subroutine put_data_vec_basis_csp ( basis_out , basis_in ) type ( vector_csp ), intent ( out ) :: basis_out (:) complex ( sp ), intent ( in ) :: basis_in (:, :) ! Internal variables. integer :: k do k = 1 , size ( basis_out ) basis_out ( k )% data = basis_in (:, k ) enddo end subroutine put_data_vec_basis_csp subroutine put_data_linop_csp ( linop_out , mat_in ) type ( linop_csp ), intent ( out ) :: linop_out complex ( sp ), intent ( in ) :: mat_in (:, :) ! Internal variables. linop_out % data = mat_in end subroutine put_data_linop_csp subroutine put_data_vec_cdp ( vec_out , vec_in ) type ( vector_cdp ), intent ( out ) :: vec_out complex ( dp ), intent ( in ) :: vec_in vec_out % data = vec_in end subroutine put_data_vec_cdp subroutine put_data_vec_basis_cdp ( basis_out , basis_in ) type ( vector_cdp ), intent ( out ) :: basis_out (:) complex ( dp ), intent ( in ) :: basis_in (:, :) ! Internal variables. integer :: k do k = 1 , size ( basis_out ) basis_out ( k )% data = basis_in (:, k ) enddo end subroutine put_data_vec_basis_cdp subroutine put_data_linop_cdp ( linop_out , mat_in ) type ( linop_cdp ), intent ( out ) :: linop_out complex ( dp ), intent ( in ) :: mat_in (:, :) ! Internal variables. linop_out % data = mat_in end subroutine put_data_linop_cdp !-------------------------------------------------------------- !-----     INITIALIZE ABSTRACT TYPES WITH RANDOM DATA     ----- !-------------------------------------------------------------- subroutine init_rand_vec_rsp ( x ) type ( vector_rsp ), intent ( inout ) :: x call x % rand () end subroutine init_rand_vec_rsp subroutine init_rand_basis_rsp ( X ) type ( vector_rsp ), intent ( inout ) :: X (:) integer :: i do i = 1 , size ( X ) call X ( i )% rand () enddo end subroutine init_rand_basis_rsp subroutine init_rand_linop_rsp ( linop ) type ( linop_rsp ), intent ( inout ) :: linop real ( sp ), allocatable :: mu (:, :), var (:, :) allocate ( mu ( test_size , test_size )) ; mu = 0.0_sp allocate ( var ( test_size , test_size )) var = 1.0_sp linop % data = normal ( mu , var ) end subroutine init_rand_linop_rsp subroutine init_rand_spd_linop_rsp ( linop ) type ( spd_linop_rsp ), intent ( inout ) :: linop real ( sp ), allocatable :: mu (:, :), var (:, :) real ( sp ), allocatable :: data (:, :) allocate ( mu ( test_size , test_size )) ; mu = zero_rsp allocate ( var ( test_size , test_size )) ; var = one_rsp data = normal ( mu , var ) linop % data = matmul ( data , transpose ( data )) / test_size + 0.01_sp * eye ( test_size , mold = 1.0_sp ) end subroutine init_rand_spd_linop_rsp subroutine init_rand_vec_rdp ( x ) type ( vector_rdp ), intent ( inout ) :: x call x % rand () end subroutine init_rand_vec_rdp subroutine init_rand_basis_rdp ( X ) type ( vector_rdp ), intent ( inout ) :: X (:) integer :: i do i = 1 , size ( X ) call X ( i )% rand () enddo end subroutine init_rand_basis_rdp subroutine init_rand_linop_rdp ( linop ) type ( linop_rdp ), intent ( inout ) :: linop real ( dp ), allocatable :: mu (:, :), var (:, :) allocate ( mu ( test_size , test_size )) ; mu = 0.0_dp allocate ( var ( test_size , test_size )) var = 1.0_dp linop % data = normal ( mu , var ) end subroutine init_rand_linop_rdp subroutine init_rand_spd_linop_rdp ( linop ) type ( spd_linop_rdp ), intent ( inout ) :: linop real ( dp ), allocatable :: mu (:, :), var (:, :) real ( dp ), allocatable :: data (:, :) allocate ( mu ( test_size , test_size )) ; mu = zero_rdp allocate ( var ( test_size , test_size )) ; var = one_rdp data = normal ( mu , var ) linop % data = matmul ( data , transpose ( data )) / test_size + 0.01_dp * eye ( test_size , mold = 1.0_dp ) end subroutine init_rand_spd_linop_rdp subroutine init_rand_vec_csp ( x ) type ( vector_csp ), intent ( inout ) :: x call x % rand () end subroutine init_rand_vec_csp subroutine init_rand_basis_csp ( X ) type ( vector_csp ), intent ( inout ) :: X (:) integer :: i do i = 1 , size ( X ) call X ( i )% rand () enddo end subroutine init_rand_basis_csp subroutine init_rand_linop_csp ( linop ) type ( linop_csp ), intent ( inout ) :: linop complex ( sp ), allocatable :: mu (:, :), var (:, :) allocate ( mu ( test_size , test_size )) ; mu = 0.0_sp allocate ( var ( test_size , test_size )) var = cmplx ( 1.0_sp , 1.0_sp , kind = sp ) linop % data = normal ( mu , var ) end subroutine init_rand_linop_csp subroutine init_rand_hermitian_linop_csp ( linop ) type ( hermitian_linop_csp ), intent ( inout ) :: linop complex ( sp ), allocatable :: data (:, :) complex ( sp ), allocatable :: mu (:, :), var (:, :) allocate ( mu ( test_size , test_size )) ; mu = 0.0_sp allocate ( var ( test_size , test_size )) ; var = cmplx ( 1.0_sp , 1.0_sp , kind = sp ) data = normal ( mu , var ) data = matmul ( data , hermitian ( data )) / test_size + 0.01_sp * eye ( test_size , mold = 1.0_sp ) linop % data = data end subroutine init_rand_hermitian_linop_csp subroutine init_rand_vec_cdp ( x ) type ( vector_cdp ), intent ( inout ) :: x call x % rand () end subroutine init_rand_vec_cdp subroutine init_rand_basis_cdp ( X ) type ( vector_cdp ), intent ( inout ) :: X (:) integer :: i do i = 1 , size ( X ) call X ( i )% rand () enddo end subroutine init_rand_basis_cdp subroutine init_rand_linop_cdp ( linop ) type ( linop_cdp ), intent ( inout ) :: linop complex ( dp ), allocatable :: mu (:, :), var (:, :) allocate ( mu ( test_size , test_size )) ; mu = 0.0_dp allocate ( var ( test_size , test_size )) var = cmplx ( 1.0_dp , 1.0_dp , kind = dp ) linop % data = normal ( mu , var ) end subroutine init_rand_linop_cdp subroutine init_rand_hermitian_linop_cdp ( linop ) type ( hermitian_linop_cdp ), intent ( inout ) :: linop complex ( dp ), allocatable :: data (:, :) complex ( dp ), allocatable :: mu (:, :), var (:, :) allocate ( mu ( test_size , test_size )) ; mu = 0.0_dp allocate ( var ( test_size , test_size )) ; var = cmplx ( 1.0_dp , 1.0_dp , kind = dp ) data = normal ( mu , var ) data = matmul ( data , hermitian ( data )) / test_size + 0.01_dp * eye ( test_size , mold = 1.0_dp ) linop % data = data end subroutine init_rand_hermitian_linop_cdp subroutine get_err_str_sp ( msg , info , err ) character ( len =* ), intent ( inout ) :: msg character ( len =* ), intent ( in ) :: info real ( sp ), intent ( in ) :: err ! internals character ( len = 9 ) :: value_str character ( len =* ), parameter :: indent = repeat ( \" \" , 4 ) write ( value_str , '(E9.2)' ) err msg = indent // info // value_str // achar ( 10 ) end subroutine get_err_str_sp subroutine get_err_str_dp ( msg , info , err ) character ( len =* ), intent ( inout ) :: msg character ( len =* ), intent ( in ) :: info real ( dp ), intent ( in ) :: err ! internals character ( len = 9 ) :: value_str character ( len =* ), parameter :: indent = repeat ( \" \" , 4 ) write ( value_str , '(E9.2)' ) err msg = indent // info // value_str // achar ( 10 ) end subroutine get_err_str_dp !--------------------------------------------------- !-----     ROESSLER SYSTEM TYPE DEFINITION     ----- !--------------------------------------------------- subroutine zero_state_rsp ( self ) class ( state_vector_rsp ), intent ( inout ) :: self self % x = 0.0_sp self % y = 0.0_sp self % z = 0.0_sp end subroutine zero_state_rsp real ( sp ) function dot_state_rsp ( self , vec ) result ( alpha ) class ( state_vector_rsp ) , intent ( in ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec select type ( vec ) type is ( state_vector_rsp ) alpha = self % x * vec % x + self % y * vec % y + self % z * vec % z class default call type_error ( 'vec' , 'state_vector_rsp' , 'IN' , this_module , 'dot_state_rsp' ) end select end function dot_state_rsp subroutine scal_state_rsp ( self , alpha ) class ( state_vector_rsp ), intent ( inout ) :: self real ( sp ) , intent ( in ) :: alpha self % x = self % x * alpha self % y = self % y * alpha self % z = self % z * alpha end subroutine scal_state_rsp subroutine axpby_state_rsp ( alpha , vec , beta , self ) class ( state_vector_rsp ) , intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec real ( sp ) , intent ( in ) :: alpha , beta select type ( vec ) type is ( state_vector_rsp ) self % x = beta * self % x + alpha * vec % x self % y = beta * self % y + alpha * vec % y self % z = beta * self % z + alpha * vec % z class default call type_error ( 'vec' , 'state_vector_rsp' , 'IN' , this_module , 'axpby_state_rsp' ) end select end subroutine axpby_state_rsp integer function get_size_state_rsp ( self ) result ( N ) class ( state_vector_rsp ), intent ( in ) :: self N = 3 end function get_size_state_rsp subroutine rand_state_rsp ( self , ifnorm ) class ( state_vector_rsp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm logical :: normalized real ( sp ) :: mu , var real ( sp ) :: alpha mu = zero_rsp var = one_rsp self % x = normal ( mu , var ) self % y = normal ( mu , var ) self % z = normal ( mu , var ) normalized = optval ( ifnorm , . false .) if ( normalized ) then alpha = self % norm () call self % scal ( one_rsp / alpha ) endif end subroutine rand_state_rsp subroutine zero_state_rdp ( self ) class ( state_vector_rdp ), intent ( inout ) :: self self % x = 0.0_dp self % y = 0.0_dp self % z = 0.0_dp end subroutine zero_state_rdp real ( dp ) function dot_state_rdp ( self , vec ) result ( alpha ) class ( state_vector_rdp ) , intent ( in ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec select type ( vec ) type is ( state_vector_rdp ) alpha = self % x * vec % x + self % y * vec % y + self % z * vec % z class default call type_error ( 'vec' , 'state_vector_rdp' , 'IN' , this_module , 'dot_state_rdp' ) end select end function dot_state_rdp subroutine scal_state_rdp ( self , alpha ) class ( state_vector_rdp ), intent ( inout ) :: self real ( dp ) , intent ( in ) :: alpha self % x = self % x * alpha self % y = self % y * alpha self % z = self % z * alpha end subroutine scal_state_rdp subroutine axpby_state_rdp ( alpha , vec , beta , self ) class ( state_vector_rdp ) , intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec real ( dp ) , intent ( in ) :: alpha , beta select type ( vec ) type is ( state_vector_rdp ) self % x = beta * self % x + alpha * vec % x self % y = beta * self % y + alpha * vec % y self % z = beta * self % z + alpha * vec % z class default call type_error ( 'vec' , 'state_vector_rdp' , 'IN' , this_module , 'axpby_state_rdp' ) end select end subroutine axpby_state_rdp integer function get_size_state_rdp ( self ) result ( N ) class ( state_vector_rdp ), intent ( in ) :: self N = 3 end function get_size_state_rdp subroutine rand_state_rdp ( self , ifnorm ) class ( state_vector_rdp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm logical :: normalized real ( dp ) :: mu , var real ( dp ) :: alpha mu = zero_rdp var = one_rdp self % x = normal ( mu , var ) self % y = normal ( mu , var ) self % z = normal ( mu , var ) normalized = optval ( ifnorm , . false .) if ( normalized ) then alpha = self % norm () call self % scal ( one_rdp / alpha ) endif end subroutine rand_state_rdp subroutine eval_roessler_rsp ( self , vec_in , vec_out , atol ) class ( roessler_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out real ( sp ), intent ( in ) :: atol select type ( vec_in ) type is ( state_vector_rsp ) select type ( vec_out ) type is ( state_vector_rsp ) vec_out % x = - vec_in % y - vec_in % z vec_out % y = vec_in % x + a_sp * vec_in % y vec_out % z = b_sp + vec_in % z * ( vec_in % x - c_sp ) class default call type_error ( 'vec_out' , 'state_vector_rsp' , 'OUT' , this_module , 'eval_roessler_rsp' ) end select class default call type_error ( 'vec_in' , 'state_vector_rsp' , 'IN' , this_module , 'eval_roessler_rsp' ) end select end subroutine eval_roessler_rsp subroutine get_state_rsp ( state , X , Y , Z ) class ( abstract_vector_rsp ), intent ( in ) :: state real ( sp ), intent ( out ) :: X , Y , z select type ( state ) type is ( state_vector_rsp ) X = state % x Y = state % y Z = state % z class default call type_error ( 'state' , 'state_vector_rsp' , 'IN' , this_module , 'get_state_rsp' ) end select end subroutine get_state_rsp subroutine lin_roessler_rsp ( self , vec_in , vec_out ) class ( jacobian_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out ! internal real ( sp ) :: X , Y , Z call get_state_rsp ( self % X , X , Y , Z ) select type ( vec_in ) type is ( state_vector_rsp ) select type ( vec_out ) type is ( state_vector_rsp ) vec_out % x = - vec_in % y - vec_in % z vec_out % y = vec_in % x + a_sp * vec_in % y vec_out % z = vec_in % x * Z + vec_in % z * ( X - c_sp ) class default call type_error ( 'vec_out' , 'state_vector_rsp' , 'OUT' , this_module , 'lin_roessler_rsp' ) end select class default call type_error ( 'vec_in' , 'state_vector_rsp' , 'IN' , this_module , 'lin_roessler_rsp' ) end select end subroutine lin_roessler_rsp subroutine adj_lin_roessler_rsp ( self , vec_in , vec_out ) class ( jacobian_rsp ), intent ( inout ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out ! internal real ( sp ) :: X , Y , Z call get_state_rsp ( self % X , X , Y , Z ) select type ( vec_in ) type is ( state_vector_rsp ) select type ( vec_out ) type is ( state_vector_rsp ) vec_out % x = vec_in % y + vec_in % z * Z vec_out % y = - vec_in % x + a_sp * vec_in % y vec_out % z = - vec_in % x + vec_in % z * ( X - c_sp ) class default call type_error ( 'vec_out' , 'state_vector_rsp' , 'OUT' , this_module , 'adj_lin_roessler_rsp' ) end select class default call type_error ( 'vec_in' , 'state_vector_rsp' , 'IN' , this_module , 'adj_lin_roessler_rsp' ) end select end subroutine adj_lin_roessler_rsp subroutine roessler_analytical_fp_rsp ( fp1 , fp2 ) class ( state_vector_rsp ), intent ( out ) :: fp1 , fp2 ! internal real ( sp ) :: d d = sqrt ( c_sp ** 2 - 4 * a_sp * b_sp ) fp1 % x = ( c_sp - d ) / 2 fp1 % y = ( - c_sp + d ) / ( 2 * a_sp ) fp1 % z = ( c_sp - d ) / ( 2 * a_sp ) fp2 % x = ( c_sp + d ) / 2 fp2 % y = ( - c_sp - d ) / ( 2 * a_sp ) fp2 % z = ( c_sp + d ) / ( 2 * a_sp ) end subroutine roessler_analytical_fp_rsp subroutine eval_roessler_rdp ( self , vec_in , vec_out , atol ) class ( roessler_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out real ( dp ), intent ( in ) :: atol select type ( vec_in ) type is ( state_vector_rdp ) select type ( vec_out ) type is ( state_vector_rdp ) vec_out % x = - vec_in % y - vec_in % z vec_out % y = vec_in % x + a_dp * vec_in % y vec_out % z = b_dp + vec_in % z * ( vec_in % x - c_dp ) class default call type_error ( 'vec_out' , 'state_vector_rdp' , 'OUT' , this_module , 'eval_roessler_rdp' ) end select class default call type_error ( 'vec_in' , 'state_vector_rdp' , 'IN' , this_module , 'eval_roessler_rdp' ) end select end subroutine eval_roessler_rdp subroutine get_state_rdp ( state , X , Y , Z ) class ( abstract_vector_rdp ), intent ( in ) :: state real ( dp ), intent ( out ) :: X , Y , z select type ( state ) type is ( state_vector_rdp ) X = state % x Y = state % y Z = state % z class default call type_error ( 'state' , 'state_vector_rdp' , 'IN' , this_module , 'get_state_rdp' ) end select end subroutine get_state_rdp subroutine lin_roessler_rdp ( self , vec_in , vec_out ) class ( jacobian_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out ! internal real ( dp ) :: X , Y , Z call get_state_rdp ( self % X , X , Y , Z ) select type ( vec_in ) type is ( state_vector_rdp ) select type ( vec_out ) type is ( state_vector_rdp ) vec_out % x = - vec_in % y - vec_in % z vec_out % y = vec_in % x + a_dp * vec_in % y vec_out % z = vec_in % x * Z + vec_in % z * ( X - c_dp ) class default call type_error ( 'vec_out' , 'state_vector_rdp' , 'OUT' , this_module , 'lin_roessler_rdp' ) end select class default call type_error ( 'vec_in' , 'state_vector_rdp' , 'IN' , this_module , 'lin_roessler_rdp' ) end select end subroutine lin_roessler_rdp subroutine adj_lin_roessler_rdp ( self , vec_in , vec_out ) class ( jacobian_rdp ), intent ( inout ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out ! internal real ( dp ) :: X , Y , Z call get_state_rdp ( self % X , X , Y , Z ) select type ( vec_in ) type is ( state_vector_rdp ) select type ( vec_out ) type is ( state_vector_rdp ) vec_out % x = vec_in % y + vec_in % z * Z vec_out % y = - vec_in % x + a_dp * vec_in % y vec_out % z = - vec_in % x + vec_in % z * ( X - c_dp ) class default call type_error ( 'vec_out' , 'state_vector_rdp' , 'OUT' , this_module , 'adj_lin_roessler_rdp' ) end select class default call type_error ( 'vec_in' , 'state_vector_rdp' , 'IN' , this_module , 'adj_lin_roessler_rdp' ) end select end subroutine adj_lin_roessler_rdp subroutine roessler_analytical_fp_rdp ( fp1 , fp2 ) class ( state_vector_rdp ), intent ( out ) :: fp1 , fp2 ! internal real ( dp ) :: d d = sqrt ( c_dp ** 2 - 4 * a_dp * b_dp ) fp1 % x = ( c_dp - d ) / 2 fp1 % y = ( - c_dp + d ) / ( 2 * a_dp ) fp1 % z = ( c_dp - d ) / ( 2 * a_dp ) fp2 % x = ( c_dp + d ) / 2 fp2 % y = ( - c_dp - d ) / ( 2 * a_dp ) fp2 % z = ( c_dp + d ) / ( 2 * a_dp ) end subroutine roessler_analytical_fp_rdp !---------------------------------------------------------------- !-----     COMPLEXIFIED ROESSLER SYSTEM TYPE DEFINITION     ----- !---------------------------------------------------------------- subroutine zero_state_csp ( self ) class ( state_vector_csp ), intent ( inout ) :: self self % x = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) self % y = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) self % z = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) end subroutine zero_state_csp complex ( sp ) function dot_state_csp ( self , vec ) result ( alpha ) class ( state_vector_csp ) , intent ( in ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec select type ( vec ) type is ( state_vector_csp ) alpha = self % x * conjg ( vec % x ) + self % y * conjg ( vec % y ) + self % z * conjg ( vec % z ) class default call type_error ( 'vec' , 'state_vector_csp' , 'IN' , this_module , 'dot_state_csp' ) end select end function dot_state_csp subroutine scal_state_csp ( self , alpha ) class ( state_vector_csp ), intent ( inout ) :: self complex ( sp ) , intent ( in ) :: alpha self % x = self % x * alpha self % y = self % y * alpha self % z = self % z * alpha end subroutine scal_state_csp subroutine axpby_state_csp ( alpha , vec , beta , self ) class ( state_vector_csp ) , intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec complex ( sp ) , intent ( in ) :: alpha , beta select type ( vec ) type is ( state_vector_csp ) self % x = beta * self % x + alpha * vec % x self % y = beta * self % y + alpha * vec % y self % z = beta * self % z + alpha * vec % z class default call type_error ( 'vec' , 'state_vector_csp' , 'IN' , this_module , 'axpby_state_csp' ) end select end subroutine axpby_state_csp integer function get_size_state_csp ( self ) result ( N ) class ( state_vector_csp ), intent ( in ) :: self N = 3 end function get_size_state_csp subroutine rand_state_csp ( self , ifnorm ) class ( state_vector_csp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm logical :: normalized real ( sp ) :: mu , var real ( sp ) :: alpha mu = zero_rsp var = one_rsp self % x = cmplx ( normal ( mu , var ), normal ( mu , var ), kind = sp ) self % y = cmplx ( normal ( mu , var ), normal ( mu , var ), kind = sp ) self % z = cmplx ( normal ( mu , var ), normal ( mu , var ), kind = sp ) normalized = optval ( ifnorm , . false .) if ( normalized ) then alpha = self % norm () call self % scal ( one_csp / alpha ) endif end subroutine rand_state_csp subroutine zero_state_cdp ( self ) class ( state_vector_cdp ), intent ( inout ) :: self self % x = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) self % y = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) self % z = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) end subroutine zero_state_cdp complex ( dp ) function dot_state_cdp ( self , vec ) result ( alpha ) class ( state_vector_cdp ) , intent ( in ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec select type ( vec ) type is ( state_vector_cdp ) alpha = self % x * conjg ( vec % x ) + self % y * conjg ( vec % y ) + self % z * conjg ( vec % z ) class default call type_error ( 'vec' , 'state_vector_cdp' , 'IN' , this_module , 'dot_state_cdp' ) end select end function dot_state_cdp subroutine scal_state_cdp ( self , alpha ) class ( state_vector_cdp ), intent ( inout ) :: self complex ( dp ) , intent ( in ) :: alpha self % x = self % x * alpha self % y = self % y * alpha self % z = self % z * alpha end subroutine scal_state_cdp subroutine axpby_state_cdp ( alpha , vec , beta , self ) class ( state_vector_cdp ) , intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec complex ( dp ) , intent ( in ) :: alpha , beta select type ( vec ) type is ( state_vector_cdp ) self % x = beta * self % x + alpha * vec % x self % y = beta * self % y + alpha * vec % y self % z = beta * self % z + alpha * vec % z class default call type_error ( 'vec' , 'state_vector_cdp' , 'IN' , this_module , 'axpby_state_cdp' ) end select end subroutine axpby_state_cdp integer function get_size_state_cdp ( self ) result ( N ) class ( state_vector_cdp ), intent ( in ) :: self N = 3 end function get_size_state_cdp subroutine rand_state_cdp ( self , ifnorm ) class ( state_vector_cdp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm logical :: normalized real ( dp ) :: mu , var real ( dp ) :: alpha mu = zero_rdp var = one_rdp self % x = cmplx ( normal ( mu , var ), normal ( mu , var ), kind = dp ) self % y = cmplx ( normal ( mu , var ), normal ( mu , var ), kind = dp ) self % z = cmplx ( normal ( mu , var ), normal ( mu , var ), kind = dp ) normalized = optval ( ifnorm , . false .) if ( normalized ) then alpha = self % norm () call self % scal ( one_cdp / alpha ) endif end subroutine rand_state_cdp subroutine eval_roessler_csp ( self , vec_in , vec_out , atol ) class ( roessler_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out real ( sp ), intent ( in ) :: atol select type ( vec_in ) type is ( state_vector_csp ) select type ( vec_out ) type is ( state_vector_csp ) vec_out % x = - vec_in % y - one_im_csp * vec_in % z vec_out % y = vec_in % x + a_sp * vec_in % y vec_out % z = b_sp + vec_in % z * ( vec_in % x - c_sp ) class default call type_error ( 'vec_out' , 'state_vector_csp' , 'OUT' , this_module , 'eval_roessler_csp' ) end select class default call type_error ( 'vec_in' , 'state_vector_csp' , 'IN' , this_module , 'eval_roessler_csp' ) end select end subroutine eval_roessler_csp subroutine get_state_csp ( state , X , Y , Z ) class ( abstract_vector_csp ), intent ( in ) :: state real ( sp ), intent ( out ) :: X , Y , z select type ( state ) type is ( state_vector_csp ) X = state % x Y = state % y Z = state % z class default call type_error ( 'state' , 'state_vector_csp' , 'IN' , this_module , 'get_state_csp' ) end select end subroutine get_state_csp subroutine lin_roessler_csp ( self , vec_in , vec_out ) class ( jacobian_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out real ( sp ) :: X , Y , Z call get_state_csp ( self % X , X , Y , Z ) select type ( vec_in ) type is ( state_vector_csp ) select type ( vec_out ) type is ( state_vector_csp ) vec_out % x = - vec_in % y - one_im_csp * vec_in % z vec_out % y = vec_in % x + a_sp * vec_in % y vec_out % z = vec_in % x * Z + vec_in % z * ( X - c_sp ) class default call type_error ( 'vec_out' , 'state_vector_csp' , 'OUT' , this_module , 'lin_roessler_csp' ) end select class default call type_error ( 'vec_in' , 'state_vector_csp' , 'IN' , this_module , 'lin_roessler_csp' ) end select end subroutine lin_roessler_csp subroutine adj_lin_roessler_csp ( self , vec_in , vec_out ) class ( jacobian_csp ), intent ( inout ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out real ( sp ) :: X , Y , Z call get_state_csp ( self % X , X , Y , Z ) select type ( vec_in ) type is ( state_vector_csp ) select type ( vec_out ) type is ( state_vector_csp ) vec_out % x = vec_in % y + one_im_csp * vec_in % z * Z vec_out % y = - vec_in % x + a_sp * vec_in % y vec_out % z = - vec_in % x + vec_in % z * ( X - c_sp ) class default call type_error ( 'vec_out' , 'state_vector_csp' , 'OUT' , this_module , 'adj_lin_roessler_csp' ) end select class default call type_error ( 'vec_in' , 'state_vector_csp' , 'IN' , this_module , 'adj_lin_roessler_csp' ) end select end subroutine adj_lin_roessler_csp subroutine roessler_analytical_fp_csp ( fp1 , fp2 ) class ( state_vector_csp ), intent ( out ) :: fp1 , fp2 complex ( sp ) :: d d = sqrt ( c_sp ** 2 - 4 * one_im_csp * a_sp * b_sp ) fp1 % z = ( c_sp - d ) / ( 2 * one_im_csp * a_sp ) fp1 % x = one_im_csp * a_sp * fp1 % z fp1 % y = - one_im_csp * fp1 % z fp2 % z = ( c_sp + d ) / ( 2 * one_im_csp * a_sp ) fp2 % x = one_im_csp * a_sp * fp2 % z fp2 % y = - one_im_csp * fp2 % z end subroutine roessler_analytical_fp_csp subroutine eval_roessler_cdp ( self , vec_in , vec_out , atol ) class ( roessler_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out real ( dp ), intent ( in ) :: atol select type ( vec_in ) type is ( state_vector_cdp ) select type ( vec_out ) type is ( state_vector_cdp ) vec_out % x = - vec_in % y - one_im_cdp * vec_in % z vec_out % y = vec_in % x + a_dp * vec_in % y vec_out % z = b_dp + vec_in % z * ( vec_in % x - c_dp ) class default call type_error ( 'vec_out' , 'state_vector_cdp' , 'OUT' , this_module , 'eval_roessler_cdp' ) end select class default call type_error ( 'vec_in' , 'state_vector_cdp' , 'IN' , this_module , 'eval_roessler_cdp' ) end select end subroutine eval_roessler_cdp subroutine get_state_cdp ( state , X , Y , Z ) class ( abstract_vector_cdp ), intent ( in ) :: state real ( dp ), intent ( out ) :: X , Y , z select type ( state ) type is ( state_vector_cdp ) X = state % x Y = state % y Z = state % z class default call type_error ( 'state' , 'state_vector_cdp' , 'IN' , this_module , 'get_state_cdp' ) end select end subroutine get_state_cdp subroutine lin_roessler_cdp ( self , vec_in , vec_out ) class ( jacobian_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out real ( dp ) :: X , Y , Z call get_state_cdp ( self % X , X , Y , Z ) select type ( vec_in ) type is ( state_vector_cdp ) select type ( vec_out ) type is ( state_vector_cdp ) vec_out % x = - vec_in % y - one_im_cdp * vec_in % z vec_out % y = vec_in % x + a_dp * vec_in % y vec_out % z = vec_in % x * Z + vec_in % z * ( X - c_dp ) class default call type_error ( 'vec_out' , 'state_vector_cdp' , 'OUT' , this_module , 'lin_roessler_cdp' ) end select class default call type_error ( 'vec_in' , 'state_vector_cdp' , 'IN' , this_module , 'lin_roessler_cdp' ) end select end subroutine lin_roessler_cdp subroutine adj_lin_roessler_cdp ( self , vec_in , vec_out ) class ( jacobian_cdp ), intent ( inout ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out real ( dp ) :: X , Y , Z call get_state_cdp ( self % X , X , Y , Z ) select type ( vec_in ) type is ( state_vector_cdp ) select type ( vec_out ) type is ( state_vector_cdp ) vec_out % x = vec_in % y + one_im_cdp * vec_in % z * Z vec_out % y = - vec_in % x + a_dp * vec_in % y vec_out % z = - vec_in % x + vec_in % z * ( X - c_dp ) class default call type_error ( 'vec_out' , 'state_vector_cdp' , 'OUT' , this_module , 'adj_lin_roessler_cdp' ) end select class default call type_error ( 'vec_in' , 'state_vector_cdp' , 'IN' , this_module , 'adj_lin_roessler_cdp' ) end select end subroutine adj_lin_roessler_cdp subroutine roessler_analytical_fp_cdp ( fp1 , fp2 ) class ( state_vector_cdp ), intent ( out ) :: fp1 , fp2 complex ( dp ) :: d d = sqrt ( c_dp ** 2 - 4 * one_im_cdp * a_dp * b_dp ) fp1 % z = ( c_dp - d ) / ( 2 * one_im_cdp * a_dp ) fp1 % x = one_im_cdp * a_dp * fp1 % z fp1 % y = - one_im_cdp * fp1 % z fp2 % z = ( c_dp + d ) / ( 2 * one_im_cdp * a_dp ) fp2 % x = one_im_cdp * a_dp * fp2 % z fp2 % y = - one_im_cdp * fp2 % z end subroutine roessler_analytical_fp_cdp end module LightKrylov_TestUtils","tags":"","url":"sourcefile/testutils.f90.html"},{"title":"Timer.f90 – LightKrylov","text":"Source Code module LightKrylov_Timing !!  This module provides a set of utility functions to define default timers within `LightKrylov`. !-------------------------------------------- !-----     Standard Fortran Library     ----- !-------------------------------------------- use stdlib_optval , only : optval use stdlib_ascii , only : to_lower !------------------------------- !-----     LightKrylov     ----- !------------------------------- use LightKrylov_Logger use LightKrylov_Timer_Utils implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_Timer' character ( len =* ), parameter :: this_module_long = 'LightKrylov_Timer' logical :: if_time = . false . !---------------------------------- !-----     Public exports     ----- !---------------------------------- public :: time_lightkrylov public :: global_lightkrylov_timer ! LightKrylov_watch type type , extends ( abstract_watch ), public :: lightkrylov_watch !! Global timing structure to contain all timers within Lightkrylov contains private procedure , pass ( self ), public :: set_private_timers_and_name => set_lightkrylov_timers end type lightkrylov_watch type ( lightkrylov_watch ) :: global_lightkrylov_timer contains pure logical function time_lightkrylov () result ( if_time_lightkrylov ) if_time_lightkrylov = if_time end function time_lightkrylov subroutine set_lightkrylov_timer_switch ( value ) logical , intent ( in ) :: value if ( if_time . neqv . value ) then if_time = value if ( if_time ) then call log_message ( 'LightKrylov timing enabled.' , module = this_module ) else call log_message ( 'LightKrylov timing disabled.' , module = this_module ) end if else call log_debug ( 'LightKrylov timing switched unchanged.' , module = this_module ) end if end subroutine set_lightkrylov_timer_switch !-------------------------------------------------------------- !  Concrete implementations for the lightkrylov_watch type !-------------------------------------------------------------- subroutine set_lightkrylov_timers ( self ) !! Initialize global watch within LightKrylov and define private system timers. class ( lightkrylov_watch ), intent ( inout ) :: self ! Internal integer :: istart , iend call self % set_watch_name ( 'LightKrylov_timer' ) ! Timers for LAPACK call self % add_timer ( 'eig' , count = istart ) call self % add_timer ( 'eigh' ) call self % add_timer ( 'svd' ) call self % add_timer ( 'trsen' , count = iend ) ! Define LAPACK group call self % add_group ( 'LAPACK' , istart = istart , iend = iend ) ! Timers for Utils ! rsp call self % add_timer ( 'sqrtm_rsp' , count = istart ) call self % add_timer ( 'expm_rsp' ) ! rdp call self % add_timer ( 'sqrtm_rdp' ) call self % add_timer ( 'expm_rdp' ) ! csp call self % add_timer ( 'sqrtm_csp' ) call self % add_timer ( 'expm_csp' ) ! cdp call self % add_timer ( 'sqrtm_cdp' ) call self % add_timer ( 'expm_cdp' , count = iend ) ! Define Utils group call self % add_group ( 'Utils' , istart = istart , iend = iend ) ! Timers for BaseKrylov ! rsp call self % add_timer ( 'qr_with_pivoting_rsp' , count = istart ) call self % add_timer ( 'qr_no_pivoting_rsp' ) call self % add_timer ( 'orthonormalize_basis_rsp' ) call self % add_timer ( 'orthogonalize_vector_against_basis_rsp' ) call self % add_timer ( 'orthogonalize_basis_against_basis_rsp' ) call self % add_timer ( 'dgs_vector_against_basis_rsp' ) call self % add_timer ( 'dgs_basis_against_basis_rsp' ) call self % add_timer ( 'arnoldi_rsp' ) call self % add_timer ( 'lanczos_bidiagonalization_rsp' ) call self % add_timer ( 'lanczos_tridiagonalization_rsp' ) call self % add_timer ( 'krylov_schur_rsp' ) ! rdp call self % add_timer ( 'qr_with_pivoting_rdp' ) call self % add_timer ( 'qr_no_pivoting_rdp' ) call self % add_timer ( 'orthonormalize_basis_rdp' ) call self % add_timer ( 'orthogonalize_vector_against_basis_rdp' ) call self % add_timer ( 'orthogonalize_basis_against_basis_rdp' ) call self % add_timer ( 'dgs_vector_against_basis_rdp' ) call self % add_timer ( 'dgs_basis_against_basis_rdp' ) call self % add_timer ( 'arnoldi_rdp' ) call self % add_timer ( 'lanczos_bidiagonalization_rdp' ) call self % add_timer ( 'lanczos_tridiagonalization_rdp' ) call self % add_timer ( 'krylov_schur_rdp' ) ! csp call self % add_timer ( 'qr_with_pivoting_csp' ) call self % add_timer ( 'qr_no_pivoting_csp' ) call self % add_timer ( 'orthonormalize_basis_csp' ) call self % add_timer ( 'orthogonalize_vector_against_basis_csp' ) call self % add_timer ( 'orthogonalize_basis_against_basis_csp' ) call self % add_timer ( 'dgs_vector_against_basis_csp' ) call self % add_timer ( 'dgs_basis_against_basis_csp' ) call self % add_timer ( 'arnoldi_csp' ) call self % add_timer ( 'lanczos_bidiagonalization_csp' ) call self % add_timer ( 'lanczos_tridiagonalization_csp' ) call self % add_timer ( 'krylov_schur_csp' ) ! cdp call self % add_timer ( 'qr_with_pivoting_cdp' ) call self % add_timer ( 'qr_no_pivoting_cdp' ) call self % add_timer ( 'orthonormalize_basis_cdp' ) call self % add_timer ( 'orthogonalize_vector_against_basis_cdp' ) call self % add_timer ( 'orthogonalize_basis_against_basis_cdp' ) call self % add_timer ( 'dgs_vector_against_basis_cdp' ) call self % add_timer ( 'dgs_basis_against_basis_cdp' ) call self % add_timer ( 'arnoldi_cdp' ) call self % add_timer ( 'lanczos_bidiagonalization_cdp' ) call self % add_timer ( 'lanczos_tridiagonalization_cdp' ) call self % add_timer ( 'krylov_schur_cdp' , count = iend ) ! Define BaseKrylov group call self % add_group ( 'BaseKrylov' , istart = istart , iend = iend ) ! Timers for IterativeSolvers ! rsp call self % add_timer ( 'eigs_rsp' , count = istart ) call self % add_timer ( 'eighs_rsp' ) call self % add_timer ( 'svds_rsp' ) call self % add_timer ( 'gmres_rsp' ) call self % add_timer ( 'fgmres_rsp' ) call self % add_timer ( 'cg_rsp' ) ! rdp call self % add_timer ( 'eigs_rdp' ) call self % add_timer ( 'eighs_rdp' ) call self % add_timer ( 'svds_rdp' ) call self % add_timer ( 'gmres_rdp' ) call self % add_timer ( 'fgmres_rdp' ) call self % add_timer ( 'cg_rdp' ) ! csp call self % add_timer ( 'eigs_csp' ) call self % add_timer ( 'eighs_csp' ) call self % add_timer ( 'svds_csp' ) call self % add_timer ( 'gmres_csp' ) call self % add_timer ( 'fgmres_csp' ) call self % add_timer ( 'cg_csp' ) ! cdp call self % add_timer ( 'eigs_cdp' ) call self % add_timer ( 'eighs_cdp' ) call self % add_timer ( 'svds_cdp' ) call self % add_timer ( 'gmres_cdp' ) call self % add_timer ( 'fgmres_cdp' ) call self % add_timer ( 'cg_cdp' , count = iend ) ! Define IterativeSolvers group call self % add_group ( 'IterativeSolvers' , istart = istart , iend = iend ) ! Timers for NewtonKrylov ! rsp call self % add_timer ( 'newton_rsp' , count = istart ) ! rdp call self % add_timer ( 'newton_rdp' ) ! csp call self % add_timer ( 'newton_csp' ) ! cdp call self % add_timer ( 'newton_cdp' , count = iend ) ! Define NewtonKrylov group call self % add_group ( 'NewtonKrylov' , istart = istart , iend = iend ) ! Enable timing call set_lightkrylov_timer_switch (. true .) end subroutine set_lightkrylov_timers end module LightKrylov_Timing","tags":"","url":"sourcefile/timer.f90.html"},{"title":"ExpmLib.f90 – LightKrylov","text":"Source Code module LightKrylov_ExpmLib !!  This module implements the evaluation of the \"matrix-exponential times vector\" procedure !!  using Krylov methods. ! Iso Fortran. use iso_fortran_env , only : output_unit ! Fortran standard library. use stdlib_optval , only : optval use stdlib_linalg , only : mnorm , norm , expm ! LightKrylov. use LightKrylov_Constants use LightKrylov_Logger use LightKrylov_Utils use LightKrylov_AbstractVectors use LightKrylov_AbstractLinops use LightKrylov_BaseKrylov implicit none ( type , external ) private character ( len =* ), parameter :: this_module = 'LK_ExpmLib' character ( len =* ), parameter :: this_module_long = 'LightKrylov_ExpmLib' public :: abstract_exptA_rsp public :: abstract_exptA_rdp public :: abstract_exptA_csp public :: abstract_exptA_cdp public :: kexpm public :: krylov_exptA public :: krylov_exptA_rsp public :: krylov_exptA_rdp public :: krylov_exptA_csp public :: krylov_exptA_cdp abstract interface subroutine abstract_exptA_rsp ( vec_out , A , vec_in , tau , info , trans ) !! Abstract interface to define the matrix exponential-vector product. import sp import abstract_vector_rsp import abstract_linop_rsp implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rsp ), intent ( in ) :: vec_in !! Input vector. real ( sp ), intent ( in ) :: tau !! Time horizon for integration. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? end subroutine abstract_exptA_rsp subroutine abstract_exptA_rdp ( vec_out , A , vec_in , tau , info , trans ) !! Abstract interface to define the matrix exponential-vector product. import dp import abstract_vector_rdp import abstract_linop_rdp implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rdp ), intent ( in ) :: vec_in !! Input vector. real ( dp ), intent ( in ) :: tau !! Time horizon for integration. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? end subroutine abstract_exptA_rdp subroutine abstract_exptA_csp ( vec_out , A , vec_in , tau , info , trans ) !! Abstract interface to define the matrix exponential-vector product. import sp import abstract_vector_csp import abstract_linop_csp implicit none ( type , external ) class ( abstract_vector_csp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_csp ), intent ( in ) :: vec_in !! Input vector. real ( sp ), intent ( in ) :: tau !! Time horizon for integration. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? end subroutine abstract_exptA_csp subroutine abstract_exptA_cdp ( vec_out , A , vec_in , tau , info , trans ) !! Abstract interface to define the matrix exponential-vector product. import dp import abstract_vector_cdp import abstract_linop_cdp implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_cdp ), intent ( in ) :: vec_in !! Input vector. real ( dp ), intent ( in ) :: tau !! Time horizon for integration. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? end subroutine abstract_exptA_cdp end interface interface kexpm !!  ### Description !! !!  This interface provides methods to evaluate the matrix-vector product !!   c = \\exp(\\tau A) b  based on the Arnoldi method. !! !!  ### Syntax !! !!  ```fortran !!      call kexpm(c, A, b, tau, tol, info [, trans] [, kdim]) !!  ``` !! !!  ### Arguments !! !!  - `c`   :   Output vector (or vectors). It is an `intent(out)` argument. !! !!  - `A`   :   Linear operator to be exponentiated. It is an `intent(inout)` argument. !! !!  - `b`   :   Vector to be multiplied by  \\exp(\\tau A) . It is an `intent(in)` argument. !! !!  - `tau` :   `real` (singe or double) time over which the matrix exponential needs to !!              be computed. It is an `intent(in)` argument. !! !!  - `info`    :   `integer` Information flag. !! !!  - `trans` (optional)    :   Whether  A  or  A&#94;H  is being used. !!                              (default `trans=.false.`) !! !!  - `kdim` (optional)     :   Dimension of the Krylov subspace used in the Arnoldi method. module procedure kexpm_vec_rsp module procedure kexpm_mat_rsp module procedure kexpm_vec_rdp module procedure kexpm_mat_rdp module procedure kexpm_vec_csp module procedure kexpm_mat_csp module procedure kexpm_vec_cdp module procedure kexpm_mat_cdp end interface interface krylov_exptA !!  ### Description !! !!  Utility function to evaluate the matrix-exponential times vector. !! !!  ### Syntax !! !!  ```fortran !!      call k_exptA(vec_out, A, vec_in, tau, info, trans) !!  ``` !! !!  ### Arguments !! !!  - `vec_out` :   Output vector. !! !!  - `A`       :   Matrix to be exponentiated. !! !!  - `vec_in`  :   Input vector. !! !!  - `tau`     :   Integration time. !! !!  - `info`    :   Information flag. !! !!  - `trans`   :   Whether  A  or  A&#94;H  is being used. module procedure krylov_exptA_rsp module procedure krylov_exptA_rdp module procedure krylov_exptA_csp module procedure krylov_exptA_cdp end interface contains subroutine kexpm_vec_rsp ( c , A , b , tau , tol , info , trans , kdim ) !! Best approximation of  \\exp(\\tau \\mathbf{A}) \\mathbf{b}  in the computed Krylov subspace implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( out ) :: c class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rsp ), intent ( in ) :: b !! Input vector on which to apply  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( sp ), intent ( in ) :: tol !! Solution tolerance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'kexpm_vec_rsp' integer , parameter :: kmax = 100 integer :: k , km , kp , nk ! Arnoldi factorization. class ( abstract_vector_rsp ), allocatable :: X (:) real ( sp ), allocatable :: H (:, :) ! Normaliztion & temporary arrays. real ( sp ), allocatable :: E (:, :) class ( abstract_vector_rsp ), allocatable :: Xwrk real ( sp ) :: err_est , beta ! Optional arguments. logical :: transpose integer :: nsteps , iostat character ( len = 256 ) :: msg ! Deals with optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps info = 0 ! Allocate arrays. allocate ( X ( nk + 1 ), Xwrk , & source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( H ( nk + 1 , nk + 1 ), E ( nk + 1 , nk + 1 ), & source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Normalize input vector and initialize Krylov subspace. beta = b % norm () if ( beta == 0.0_sp ) then ! Input is zero => Output is zero. call c % zero () err_est = 0.0_sp kp = 1 else call zero_basis ( X ) call X ( 1 )% add ( b ) ; call X ( 1 )% scal ( one_rsp / beta ) expm_arnoldi : do k = 1 , nk km = k - 1 ; kp = k + 1 ! Reset work arrays. E = 0.0_sp ! Compute k-th step Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) ! Compute approximation. if ( info == k ) then ! Arnoldi breakdown, do not consider extended matrix. kp = k info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kp , : kp ) = expm ( tau * H (: kp , : kp )) ! Project back into original space. call linear_combination ( Xwrk , X (: kp ), E (: kp , 1 )) call c % axpby ( beta * one_rsp , Xwrk , zero_rsp ) ! Cheap error esimate (this actually is the magnitude of the included correction ! and thus is very conservative). err_est = merge ( 0.0_sp , abs ( E ( kp , 1 ) * beta ), info == k ) ! Check convergence. if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , nk + 1 , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) info = - 1 endif end subroutine kexpm_vec_rsp subroutine kexpm_mat_rsp ( C , A , B , tau , tol , info , trans , kdim ) !! Best Krylov approximation of  \\mathbf{C} = \\exp(\\tau \\mathbf{A}) \\mathbf{B}  in the computed Krylov subspace. implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( out ) :: C (:) class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rsp ), intent ( in ) :: B (:) !! Input matrix on which to apply  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( sp ), intent ( in ) :: tol !! Solution toleance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'kexpm_mat_rsp' integer , parameter :: kmax = 100 integer :: i , j , k , p , kpm , kp , kpp , nk ! Block-Arnoldi factorization. class ( abstract_vector_rsp ), allocatable :: X (:) real ( sp ), allocatable :: H (:, :) ! Normalization & temporary arrays. real ( sp ), allocatable :: R (:, :), E (:, :) integer , allocatable :: perm (:), ptrans (:) class ( abstract_vector_rsp ), allocatable :: Xwrk (:), Cwrk (:) real ( sp ) :: err_est ! Optional arguments. logical :: transpose integer :: nsteps , iostat character ( len = 256 ) :: msg ! Determine block size. p = size ( B ) ! Deals with the optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps * p info = 0 ! Allocate arrays. allocate ( R ( p , p ), H ( p * ( nk + 1 ), p * ( nk + 1 )), E ( p * ( nk + 1 ), p * ( nk + 1 )), & source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( perm ( p ), ptrans ( p ), & source = 0 , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( X ( p * ( nk + 1 )), Cwrk ( p ), & source = B ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( Xwrk ( p ), source = B , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Normalize input matrix and initialize Krylov subspace. call qr ( Xwrk , R , perm , info ) ; call permcols ( R , invperm ( perm )) if ( mnorm ( R , \"fro\" ) == 0.0_sp ) then ! Input matrix is zero. call zero_basis ( C ) err_est = 0.0_sp ; k = 0 ; kpp = p else call initialize_krylov_subspace ( X , Xwrk ) ; H = 0.0_sp expm_arnoldi : do k = 1 , nk ! Set counters. kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Reset working arrays. E = 0.0_sp ; call zero_basis ( Xwrk ) ! Compute the k-th step of the Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose , blksize = p ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) if ( info == kp ) then ! Arnoldi breakdown. Do not consider extended matrix. kpp = kp info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kpp , : kpp ) = expm ( tau * H (: kpp , : kpp )) ! Project back to original space. do i = 1 , size ( Xwrk ) call Xwrk ( i )% zero () do j = 1 , kpp call Xwrk ( i )% axpby ( E ( j , i ), X ( j ), one_rsp ) enddo enddo do i = 1 , p call C ( i )% zero () do j = 1 , p call C ( i )% axpby ( R ( j , i ), Xwrk ( j ), one_rsp ) enddo enddo ! Cheap error estimate. if ( info == kp ) then ! Approximation is exact. err_est = 0.0_sp else err_est = norm ( matmul ( E ( kp + 1 : kpp , : p ), R (: p , : p )), 2 ) endif if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kpp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) info = - 1 endif end subroutine kexpm_mat_rsp subroutine krylov_exptA_rsp ( vec_out , A , vec_in , tau , info , trans ) !! Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator !! on a vector that conforms to the `abstract_exptA_rsp` interface. implicit none ( type , external ) class ( abstract_vector_rsp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rsp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'krylov_exptA_rsp' real ( sp ) :: tol integer :: kdim tol = atol_sp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , this_module , this_procedure ) end subroutine krylov_exptA_rsp subroutine kexpm_vec_rdp ( c , A , b , tau , tol , info , trans , kdim ) !! Best approximation of  \\exp(\\tau \\mathbf{A}) \\mathbf{b}  in the computed Krylov subspace implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( out ) :: c class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rdp ), intent ( in ) :: b !! Input vector on which to apply  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( dp ), intent ( in ) :: tol !! Solution tolerance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'kexpm_vec_rdp' integer , parameter :: kmax = 100 integer :: k , km , kp , nk ! Arnoldi factorization. class ( abstract_vector_rdp ), allocatable :: X (:) real ( dp ), allocatable :: H (:, :) ! Normaliztion & temporary arrays. real ( dp ), allocatable :: E (:, :) class ( abstract_vector_rdp ), allocatable :: Xwrk real ( dp ) :: err_est , beta ! Optional arguments. logical :: transpose integer :: nsteps , iostat character ( len = 256 ) :: msg ! Deals with optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps info = 0 ! Allocate arrays. allocate ( X ( nk + 1 ), Xwrk , & source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( H ( nk + 1 , nk + 1 ), E ( nk + 1 , nk + 1 ), & source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Normalize input vector and initialize Krylov subspace. beta = b % norm () if ( beta == 0.0_dp ) then ! Input is zero => Output is zero. call c % zero () err_est = 0.0_dp kp = 1 else call zero_basis ( X ) call X ( 1 )% add ( b ) ; call X ( 1 )% scal ( one_rdp / beta ) expm_arnoldi : do k = 1 , nk km = k - 1 ; kp = k + 1 ! Reset work arrays. E = 0.0_dp ! Compute k-th step Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) ! Compute approximation. if ( info == k ) then ! Arnoldi breakdown, do not consider extended matrix. kp = k info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kp , : kp ) = expm ( tau * H (: kp , : kp )) ! Project back into original space. call linear_combination ( Xwrk , X (: kp ), E (: kp , 1 )) call c % axpby ( beta * one_rdp , Xwrk , zero_rdp ) ! Cheap error esimate (this actually is the magnitude of the included correction ! and thus is very conservative). err_est = merge ( 0.0_dp , abs ( E ( kp , 1 ) * beta ), info == k ) ! Check convergence. if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , nk + 1 , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) info = - 1 endif end subroutine kexpm_vec_rdp subroutine kexpm_mat_rdp ( C , A , B , tau , tol , info , trans , kdim ) !! Best Krylov approximation of  \\mathbf{C} = \\exp(\\tau \\mathbf{A}) \\mathbf{B}  in the computed Krylov subspace. implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( out ) :: C (:) class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rdp ), intent ( in ) :: B (:) !! Input matrix on which to apply  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( dp ), intent ( in ) :: tol !! Solution toleance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'kexpm_mat_rdp' integer , parameter :: kmax = 100 integer :: i , j , k , p , kpm , kp , kpp , nk ! Block-Arnoldi factorization. class ( abstract_vector_rdp ), allocatable :: X (:) real ( dp ), allocatable :: H (:, :) ! Normalization & temporary arrays. real ( dp ), allocatable :: R (:, :), E (:, :) integer , allocatable :: perm (:), ptrans (:) class ( abstract_vector_rdp ), allocatable :: Xwrk (:), Cwrk (:) real ( dp ) :: err_est ! Optional arguments. logical :: transpose integer :: nsteps , iostat character ( len = 256 ) :: msg ! Determine block size. p = size ( B ) ! Deals with the optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps * p info = 0 ! Allocate arrays. allocate ( R ( p , p ), H ( p * ( nk + 1 ), p * ( nk + 1 )), E ( p * ( nk + 1 ), p * ( nk + 1 )), & source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( perm ( p ), ptrans ( p ), & source = 0 , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( X ( p * ( nk + 1 )), Cwrk ( p ), & source = B ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( Xwrk ( p ), source = B , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Normalize input matrix and initialize Krylov subspace. call qr ( Xwrk , R , perm , info ) ; call permcols ( R , invperm ( perm )) if ( mnorm ( R , \"fro\" ) == 0.0_dp ) then ! Input matrix is zero. call zero_basis ( C ) err_est = 0.0_dp ; k = 0 ; kpp = p else call initialize_krylov_subspace ( X , Xwrk ) ; H = 0.0_dp expm_arnoldi : do k = 1 , nk ! Set counters. kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Reset working arrays. E = 0.0_dp ; call zero_basis ( Xwrk ) ! Compute the k-th step of the Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose , blksize = p ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) if ( info == kp ) then ! Arnoldi breakdown. Do not consider extended matrix. kpp = kp info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kpp , : kpp ) = expm ( tau * H (: kpp , : kpp )) ! Project back to original space. do i = 1 , size ( Xwrk ) call Xwrk ( i )% zero () do j = 1 , kpp call Xwrk ( i )% axpby ( E ( j , i ), X ( j ), one_rdp ) enddo enddo do i = 1 , p call C ( i )% zero () do j = 1 , p call C ( i )% axpby ( R ( j , i ), Xwrk ( j ), one_rdp ) enddo enddo ! Cheap error estimate. if ( info == kp ) then ! Approximation is exact. err_est = 0.0_dp else err_est = norm ( matmul ( E ( kp + 1 : kpp , : p ), R (: p , : p )), 2 ) endif if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kpp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) info = - 1 endif end subroutine kexpm_mat_rdp subroutine krylov_exptA_rdp ( vec_out , A , vec_in , tau , info , trans ) !! Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator !! on a vector that conforms to the `abstract_exptA_rdp` interface. implicit none ( type , external ) class ( abstract_vector_rdp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rdp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'krylov_exptA_rdp' real ( dp ) :: tol integer :: kdim tol = atol_dp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , this_module , this_procedure ) end subroutine krylov_exptA_rdp subroutine kexpm_vec_csp ( c , A , b , tau , tol , info , trans , kdim ) !! Best approximation of  \\exp(\\tau \\mathbf{A}) \\mathbf{b}  in the computed Krylov subspace implicit none ( type , external ) class ( abstract_vector_csp ), intent ( out ) :: c class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_csp ), intent ( in ) :: b !! Input vector on which to apply  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( sp ), intent ( in ) :: tol !! Solution tolerance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'kexpm_vec_csp' integer , parameter :: kmax = 100 integer :: k , km , kp , nk ! Arnoldi factorization. class ( abstract_vector_csp ), allocatable :: X (:) complex ( sp ), allocatable :: H (:, :) ! Normaliztion & temporary arrays. complex ( sp ), allocatable :: E (:, :) class ( abstract_vector_csp ), allocatable :: Xwrk real ( sp ) :: err_est , beta ! Optional arguments. logical :: transpose integer :: nsteps , iostat character ( len = 256 ) :: msg ! Deals with optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps info = 0 ! Allocate arrays. allocate ( X ( nk + 1 ), Xwrk , & source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( H ( nk + 1 , nk + 1 ), E ( nk + 1 , nk + 1 ), & source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Normalize input vector and initialize Krylov subspace. beta = b % norm () if ( beta == 0.0_sp ) then ! Input is zero => Output is zero. call c % zero () err_est = 0.0_sp kp = 1 else call zero_basis ( X ) call X ( 1 )% add ( b ) ; call X ( 1 )% scal ( one_csp / beta ) expm_arnoldi : do k = 1 , nk km = k - 1 ; kp = k + 1 ! Reset work arrays. E = 0.0_sp ! Compute k-th step Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) ! Compute approximation. if ( info == k ) then ! Arnoldi breakdown, do not consider extended matrix. kp = k info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kp , : kp ) = expm ( tau * H (: kp , : kp )) ! Project back into original space. call linear_combination ( Xwrk , X (: kp ), E (: kp , 1 )) call c % axpby ( beta * one_csp , Xwrk , zero_csp ) ! Cheap error esimate (this actually is the magnitude of the included correction ! and thus is very conservative). err_est = merge ( 0.0_sp , abs ( E ( kp , 1 ) * beta ), info == k ) ! Check convergence. if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , nk + 1 , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) info = - 1 endif end subroutine kexpm_vec_csp subroutine kexpm_mat_csp ( C , A , B , tau , tol , info , trans , kdim ) !! Best Krylov approximation of  \\mathbf{C} = \\exp(\\tau \\mathbf{A}) \\mathbf{B}  in the computed Krylov subspace. implicit none ( type , external ) class ( abstract_vector_csp ), intent ( out ) :: C (:) class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_csp ), intent ( in ) :: B (:) !! Input matrix on which to apply  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( sp ), intent ( in ) :: tol !! Solution toleance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'kexpm_mat_csp' integer , parameter :: kmax = 100 integer :: i , j , k , p , kpm , kp , kpp , nk ! Block-Arnoldi factorization. class ( abstract_vector_csp ), allocatable :: X (:) complex ( sp ), allocatable :: H (:, :) ! Normalization & temporary arrays. complex ( sp ), allocatable :: R (:, :), E (:, :) integer , allocatable :: perm (:), ptrans (:) class ( abstract_vector_csp ), allocatable :: Xwrk (:), Cwrk (:) real ( sp ) :: err_est ! Optional arguments. logical :: transpose integer :: nsteps , iostat character ( len = 256 ) :: msg ! Determine block size. p = size ( B ) ! Deals with the optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps * p info = 0 ! Allocate arrays. allocate ( R ( p , p ), H ( p * ( nk + 1 ), p * ( nk + 1 )), E ( p * ( nk + 1 ), p * ( nk + 1 )), & source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( perm ( p ), ptrans ( p ), & source = 0 , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( X ( p * ( nk + 1 )), Cwrk ( p ), & source = B ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( Xwrk ( p ), source = B , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Normalize input matrix and initialize Krylov subspace. call qr ( Xwrk , R , perm , info ) ; call permcols ( R , invperm ( perm )) if ( mnorm ( R , \"fro\" ) == 0.0_sp ) then ! Input matrix is zero. call zero_basis ( C ) err_est = 0.0_sp ; k = 0 ; kpp = p else call initialize_krylov_subspace ( X , Xwrk ) ; H = 0.0_sp expm_arnoldi : do k = 1 , nk ! Set counters. kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Reset working arrays. E = 0.0_sp ; call zero_basis ( Xwrk ) ! Compute the k-th step of the Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose , blksize = p ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) if ( info == kp ) then ! Arnoldi breakdown. Do not consider extended matrix. kpp = kp info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kpp , : kpp ) = expm ( tau * H (: kpp , : kpp )) ! Project back to original space. do i = 1 , size ( Xwrk ) call Xwrk ( i )% zero () do j = 1 , kpp call Xwrk ( i )% axpby ( E ( j , i ), X ( j ), one_csp ) enddo enddo do i = 1 , p call C ( i )% zero () do j = 1 , p call C ( i )% axpby ( R ( j , i ), Xwrk ( j ), one_csp ) enddo enddo ! Cheap error estimate. if ( info == kp ) then ! Approximation is exact. err_est = 0.0_sp else err_est = norm ( matmul ( E ( kp + 1 : kpp , : p ), R (: p , : p )), 2 ) endif if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kpp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) info = - 1 endif end subroutine kexpm_mat_csp subroutine krylov_exptA_csp ( vec_out , A , vec_in , tau , info , trans ) !! Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator !! on a vector that conforms to the `abstract_exptA_csp` interface. implicit none ( type , external ) class ( abstract_vector_csp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_csp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'krylov_exptA_csp' real ( sp ) :: tol integer :: kdim tol = atol_sp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , this_module , this_procedure ) end subroutine krylov_exptA_csp subroutine kexpm_vec_cdp ( c , A , b , tau , tol , info , trans , kdim ) !! Best approximation of  \\exp(\\tau \\mathbf{A}) \\mathbf{b}  in the computed Krylov subspace implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( out ) :: c class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_cdp ), intent ( in ) :: b !! Input vector on which to apply  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( dp ), intent ( in ) :: tol !! Solution tolerance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'kexpm_vec_cdp' integer , parameter :: kmax = 100 integer :: k , km , kp , nk ! Arnoldi factorization. class ( abstract_vector_cdp ), allocatable :: X (:) complex ( dp ), allocatable :: H (:, :) ! Normaliztion & temporary arrays. complex ( dp ), allocatable :: E (:, :) class ( abstract_vector_cdp ), allocatable :: Xwrk real ( dp ) :: err_est , beta ! Optional arguments. logical :: transpose integer :: nsteps , iostat character ( len = 256 ) :: msg ! Deals with optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps info = 0 ! Allocate arrays. allocate ( X ( nk + 1 ), Xwrk , & source = b , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( H ( nk + 1 , nk + 1 ), E ( nk + 1 , nk + 1 ), & source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Normalize input vector and initialize Krylov subspace. beta = b % norm () if ( beta == 0.0_dp ) then ! Input is zero => Output is zero. call c % zero () err_est = 0.0_dp kp = 1 else call zero_basis ( X ) call X ( 1 )% add ( b ) ; call X ( 1 )% scal ( one_cdp / beta ) expm_arnoldi : do k = 1 , nk km = k - 1 ; kp = k + 1 ! Reset work arrays. E = 0.0_dp ! Compute k-th step Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) ! Compute approximation. if ( info == k ) then ! Arnoldi breakdown, do not consider extended matrix. kp = k info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kp , : kp ) = expm ( tau * H (: kp , : kp )) ! Project back into original space. call linear_combination ( Xwrk , X (: kp ), E (: kp , 1 )) call c % axpby ( beta * one_cdp , Xwrk , zero_cdp ) ! Cheap error esimate (this actually is the magnitude of the included correction ! and thus is very conservative). err_est = merge ( 0.0_dp , abs ( E ( kp , 1 ) * beta ), info == k ) ! Check convergence. if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , nk + 1 , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) info = - 1 endif end subroutine kexpm_vec_cdp subroutine kexpm_mat_cdp ( C , A , B , tau , tol , info , trans , kdim ) !! Best Krylov approximation of  \\mathbf{C} = \\exp(\\tau \\mathbf{A}) \\mathbf{B}  in the computed Krylov subspace. implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( out ) :: C (:) class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_cdp ), intent ( in ) :: B (:) !! Input matrix on which to apply  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( dp ), intent ( in ) :: tol !! Solution toleance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'kexpm_mat_cdp' integer , parameter :: kmax = 100 integer :: i , j , k , p , kpm , kp , kpp , nk ! Block-Arnoldi factorization. class ( abstract_vector_cdp ), allocatable :: X (:) complex ( dp ), allocatable :: H (:, :) ! Normalization & temporary arrays. complex ( dp ), allocatable :: R (:, :), E (:, :) integer , allocatable :: perm (:), ptrans (:) class ( abstract_vector_cdp ), allocatable :: Xwrk (:), Cwrk (:) real ( dp ) :: err_est ! Optional arguments. logical :: transpose integer :: nsteps , iostat character ( len = 256 ) :: msg ! Determine block size. p = size ( B ) ! Deals with the optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps * p info = 0 ! Allocate arrays. allocate ( R ( p , p ), H ( p * ( nk + 1 ), p * ( nk + 1 )), E ( p * ( nk + 1 ), p * ( nk + 1 )), & source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( perm ( p ), ptrans ( p ), & source = 0 , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( X ( p * ( nk + 1 )), Cwrk ( p ), & source = B ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( Xwrk ( p ), source = B , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Normalize input matrix and initialize Krylov subspace. call qr ( Xwrk , R , perm , info ) ; call permcols ( R , invperm ( perm )) if ( mnorm ( R , \"fro\" ) == 0.0_dp ) then ! Input matrix is zero. call zero_basis ( C ) err_est = 0.0_dp ; k = 0 ; kpp = p else call initialize_krylov_subspace ( X , Xwrk ) ; H = 0.0_dp expm_arnoldi : do k = 1 , nk ! Set counters. kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Reset working arrays. E = 0.0_dp ; call zero_basis ( Xwrk ) ! Compute the k-th step of the Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose , blksize = p ) call check_info ( info , 'arnoldi' , this_module , this_procedure ) if ( info == kp ) then ! Arnoldi breakdown. Do not consider extended matrix. kpp = kp info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kpp , : kpp ) = expm ( tau * H (: kpp , : kpp )) ! Project back to original space. do i = 1 , size ( Xwrk ) call Xwrk ( i )% zero () do j = 1 , kpp call Xwrk ( i )% axpby ( E ( j , i ), X ( j ), one_cdp ) enddo enddo do i = 1 , p call C ( i )% zero () do j = 1 , p call C ( i )% axpby ( R ( j , i ), Xwrk ( j ), one_cdp ) enddo enddo ! Cheap error estimate. if ( info == kp ) then ! Approximation is exact. err_est = 0.0_dp else err_est = norm ( matmul ( E ( kp + 1 : kpp , : p ), R (: p , : p )), 2 ) endif if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kpp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call log_information ( msg , this_module , this_procedure ) info = - 1 endif end subroutine kexpm_mat_cdp subroutine krylov_exptA_cdp ( vec_out , A , vec_in , tau , info , trans ) !! Wrapper for the Krylov-based evaluation of the action of the matrix exponential operator !! on a vector that conforms to the `abstract_exptA_cdp` interface. implicit none ( type , external ) class ( abstract_vector_cdp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_cdp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- character ( len =* ), parameter :: this_procedure = 'krylov_exptA_cdp' real ( dp ) :: tol integer :: kdim tol = atol_dp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , this_module , this_procedure ) end subroutine krylov_exptA_cdp end module LightKrylov_ExpmLib","tags":"","url":"sourcefile/expmlib.f90.html"},{"title":"eighs.f90 – LightKrylov","text":"Source Code submodule ( lightkrylov_iterativesolvers ) hermitian_eigensolvers use stdlib_strings , only : padr use stdlib_linalg , only : eigh implicit none ( type , external ) character ( len =* ), parameter :: eighs_output = 'eighs_output.txt' contains !----- Utility functions ----- elemental pure function eigenvalue_residual_rsp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. real ( sp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. real ( sp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( sp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function eigenvalue_residual_rsp elemental pure function eigenvalue_residual_rdp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. real ( dp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. real ( dp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( dp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function eigenvalue_residual_rdp elemental pure function eigenvalue_residual_csp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. complex ( sp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. complex ( sp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( sp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function eigenvalue_residual_csp elemental pure function eigenvalue_residual_cdp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. complex ( dp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. complex ( dp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( dp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) end function eigenvalue_residual_cdp !-------------------------------------------------- !-----     ABSTRACT HERMITIAN EIGENSOLVER     ----- !-------------------------------------------------- module procedure eighs_rsp class ( abstract_vector_rsp ), allocatable :: Xwrk (:) ! Krylov subspace. integer :: kdim_ ! Krylov subspace dimension. real ( sp ), allocatable :: T (:, :) ! Tridiagonal matrix. real ( sp ), allocatable :: eigvecs_wrk (:, :) ! Working array for the Ritz eigenvectors. real ( sp ), allocatable :: eigvals_wrk (:) ! Working array for the Ritz eigenvalues. real ( sp ), allocatable :: residuals_wrk (:) ! Working array for the Ritz residuals. real ( sp ) :: x0_norm ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'eighs_rsp' integer :: i , j , k , nev , conv , iostat real ( sp ) :: tol real ( sp ) :: beta logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deaks with the optional args. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_sp ) outpost = optval ( write_intermediate , . false .) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), mold = X ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Xwrk ) if ( present ( x0 )) then call copy ( Xwrk ( 1 ), x0 ) x0_norm = x0 % norm (); call Xwrk ( 1 )% scal ( one_rsp / x0_norm ) else call Xwrk ( 1 )% rand (. true .) endif allocate ( T ( kdim_ + 1 , kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvecs_wrk ( kdim_ , kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvals_wrk ( kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Ritz eigenpairs computation. lanczos_iter : do k = 1 , kdim_ ! Symmetric Lanczos step. call lanczos ( A , Xwrk , T , info , kstart = k , kend = k ) call check_info ( info , 'lanczos' , this_module , this_procedure ) ! Spectral decomposition of the k x k tridiagonal matrix. eigvals_wrk = 0.0_sp ; eigvecs_wrk = zero_rsp if ( time_lightkrylov ()) call timer % start ( 'eigh' ) call eigh ( T (: k , : k ), eigvals_wrk (: k ), vectors = eigvecs_wrk (: k , : k )) if ( time_lightkrylov ()) call timer % stop ( 'eigh' ) ! Compute residuals. beta = T ( k + 1 , k ) residuals_wrk (: k ) = eigenvalue_residual_rsp ( beta , eigvecs_wrk ( k , : k )) ! Check convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , k , & & ' iterations of the Lanczos process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_rsp ( eighs_output , eigvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nev ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) call sort_index ( eigvals_wrk , indices , reverse = . true .) eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. k = min ( k , kdim_ ) do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( eigvecs_wrk ( j , i ), Xwrk ( j ), one_rsp ) enddo enddo info = k if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure eighs_rdp class ( abstract_vector_rdp ), allocatable :: Xwrk (:) ! Krylov subspace. integer :: kdim_ ! Krylov subspace dimension. real ( dp ), allocatable :: T (:, :) ! Tridiagonal matrix. real ( dp ), allocatable :: eigvecs_wrk (:, :) ! Working array for the Ritz eigenvectors. real ( dp ), allocatable :: eigvals_wrk (:) ! Working array for the Ritz eigenvalues. real ( dp ), allocatable :: residuals_wrk (:) ! Working array for the Ritz residuals. real ( dp ) :: x0_norm ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'eighs_rdp' integer :: i , j , k , nev , conv , iostat real ( dp ) :: tol real ( dp ) :: beta logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deaks with the optional args. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_dp ) outpost = optval ( write_intermediate , . false .) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), mold = X ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Xwrk ) if ( present ( x0 )) then call copy ( Xwrk ( 1 ), x0 ) x0_norm = x0 % norm (); call Xwrk ( 1 )% scal ( one_rdp / x0_norm ) else call Xwrk ( 1 )% rand (. true .) endif allocate ( T ( kdim_ + 1 , kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvecs_wrk ( kdim_ , kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvals_wrk ( kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Ritz eigenpairs computation. lanczos_iter : do k = 1 , kdim_ ! Symmetric Lanczos step. call lanczos ( A , Xwrk , T , info , kstart = k , kend = k ) call check_info ( info , 'lanczos' , this_module , this_procedure ) ! Spectral decomposition of the k x k tridiagonal matrix. eigvals_wrk = 0.0_dp ; eigvecs_wrk = zero_rdp if ( time_lightkrylov ()) call timer % start ( 'eigh' ) call eigh ( T (: k , : k ), eigvals_wrk (: k ), vectors = eigvecs_wrk (: k , : k )) if ( time_lightkrylov ()) call timer % stop ( 'eigh' ) ! Compute residuals. beta = T ( k + 1 , k ) residuals_wrk (: k ) = eigenvalue_residual_rdp ( beta , eigvecs_wrk ( k , : k )) ! Check convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , k , & & ' iterations of the Lanczos process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_rdp ( eighs_output , eigvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nev ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) call sort_index ( eigvals_wrk , indices , reverse = . true .) eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. k = min ( k , kdim_ ) do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( eigvecs_wrk ( j , i ), Xwrk ( j ), one_rdp ) enddo enddo info = k if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure eighs_csp class ( abstract_vector_csp ), allocatable :: Xwrk (:) ! Krylov subspace. integer :: kdim_ ! Krylov subspace dimension. complex ( sp ), allocatable :: T (:, :) ! Tridiagonal matrix. complex ( sp ), allocatable :: eigvecs_wrk (:, :) ! Working array for the Ritz eigenvectors. real ( sp ), allocatable :: eigvals_wrk (:) ! Working array for the Ritz eigenvalues. real ( sp ), allocatable :: residuals_wrk (:) ! Working array for the Ritz residuals. real ( sp ) :: x0_norm ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'eighs_csp' integer :: i , j , k , nev , conv , iostat real ( sp ) :: tol complex ( sp ) :: beta logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deaks with the optional args. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_sp ) outpost = optval ( write_intermediate , . false .) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), mold = X ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Xwrk ) if ( present ( x0 )) then call copy ( Xwrk ( 1 ), x0 ) x0_norm = x0 % norm (); call Xwrk ( 1 )% scal ( one_csp / x0_norm ) else call Xwrk ( 1 )% rand (. true .) endif allocate ( T ( kdim_ + 1 , kdim_ ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvecs_wrk ( kdim_ , kdim_ ), source = zero_csp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvals_wrk ( kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rsp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Ritz eigenpairs computation. lanczos_iter : do k = 1 , kdim_ ! Symmetric Lanczos step. call lanczos ( A , Xwrk , T , info , kstart = k , kend = k ) call check_info ( info , 'lanczos' , this_module , this_procedure ) ! Spectral decomposition of the k x k tridiagonal matrix. eigvals_wrk = 0.0_sp ; eigvecs_wrk = zero_csp if ( time_lightkrylov ()) call timer % start ( 'eigh' ) call eigh ( T (: k , : k ), eigvals_wrk (: k ), vectors = eigvecs_wrk (: k , : k )) if ( time_lightkrylov ()) call timer % stop ( 'eigh' ) ! Compute residuals. beta = T ( k + 1 , k ) residuals_wrk (: k ) = eigenvalue_residual_csp ( beta , eigvecs_wrk ( k , : k )) ! Check convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , k , & & ' iterations of the Lanczos process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_rsp ( eighs_output , eigvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nev ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) call sort_index ( eigvals_wrk , indices , reverse = . true .) eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. k = min ( k , kdim_ ) do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( eigvecs_wrk ( j , i ), Xwrk ( j ), one_csp ) enddo enddo info = k if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure module procedure eighs_cdp class ( abstract_vector_cdp ), allocatable :: Xwrk (:) ! Krylov subspace. integer :: kdim_ ! Krylov subspace dimension. complex ( dp ), allocatable :: T (:, :) ! Tridiagonal matrix. complex ( dp ), allocatable :: eigvecs_wrk (:, :) ! Working array for the Ritz eigenvectors. real ( dp ), allocatable :: eigvals_wrk (:) ! Working array for the Ritz eigenvalues. real ( dp ), allocatable :: residuals_wrk (:) ! Working array for the Ritz residuals. real ( dp ) :: x0_norm ! Miscellaneous. character ( len =* ), parameter :: this_procedure = 'eighs_cdp' integer :: i , j , k , nev , conv , iostat real ( dp ) :: tol complex ( dp ) :: beta logical :: outpost character ( len = 256 ) :: msg if ( time_lightkrylov ()) call timer % start ( this_procedure ) ! Deaks with the optional args. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_dp ) outpost = optval ( write_intermediate , . false .) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), mold = X ( 1 ), stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) call zero_basis ( Xwrk ) if ( present ( x0 )) then call copy ( Xwrk ( 1 ), x0 ) x0_norm = x0 % norm (); call Xwrk ( 1 )% scal ( one_cdp / x0_norm ) else call Xwrk ( 1 )% rand (. true .) endif allocate ( T ( kdim_ + 1 , kdim_ ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvecs_wrk ( kdim_ , kdim_ ), source = zero_cdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( eigvals_wrk ( kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) allocate ( residuals_wrk ( kdim_ ), source = zero_rdp , stat = iostat , errmsg = msg ) call check_allocation ( iostat , msg , this_module , this_procedure ) ! Ritz eigenpairs computation. lanczos_iter : do k = 1 , kdim_ ! Symmetric Lanczos step. call lanczos ( A , Xwrk , T , info , kstart = k , kend = k ) call check_info ( info , 'lanczos' , this_module , this_procedure ) ! Spectral decomposition of the k x k tridiagonal matrix. eigvals_wrk = 0.0_dp ; eigvecs_wrk = zero_cdp if ( time_lightkrylov ()) call timer % start ( 'eigh' ) call eigh ( T (: k , : k ), eigvals_wrk (: k ), vectors = eigvecs_wrk (: k , : k )) if ( time_lightkrylov ()) call timer % stop ( 'eigh' ) ! Compute residuals. beta = T ( k + 1 , k ) residuals_wrk (: k ) = eigenvalue_residual_cdp ( beta , eigvecs_wrk ( k , : k )) ! Check convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , k , & & ' iterations of the Lanczos process.' call log_information ( msg , this_module , this_procedure ) if ( outpost ) call write_results_rdp ( eighs_output , eigvals_wrk (: k ), residuals_wrk (: k ), tol ) if ( conv >= nev ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) call sort_index ( eigvals_wrk , indices , reverse = . true .) eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. k = min ( k , kdim_ ) do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( eigvecs_wrk ( j , i ), Xwrk ( j ), one_cdp ) enddo enddo info = k if ( time_lightkrylov ()) call timer % stop ( this_procedure ) end procedure end submodule","tags":"","url":"sourcefile/eighs.f90.html"},{"title":"Overview – LightKrylov","text":"Warning This page is under construction","tags":"","url":"page/index.html"},{"title":"Examples – LightKrylov","text":"","tags":"","url":"page/examples/index.html"},{"title":"Ginzburg-Landau – LightKrylov","text":"Leading eigenpairs of the linearized Ginzburg-Landau equation The linearized complex Ginzburg-Landau equation is a one-dimensional partial differential equation of convection-diffusion type.\nIt is given by The spatial domain considered is formaly infinite, hence there are no boundary conditions.\nYet, the complex-valued solution is required to remain finite as .\nThe complex convective velocity is defined as , while the complex diffusion parameter is .\nThe spatially varying parameter is defined as In the region given by perturbations are spatially amplified.\nOutside of this region, they are exponentially attenuated.\nThis simple partial differential equation has been extensively used in the hydrodynamic stability community as a model for spatially developing flows, as well as a prototypical example for reduced-order modeling and controller design.\nFor more details, interested readers are refered to [ 1 , 2 , 3 , 4 ] and references therein.\nHere, we use this seemingly simple test case to illustrate how one can compute the leading eigenpairs of this linear operator with LightKrylov using a time-stepper approach. Time-stepping and eigenvalue analysis - Suppose the equations have been discretized in space such that we now consider the finite-dimensional continuous-time linear time invariant dynamical system where is the state vector of the system, and its dynamics matrix.\nWhen studying the linear stability of such systems, one is often interested in the eigenvalues of having small real parts (i.e. in the vicinity of the imaginary axis).\nWhile direct solvers such as QZ can be used when the dimension n is relatively small, one often needs to turn to iterative solvers for large-scale systems.\nUnfortunately, techniques such as the Arnoldi iteration tend to converge first the eigenvalues having the largest magnitude.\nIn order to overcome this limitation, a possibly remedy is to use a shift-invert strategy.\nSuch a strategy however requires the inversion of a possibly very ill-conditioned linear system at each iteration.\nAnother alternative, pioneered by Laurette Tuckerman , is to consider the following eigenvalue problem where is an eigenvector of both and and the eigenvalues are related to those of via a simple logarithmic transformation.\nSuch a reformulation of the problem is advantageous for two main reasons: The eigenvalues of close to the imaginary axis get mapped along the unit-circle while those with very negative real parts get mapped close to zero. As a consequence, in the transformed complex plane, the eigenvalues of interest become the outer-most ones of the exponential matrix and thus the first to converge when using an iterative procedure. When using an interative procedure, only the matrix-vector product is needed. For a matrix exponential, this product can be easily and efficiently computed using a standard time-integration scheme. Consequently, it requires only a minimal set of modifications to adapt an existing simulation code for it to perform linear stability analyses. Over the past two decades, this time-stepper approach to stability analysis has been instrumental in the field of hydrodynamic stability analysis.\nFor more details, please refer to [5, 6, 7, 8, 9]. Computing the leading eigenpairs of the Ginzburg-Landau equation via time-stepping Note Owing to the small size of the problem, computing the leading eigenpairs of the linearized Ginzburg-Landau operator using a time-stepper approach is not the recommended way to proceed. The code is only used for illustratory purposes. The performance-critical part in a time-stepper approach for eigenvalue computation is the evaluation of the exponential matrix applied to a given vector .\nNote that the exponential matrix does not have to be computed using classical dens elinear algebra.\nInstead, the can be computed by simply time-marching the linearized equations. Numerical setup - The computational domain consider is along with homogeneous Dirichlet boundary conditions. This domain is large enough such that finite-length effects are negligible.\nThe spatial derivatives are discretized using second-order accurate finite differences on a uniform grid. The routine below then uses the Runge-Kutta class provided by rklib to implement the right-hand side of the linearized discretized system. subroutine rhs ( me , t , x , f ) ! Time-integrator. class ( rk_class ), intent ( inout ) :: me ! Current time. real ( kind = dp ), intent ( in ) :: t ! State vector. real ( kind = dp ), dimension (:), intent ( in ) :: x ! Time-derivative. real ( kind = dp ), dimension (:), intent ( out ) :: f ! Internal variables. integer :: i real ( kind = dp ), dimension ( nx ) :: u , du , v , dv real ( kind = dp ) :: d2u , d2v , cu , cv ! Sets the internal variables. f = 0.0_dp ; u = x ( 1 : nx ); du = 0.0_dp v = x ( nx + 1 : 2 * nx ) ; dv = 0.0_dp !--------------------------------------------------- !-----     Linear Ginzburg Landau Equation     ----- !--------------------------------------------------- ! Left most boundary points. cu = u ( 2 ) / ( 2 * dx ); cv = v ( 2 ) / ( 2 * dx ) du ( 1 ) = - ( real ( nu ) * cu - aimag ( nu ) * cv ) ! Convective term. dv ( 1 ) = - ( aimag ( nu ) * cu + real ( nu ) * cv ) ! Convective term. d2u = ( u ( 2 ) - 2 * u ( 1 )) / dx ** 2 ; d2v = ( v ( 2 ) - 2 * v ( 1 )) / dx ** 2 du ( 1 ) = du ( 1 ) + real ( gamma ) * d2u - aimag ( gamma ) * d2v ! Diffusion term. dv ( 1 ) = dv ( 1 ) + aimag ( gamma ) * d2u + real ( gamma ) * d2v ! Diffusion term. du ( 1 ) = du ( 1 ) + mu ( 1 ) * u ( 1 ) ! Non-parallel term. dv ( 1 ) = dv ( 1 ) + mu ( 1 ) * v ( 1 ) ! Non-parallel term. ! Interior nodes. do i = 2 , nx - 1 ! Convective term. cu = ( u ( i + 1 ) - u ( i - 1 )) / ( 2 * dx ) cv = ( v ( i + 1 ) - v ( i - 1 )) / ( 2 * dx ) du ( i ) = - ( real ( nu ) * cu - aimag ( nu ) * cv ) dv ( i ) = - ( aimag ( nu ) * cu + real ( nu ) * cv ) ! Diffusion term. d2u = ( u ( i + 1 ) - 2 * u ( i ) + u ( i - 1 )) / dx ** 2 d2v = ( v ( i + 1 ) - 2 * v ( i ) + v ( i - 1 )) / dx ** 2 du ( i ) = du ( i ) + real ( gamma ) * d2u - aimag ( gamma ) * d2v dv ( i ) = dv ( i ) + aimag ( gamma ) * d2u + real ( gamma ) * d2v ! Non-parallel term. du ( i ) = du ( i ) + mu ( i ) * u ( i ) dv ( i ) = dv ( i ) + mu ( i ) * v ( i ) end do ! Right most boundary points. cu = - u ( nx - 1 ) / ( 2 * dx ); cv = - v ( nx - 1 ) / ( 2 * dx ) du ( nx ) = - ( real ( nu ) * cu - aimag ( nu ) * cv ) ! Convective term. dv ( nx ) = - ( aimag ( nu ) * cu + real ( nu ) * cv ) ! Convective term. d2u = ( - 2 * u ( nx ) + u ( nx - 1 )) / dx ** 2 ; d2v = ( - 2 * v ( nx ) + v ( nx - 1 )) / dx ** 2 du ( nx ) = du ( nx ) + real ( gamma ) * d2u - aimag ( gamma ) * d2v ! Diffusion term. dv ( nx ) = dv ( nx ) + aimag ( gamma ) * d2u + real ( gamma ) * d2v ! Diffusion term. du ( nx ) = du ( nx ) + mu ( nx ) * u ( nx ) ! Non-parallel term. dv ( nx ) = dv ( nx ) + mu ( nx ) * v ( nx ) ! Non-parallel term. ! Copy results to the output array. f ( 1 : nx ) = du ; f ( nx + 1 : 2 * nx ) = dv end subroutine rhs It can then be embeded into another subroutine having the interface required for the definition of an abstract linear operator (see LightKrylov_AbstractLinops for more details).\nThe definition the state_vector derived-type extended from abstract_vector_cdp is not presented here for the sake of conciseness.\nIt amounts to a simple wrapper around the standard Fortran rank-1 arrays. subroutine direct_solver ( self , vec_in , vec_out ) ! Linear Operator. class ( exponential_prop ), intent ( inout ) :: self ! Input vector. class ( abstract_vector_cdp ), intent ( in ) :: vec_in ! Output vector. class ( abstract_vector_cdp ), intent ( out ) :: vec_out ! Time-integrator. type ( rks54_class ) :: prop real ( kind = dp ) :: dt = 1.0_dp real ( kind = dp ) :: state_ic ( 2 * nx ), state_fc ( 2 * nx ) select type ( vec_in ) type is ( state_vector ) select type ( vec_out ) type is ( state_vector ) ! Get state vector. state_ic (: nx ) = vec_in % state % re state_ic ( nx + 1 :) = vec_in % state % im ! Initialize propagator. call prop % initialize ( n = 2 * nx , f = rhs ) ! Integrate forward in time. call prop % integrate ( 0.0_dp , state_ic , dt , self % tau , state_fc ) ! Pass-back the state vector. vec_out % state % re = state_fc (: nx ) vec_out % state % im = state_fc ( nx + 1 :) end select end select end subroutine direct_solver Provided a similar set of routines have been implemented for the adjoint system, one can then extend the abstract_linop_cdp type to define the exponential propagator as illustrated below. type , extends ( abstract_linop_cdp ), public :: exponential_prop real ( kind = dp ), public :: tau ! Integration time. contains private procedure , pass ( self ), public :: matvec => direct_solver procedure , pass ( self ), public :: rmatvec => adjoint_solver end type exponential_prop This is pretty much everything you need to implement in order to benefit from the iterative eigenvalue and singular value solvers provided by LightKrylov .\nThe Fortran program below uses the derived-types we've just defined and pass them to eigs in order to compute the leading eigenpairs of the linearized Ginzburg-Landau operator. program demo use stdlib_io_npy , only : save_npy use LightKrylov , only : wp => dp use LightKrylov use Ginzburg_Landau implicit none !> Exponential propagator. type ( exponential_prop ), allocatable :: A !> Sampling time. real ( kind = wp ), parameter :: tau = 0.1_wp !> Number of eigenvalues we wish to converge. integer , parameter :: nev = 32 !> Krylov subspace. type ( state_vector ), allocatable :: X (:) !> Eigenvalues. complex ( kind = wp ), allocatable :: lambda (:) !> Residual. real ( kind = wp ), allocatable :: residuals (:) !> Information flag. integer :: info !> Miscellaneous. integer :: i complex ( wp ) :: eigenvectors ( nx , nev ) !> Initialize physical parameters. call initialize_parameters () !> Initialize exponential propagator. A = exponential_prop ( tau ) !> Initialize Krylov subspace. allocate ( X ( nev )); call zero_basis ( X ) !> Call to LightKrylov. call eigs ( A , X , lambda , residuals , info ) !> Transform eigenspectrum from unit-disk to standard complex plane. lambda = log ( lambda ) / tau !> Extract the leading eigenvectors from the Krylov basis into a standard array. do i = 1 , nev eigenvectors (:, i ) = X ( i )% state end do !> Save eigenvalues and eigenvectors to disk. call save_eigenspectrum ( lambda , residuals , \"example/ginzburg_landau/eigenspectrum.npy\" ) call save_npy ( \"example/ginzburg_landau/eigenvectors.npy\" , eigenvectors ) end program demo From the root directory of LightKrylov , you can run this example by typing the following command: fpm run --example Ginzburg-Landau Then python eigenplots.py in the example/ginzburg-landau directory will produce the following figure depicting the eigenspectrum and leading eigenvector of the discretized linearized Ginzburg-Landau operator. Figure: Left panel depicts the eigenspectrum computed with `LightKrylov` and compares against the analytical expressions. The branch splitting observed for very stable eigenvalues result from the discretization of the operator. Right panel depicts the real and imaginary parts of the leading eigenvector. References [1] J.-M. Chomaz, P. Huerre and L. G. Redekopp. Bifurcations to local and global modes in spatially developping flows . Phys. Rev. Lett., 60 (25), 1988. [2] C. Cossu and J.-M. Chomaz. Global measures of local convective instabilities . Phys. Rev. Lett., 78 (4387), 1997. [3] J.-M. Chomaz. Global instabilities in spatially developing flow: non-normality and nonlinearity . Ann. Rev. Fluid Mech., 37 (357-392), 2005. [4] M. Ilak, S. Bagheri, L. Brandt, C. W. Rowley, and D. S. Henningson. Model reduction of the nonlinear complex Ginzburg-Landau equation . SIAM Journal on Applied Dynamical Sysmte, 9 (4), 2010. [5] W. S. Edward, L. S. Tuckerman, R. A. Friesner and D. C. Sorensen. *Krylov methods for the incompressible Navier-Stokes equations . Journal of Computational Physics, 110 (1), 1994. [6] Tuckerman, Laurette S., and Dwight Barkley. Bifurcation analysis for timesteppers. Numerical methods for bifurcation problems and large-scale dynamical systems, 2000. [7] S. Bagheri, E. Akervik, L. Brandt, and D. S. Henningson. Matrix-free methods for stability and control of boundary layers . AIAA Journal, 47 (5), 2009. [8] J.-Ch. Loiseau, J.-Ch. Robinet, S. Cherubini and E. Leriche. Investigation of the roughness-induced transition: global stability analyses and direct numerical similations . Journal of Fluid Mechanics, 2014. [9] R. A. S. Frantz, J.-Ch. Loiseau and J.-Ch. Robinet. Krylov methods for large-scale dynamical systems: applications in fluid dynamics . Applied Mechanics Review, 75 (3), 2023.","tags":"","url":"page/examples/ginzburg-landau.html"},{"title":"Roessler system – LightKrylov","text":"Periodic orbits and their stability on the chaotic Roessler attractor The Roessler system is a system of three non-linear ordinary differential equations given by The three input parameters define the systems regime. The Roessler system is a well-studied example of a continuous-time dynamical system that exhibits many features also found in more complicated systems of practical significance, namely stable and unstable fixed points, periodic orbits as well as chaotic behaviour, i.e. extreme sensitivity to initial conditions [ 1 , 2 ]. For the present example, we choose the standard input parameters for which the system dynamics give rise to the Roessler attractor with a fractal structure due to the chaotic behaviour of the system. To analyse the dynamics, we consider the linearised dynamics of the Roessler system around a point , which are given by To simplify notation, we will write the nonlinear and linear dynamics as and , respectively, where the linear operator (also called Jacobian) encapsulates the above linear dynamics. In the following, we will illustrate the techniques to compute periodic orbits of dynamical system using the iterative Newton-Krylov fixed-point iteration and different methods to analyse their local and global stability, namely the computation of the eigenvalues of the monodromy matrix and Lyapunov exponents as well as the Optimally Time-Dependent mode framework. Newton-Krylov fixed-point iteration - A fixed point of a dynamical system is an equilibrium point that satisfies . Periodic orbits are a second kind of equilibrium point that are characterised by repeating dynamics with a constant period such that , which can also be seen as fixed points of the forward map defined as The Newton-Krylov fixed-point iteration is a Jacobian-free variant of the classical Newton-Raphson root-finding algorithm that, starting from an initial guess for the root of the nonlinear function , iteratively improves the guess using the rule In order to apply the Newton-Raphson method to find periodic orbits, the unknown orbit period is included in the state vector together with a new constraint to have a fully determined system and the system Jacobian is replaced by the Monodromy operator , which is the linearisation of the forward map about a given trajectory and is computed as In practical applications, the Jacobian and Monodromy operators, if they are known explicitly, are never assembled or otherwise are only available via time-stepper functionalities. In order to extend the Newton-Raphson fixed-point iteration to these cases, we move to the Newton-Krylov fixed point iteration that replaces the direct inversion of the system Jacobian with Krylov-based approximations of the action of the linear operators. The system Jacobian that needs to be inverted at each Newton step becomes In most applications in fluid mechanics, the discretisation produce systems of very high dimension so that the Newton-Krylov iteration is the only viable option for the computation of periodic orbits. For details and applications of the Newton-Krylov method, the interested reader is refered to [ 3 , 4 , 5 , 6 ] and the references therein. Numerical setup - In order to analyse the linear and nonlinear dynamics of the Roessler system, we extend the abstract_system_rdp type together with an integrator for both the linear and nonlinear dynamics around a given nonlinear trajectory using a Runge-Kutta class provided by rklib . subroutine combined_rhs ( me , t , x , f ) ! Time-integrator. class ( rk_class ), intent ( inout ) :: me ! Current time. real ( kind = wp ) , intent ( in ) :: t ! State vector. real ( kind = wp ) , dimension (:), intent ( in ) :: x ! Time-derivative. real ( kind = wp ) , dimension (:), intent ( out ) :: f call nonlinear_roessler ( x (: npts ), f (: npts )) ! nonlinear dynamics call linear_roessler ( x ( npts + 1 :), x (: npts ), f ( npts + 1 :)) ! linear dynamics about current point return end subroutine combined_rhs Computation of periodic orbits of the Roessler system - In order to apply the Newton-Krylov formalism to the Roessler system, we define the nonlinear system roessler_upo() sys_jac = roessler_upo () sys_jac % jacobian = jacobian () sys_jac % jacobian % X = bf where jacobian is a linear operator (extended from the abstract_linop_rdp type) for the Newton-Krylov step calling the combined_rhs integrator and bf is the initial guess for the periodic orbit. subroutine linear_map ( self , vec_in , vec_out ) ! Linear Operator. class ( jacobian ), intent ( inout ) :: self ! Input vector. class ( abstract_vector_rdp ), intent ( in ) :: vec_in ! Output vector. class ( abstract_vector_rdp ), intent ( out ) :: vec_out ! Time-integrator. type ( rks54_class ) :: combined_roessler real ( wp ) :: dt = 1.0_wp real ( wp ) :: period real ( wp ), dimension ( 2 * npts ) :: pos_in , pos_out type ( state_vector ) :: vec select type ( vec_in ) type is ( state_vector ) select type ( vec_out ) type is ( state_vector ) ! Get the state. call get_position ( self % X , pos_in (: npts )) call get_period ( self % X , period ) call get_position ( vec_in , pos_in ( npts + 1 :)) ! Initialize integrator. call combined_roessler % initialize ( n = 2 * npts , f = combined_rhs ) ! Evaluate: ! 1. F(X) ! 2. exp(tau*J) @ dx call combined_roessler % integrate ( 0.0_wp , pos_in , dt , period , pos_out ) ! Pass-back the state. call set_position ( pos_out ( npts + 1 :), vec_out ) ! Evaluate [ exp(tau*J) - I ] @ dx. call vec_out % sub ( vec_in ) ! Evaluate f'(X(T), T) * dT and add it to the position residual call compute_fdot ( pos_out (: npts ), vec ) call vec_out % axpby ( vec_in % T , vec , 1.0_wp ) ! Evaluate f'(X(0), 0).T @ dx and add phase condition call compute_fdot ( pos_in (: npts ), vec ) vec_out % T = vec_in % dot ( vec ) class default call stop_error ( \"The intent [OUT] argument 'vec_out' must be of type 'state_vector'\" , this_module , 'linear_map' ) end select class default call stop_error ( \"The intent [IN] argument 'vec_in' must be of type 'state_vector'\" , this_module , 'linear_map' ) end select end subroutine linear_map Figure: Representation of the chaotic Roessler attractor together with the periodic orbit. The fixed point of the forward map is then found with the Newton-Krylov method using the iterative GMRES algorithm to solve the linear system involving the Jacobian. Stability analysis of the periodic orbit via the Optimally Time-Dependent modes - In order to analyse the stability properties of the periodic orbit, we can use the Optimally Time-Dependent (OTD) Framework which is a numerically stable algorithm to compute an orthonormal basis of a linear subspace of the tangent space to a nonlinear trajectory spanning the most unstable directions [ 7 ]. This framework is particularly suited for the analysis of periodic orbits and other time-dependent trajectories since, once the basis is aligned with the most unstable subspace, it optimally follows it as the trajectory evolves. Once this time-dependent orthonormal basis of used-defined rank is computed, the full linearised dynamics can be projected onto the subspace to obtain the reduced operator containing the dominant dynamics. The theory and implementation of the OTD framework is not reported here for the sake of conciseness. The interested reader is refered to [ 7 ] for the original paper presenting the method and [ 8 ] and [ 9 ] for extensions and an application to fluid mechanics, respectively. As the OTD basis converges to and follow the most unstable linear subspace tangent to the trajectory, they are ideally suited for the computation of the Lyapunov exponents, which are often used to characterise the chaotic behaviour of strange attractors. In order to compute the Lyapunov exponents, we integrate the leading eigenvalues of the reduced operator over time [ 8 ]. In this example, we initialise the 2-dimensional OTD basis with random orthonormal vectors and evolve it along the periodic orbit measuring the Lyapunov exponents at each period. As the OTD basis exponentially aligns with the invariant periodic tangent space along the periodic orbit, the approximation of the Lyapunov exponents improves, converging to the reference values from [ 2 ]. Figure: Convergence history of the 2 Lyapunov exponents computed using the OTD basis compared to the reference values [2]. Note that the reference values are known only to 9 digits of precision which is reached after 24 periods. From the reduced operator we can compute the instantaneous eigenvalues of the reduced operator and the symmetrised reduced operator measuring modal and nonmodal growth potential, respectively. Projecting the OTD basis onto the eigenvectors of yields physically meaningful directions in phase space called OTD modes. Figure: The left panel depicts the chaotic Roessler attractor together with the periodic orbit (traversed in anticlockwise direction). At a few points along the orbit, the converged OTD subspace is plotted (grey surfaces) with the OTD modes (blue arrows) and the direction of maximum linear growth in the OTD subspace (red). The right panel shows the evolution over two periods of the growth rate of the eigenvalues and the numerical abscissa of the converged reduced operator along the invariant periodic tangent space. The vertical dashed line corresponds to the empty circle in the left panel for easier orientation. From the root directory of LightKrylov , you can run this example by typing the following command: fpm run --example Roessler Then python plot_roessler.py in the example/roessler directory will produce the plots in this example. References [1] O. E. Roessler. An Equation for Continuous Chaos . Physics Letters, 57A (5), 397–398, 1976. [2] P. Cvitanovic, R. Artuso, R. Mainieri, G. Tanner and G. Vattay. Chaos: Classical and Quantum . Niels Bohr Institute, Copenhagen 2020. [3] J. Sánchez, M. Net, B. Garcıa-Archilla, & C. Simó. Newton–Krylov continuation of periodic orbits for Navier–Stokes flows . Journal of Computational Physics, 201(1), 13-33., 2004. [4] D. Viswanath. Recurrent motions within plane Couette turbulence . Journal of Fluid Mechanics, 580, 339-358, 2007. [5] Y. Duguet, C. C. T. Pringle, R. R. Kerswell, Relative periodic orbits in transitional pipe flow . Physics of Fluids, 20(11), 114102, 2008. [6] R. A. Frantz, J.-C. Loiseau, & J.-C. Robinet. Krylov methods for large-scale dynamical systems: Application in fluid dynamics . Applied Mechanics Reviews, 75(3), 030802, 2008. [7] H. Babaee & T. P. Sapsis. A minimization principle for the description of modes associated with finite-time instabilities . Proc. R. Soc. London, Ser. A 472, 2016. [8] A. Blanchard & T. P. Sapsis. Analytical description of optimally time-dependent modes for reduced-order modeling of transient instabilities . SIAM J. Appl. Dyn. Syst. 18 (2), 1143–1162, 2019. [9] J. S. Kern, M. Beneitez, A. Hanifi & D. S. Henningson. Transient linear stability of pulsating Poiseuille flow using optimally time-dependent modes. J. Fluid Mech. 927, A6., 2021.","tags":"","url":"page/examples/roessler.html"}]}