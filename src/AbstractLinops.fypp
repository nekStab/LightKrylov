#:include "../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module lightkrylov_AbstractLinops
    use lightkrylov_constants
    use lightkrylov_utils
    use lightkrylov_AbstractVectors
    implicit none
    private

    type, abstract, public :: abstract_linop
    contains
    private
        procedure, pass(from), public :: copy
        generic, public :: assignment(=) => copy
    end type abstract_linop





    #:for k1, t1 in RC_KINDS_TYPES
    !------------------------------------------------------------------------------
    !-----     Definition of an abstract ${t1}$ operator with kind=${k1}$     -----
    !------------------------------------------------------------------------------
    type, abstract, extends(abstract_linop), public :: abstract_linop_${t1[0]}$${k1}$
    contains
        private
        procedure(abstract_matvec_${t1[0]}$${k1}$), pass(self), deferred, public :: matvec
        procedure(abstract_matvec_${t1[0]}$${k1}$), pass(self), deferred, public :: rmatvec
    end type

    abstract interface
        subroutine abstract_matvec_${t1[0]}$${k1}$(self, vec_in, vec_out)
            !! Interface for the matrix-vector product.
            use lightkrylov_AbstractVectors
            import abstract_linop_${t1[0]}$${k1}$
            class(abstract_linop_${t1[0]}$${k1}$) , intent(in)  :: self
            !! Linear operator \(\mathbf{A}\).
            class(abstract_vector_${t1[0]}$${k1}$), intent(in)  :: vec_in
            !! Vector to be multiplied by \(\mathbf{A}\).
            class(abstract_vector_${t1[0]}$${k1}$), intent(out) :: vec_out
            !! Result of the matrix-vector product.
        end subroutine abstract_matvec_${t1[0]}$${k1}$
    end interface

    type, extends(abstract_linop_${t1[0]}$${k1}$), public :: adjoint_linop_${t1[0]}$${k1}$
        class(abstract_linop_${t1[0]}$${k1}$), allocatable :: A
    contains
        private
        procedure, pass(self), public :: matvec => adjoint_matvec_${t1[0]}$${k1}$
        procedure, pass(self), public :: rmatvec => adjoint_rmatvec_${t1[0]}$${k1}$
    end type



    #:endfor

    !--------------------------------------------------
    !-----     Definition of the Identity map     -----
    !--------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    type, extends(abstract_linop_${type[0]}$${kind}$), public :: Id_${type[0]}$${kind}$
        contains
        private
        procedure, pass(self), public :: matvec => id_matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => id_matvec_${type[0]}$${kind}$
    end type

    #:endfor

    !----------------------------------------------
    !-----     Definition of scaled linop     -----
    !----------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    type, extends(abstract_linop_${type[0]}$${kind}$), public :: scaled_linop_${type[0]}$${kind}$
        #:if type[0] == "r"
        !! Defines a scaled linear operator \( \mathbf{B} = \sigma \mathbf{A} \) with \( \mathbf{A} \) a real-valued operator and \( \sigma \in \mathbb{R} \).
        class(abstract_linop_${type[0]}$${kind}$), allocatable :: A
        !! Base linear operator to be scaled.
        ${type}$ :: sigma
        !! Scaling factor.
        #:else
        !! Defines a scaled linear operator \( \mathbf{B} = \sigma \mathbf{A} \) with \( \mathbf{A} \) a complex-valued operator and \( \sigma \in \mathbb{C} \).
        class(abstract_linop_${type[0]}$${kind}$), allocatable :: A
        !! Base linear operator to be scaled.
        ${type}$ :: sigma
        !! Scaling factor.
       #:endif
    contains
        private
        procedure, pass(self), public :: matvec => scaled_matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => scaled_rmatvec_${type[0]}$${kind}$
    end type
    #:endfor

    !------------------------------------------------
    !-----     Definition of axpby operator     -----
    !------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    type, extends(abstract_linop_${type[0]}$${kind}$), public :: axpby_linop_${type[0]}$${kind}$
        class(abstract_linop_${type[0]}$${kind}$), allocatable :: A, B
        ${type}$ :: alpha, beta
        logical :: transA = .false., transB = .false.
    contains
        private
        procedure, pass(self), public :: matvec => axpby_matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => axpby_rmatvec_${type[0]}$${kind}$
    end type
    #:endfor

    #:for kind, type in RC_KINDS_TYPES
    #:if type[0] == "r"
    !----------------------------------------------------------------------------------
    !-----     Definition of an abstract symmetric positive definite operator     -----
    !----------------------------------------------------------------------------------
    type, abstract, extends(abstract_linop_${type[0]}$${kind}$), public :: abstract_spd_linop_${type[0]}$${kind}$
    contains
    end type
    #:else
    !----------------------------------------------------------------------------------
    !-----     Definition of an abstract Hermitian positive definite operator     -----
    !----------------------------------------------------------------------------------
    type, abstract, extends(abstract_linop_${type[0]}$${kind}$), public :: abstract_hermitian_linop_${type[0]}$${kind}$
    contains
    end type
 
   #:endif



    #:endfor
contains

    subroutine copy(out, from)
        class(abstract_linop), intent(in) :: from
        class(abstract_linop), allocatable, intent(out) :: out
        if (allocated(out)) deallocate(out)
        allocate(out, source=from)
        return
    end subroutine copy

    #:for kind, type in RC_KINDS_TYPES
    subroutine id_matvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(Id_${type[0]}$${kind}$), intent(in) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec_in
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: vec_out
        call vec_out%axpby(zero_${type[0]}$${kind}$, vec_in, one_${type[0]}$${kind}$)
        return
    end subroutine id_matvec_${type[0]}$${kind}$
    #:endfor

    #:for kind, type in RC_KINDS_TYPES
    subroutine scaled_matvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(scaled_linop_${type[0]}$${kind}$), intent(in) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec_in
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: vec_out

        call self%A%matvec(vec_in, vec_out) ; call vec_out%scal(self%sigma)
        return
    end subroutine scaled_matvec_${type[0]}$${kind}$

    subroutine scaled_rmatvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(scaled_linop_${type[0]}$${kind}$), intent(in) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec_in
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: vec_out

        call self%A%rmatvec(vec_in, vec_out) ; call vec_out%scal(self%sigma)
        return
    end subroutine scaled_rmatvec_${type[0]}$${kind}$
    #:endfor

    #:for kind, type in RC_KINDS_TYPES
    subroutine axpby_matvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(axpby_linop_${type[0]}$${kind}$), intent(in) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec_in
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: vec_out

        ! Working array.
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: wrk

        ! Allocate working array.
        allocate(wrk, source=vec_in) ; call wrk%zero()

        ! w = A @ x
        if (self%transA) then
            call self%A%rmatvec(vec_in, wrk)
        else
            call self%A%matvec(vec_in, wrk)
        endif

        ! y = B @ x
        if (self%transB) then
            call self%B%rmatvec(vec_in, vec_out)
        else
            call self%B%matvec(vec_in, vec_out)
        endif

        ! y = alpha*w + beta*y
        call vec_out%axpby(self%beta, wrk, self%alpha)

        return
    end subroutine axpby_matvec_${type[0]}$${kind}$

    subroutine axpby_rmatvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(axpby_linop_${type[0]}$${kind}$), intent(in) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec_in
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: vec_out

        ! Working array.
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: wrk

        ! Allocate working array.
        allocate(wrk, source=vec_in) ; call wrk%zero()

        ! w = A @ x
        if (self%transA) then
            call self%A%matvec(vec_in, wrk)
        else
            call self%A%rmatvec(vec_in, wrk)
        endif

        ! y = B @ x
        if (self%transB) then
            call self%B%matvec(vec_in, vec_out)
        else
            call self%B%rmatvec(vec_in, vec_out)
        endif

        ! y = alpha*w + beta*y
        call vec_out%axpby(self%beta, wrk, self%alpha)

        return
    end subroutine axpby_rmatvec_${type[0]}$${kind}$

    #:endfor

    #:for kind, type in RC_KINDS_TYPES
    subroutine adjoint_matvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(adjoint_linop_${type[0]}$${kind}$), intent(in) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec_in
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: vec_out

        call self%A%rmatvec(vec_in, vec_out)

        return
    end subroutine adjoint_matvec_${type[0]}$${kind}$

    subroutine adjoint_rmatvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(adjoint_linop_${type[0]}$${kind}$), intent(in) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec_in
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: vec_out

        call self%A%matvec(vec_in, vec_out)

        return
    end subroutine adjoint_rmatvec_${type[0]}$${kind}$

    #:endfor

end module lightkrylov_AbstractLinops
