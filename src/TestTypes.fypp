#:include "../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module LightKrylov_TestTypes
    ! Frortran Standard Library
    use stdlib_stats_distribution_normal, only: normal => rvs_normal
    use stdlib_optval, only: optval
    ! LightKrylov
    use LightKrylov
    use LightKrylov_Logger
    
    implicit none
    
    private

    character(len=128), parameter, private :: this_module = 'LightKrylov_TestTypes'

    integer, parameter, public :: test_size = 128

    !-----------------------------------------------
    !-----     TEST VECTOR TYPE DEFINITION     -----
    !-----------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    type, extends(abstract_vector_${type[0]}$${kind}$), public :: vector_${type[0]}$${kind}$
        ${type}$, dimension(test_size) :: data = 0.0_${kind}$
    contains
        private
        procedure, pass(self), public :: zero => zero_${type[0]}$${kind}$
        procedure, pass(self), public :: dot => dot_${type[0]}$${kind}$
        procedure, pass(self), public :: scal => scal_${type[0]}$${kind}$
        procedure, pass(self), public :: axpby => axpby_${type[0]}$${kind}$
        procedure, pass(self), public :: rand => rand_${type[0]}$${kind}$
        procedure, pass(self), public :: get_size => get_size_${type[0]}$${kind}$
    end type vector_${type[0]}$${kind}$

    #:endfor

    !----------------------------------------------
    !-----     TEST LINOP TYPE DEFINITION     -----
    !----------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    #:if type[0] == "r"
    type, extends(abstract_linop_${type[0]}$${kind}$), public :: linop_${type[0]}$${kind}$
        ${type}$, dimension(test_size, test_size) :: data = 0.0_${kind}$
    contains
        private
        procedure, pass(self), public :: matvec  => matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => rmatvec_${type[0]}$${kind}$
    end type

    type, extends(abstract_sym_linop_${type[0]}$${kind}$), public :: spd_linop_${type[0]}$${kind}$
        ${type}$, dimension(test_size, test_size) :: data = 0.0_${kind}$
    contains
        private
        procedure, pass(self), public :: matvec => sdp_matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => sdp_matvec_${type[0]}$${kind}$
    end type
    #:else
    type, extends(abstract_linop_${type[0]}$${kind}$), public :: linop_${type[0]}$${kind}$
        ${type}$, dimension(test_size, test_size) :: data = cmplx(0.0_${kind}$, 0.0_${kind}$, kind=${kind}$)
    contains
        private
        procedure, pass(self), public :: matvec  => matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => rmatvec_${type[0]}$${kind}$
    end type

    type, extends(abstract_hermitian_linop_${type[0]}$${kind}$), public :: hermitian_linop_${type[0]}$${kind}$
        ${type}$, dimension(test_size, test_size) :: data = cmplx(0.0_${kind}$, 0.0_${kind}$, kind=${kind}$)
    contains
        private
        procedure, pass(self), public :: matvec => hermitian_matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => hermitian_matvec_${type[0]}$${kind}$
    end type
    #:endif

    #:endfor
contains
    
    !----------------------------------------------------------
    !-----     TYPE-BOUND PROCEDURES FOR TEST VECTORS     -----
    !----------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine zero_${type[0]}$${kind}$(self)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        self%data = 0.0_${kind}$
        return
    end subroutine zero_${type[0]}$${kind}$

    function dot_${type[0]}$${kind}$(self, vec) result(alpha)
        class(vector_${type[0]}$${kind}$), intent(in) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec
        ${type}$ :: alpha

        select type(vec)
        type is(vector_${type[0]}$${kind}$)
            alpha = dot_product(self%data, vec%data)
        end select
    end function dot_${type[0]}$${kind}$

    integer function get_size_${type[0]}$${kind}$(self) result(N)
        class(vector_${type[0]}$${kind}$), intent(in) :: self
        N = test_size
        return
    end function get_size_${type[0]}$${kind}$

    subroutine scal_${type[0]}$${kind}$(self, alpha)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        ${type}$, intent(in) :: alpha
        self%data = alpha * self%data
        return
    end subroutine scal_${type[0]}$${kind}$

    subroutine axpby_${type[0]}$${kind}$(self, alpha, vec, beta)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec
        ${type}$, intent(in) :: alpha, beta

        select type(vec)
        type is(vector_${type[0]}$${kind}$)
            self%data = alpha*self%data + beta*vec%data
        end select
        return
    end subroutine

    subroutine rand_${type[0]}$${kind}$(self, ifnorm)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        logical, optional, intent(in) :: ifnorm
        logical :: normalized
        ${type}$ :: mu(test_size), var(test_size)
        ${type}$ :: alpha
 
        mu = 0.0_${kind}$
        #:if type[0] == "r"
        var = 1.0_${kind}$
        #:else
        var = cmplx(1.0_${kind}$, 1.0_${kind}$, kind=${kind}$)
        #:endif
        self%data = normal(mu, var)
 
        normalized = optval(ifnorm, .false.)
        if (normalized) then
            alpha = self%norm()
            call self%scal(1.0_${kind}$/alpha)
        endif
    end subroutine rand_${type[0]}$${kind}$

    #:endfor

    !---------------------------------------------------------
    !-----     TYPE-BOUND PROCEDURES FOR TEST LINOPS     -----
    !---------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine matvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(linop_${type[0]}$${kind}$), intent(in)  :: self
        class(abstract_vector_${type[0]}$${kind}$)       , intent(in)  :: vec_in
        class(abstract_vector_${type[0]}$${kind}$)       , intent(out) :: vec_out

        select type(vec_in)
        type is(vector_${type[0]}$${kind}$)
            select type(vec_out)
            type is(vector_${type[0]}$${kind}$)

            vec_out%data = matmul(self%data, vec_in%data)

            end select
        end select

        return
    end subroutine matvec_${type[0]}$${kind}$

    subroutine rmatvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(linop_${type[0]}$${kind}$), intent(in)  :: self
        class(abstract_vector_${type[0]}$${kind}$)       , intent(in)  :: vec_in
        class(abstract_vector_${type[0]}$${kind}$)       , intent(out) :: vec_out

        select type(vec_in)
        type is(vector_${type[0]}$${kind}$)
            select type(vec_out)
            type is(vector_${type[0]}$${kind}$)

            #:if type[0] == "c"
            vec_out%data = matmul(transpose(conjg(self%data)), vec_in%data)
            #:else
            vec_out%data = matmul(transpose(self%data), vec_in%data)
            #:endif

            end select
        end select

        return
    end subroutine rmatvec_${type[0]}$${kind}$

    #:if type[0] == "r"
    subroutine sdp_matvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(spd_linop_${type[0]}$${kind}$), intent(in)  :: self
        class(abstract_vector_${type[0]}$${kind}$)       , intent(in)  :: vec_in
        class(abstract_vector_${type[0]}$${kind}$)       , intent(out) :: vec_out

        select type(vec_in)
        type is(vector_${type[0]}$${kind}$)
            select type(vec_out)
            type is(vector_${type[0]}$${kind}$)

            vec_out%data = matmul(self%data, vec_in%data)

            end select
        end select

        return
    end subroutine sdp_matvec_${type[0]}$${kind}$
    #:else
    subroutine hermitian_matvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(hermitian_linop_${type[0]}$${kind}$), intent(in)  :: self
        class(abstract_vector_${type[0]}$${kind}$)       , intent(in)  :: vec_in
        class(abstract_vector_${type[0]}$${kind}$)       , intent(out) :: vec_out

        select type(vec_in)
        type is(vector_${type[0]}$${kind}$)
            select type(vec_out)
            type is(vector_${type[0]}$${kind}$)

            vec_out%data = matmul(self%data, vec_in%data)

            end select
        end select

        return
    end subroutine hermitian_matvec_${type[0]}$${kind}$
   #:endif

    #:endfor
    
end module LightKrylov_TestTypes
