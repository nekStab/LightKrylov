#:include "../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module lightkrylov_IterativeSolvers
    !!  This module provides some of the most important computational routines provided by
    !!  `LightKrylov`. These include:
    !!
    !!  - `eigs` : Compute the leading eigenpairs of a square linear operator \( A \).
    !!  - `eighs` : Compute the leading eigenpairs of a symmetric positive definite 
    !!              operator \( A \).
    !!  - `svds` : Compute the leading singular triplets of a linear operator \( A \).
    !!  - `gmres` : Solve the linear system \( Ax = b \) using the *generalized minimum
    !!              residual method*.
    !!  - `cg` : Solve the linear system \( Ax = b \) where \( A \) is symmetric
    !!           positive definite using the *Conjugate Gradient* method.
    !!
    !!  It also provides abstract interfaces to pass user-defined solvers and preconditioners
    !!  to `LightKrylov`. Note that these features are still experimental however.

    !--------------------------------------------
    !-----     Fortran Standard Library     -----
    !--------------------------------------------
    use iso_fortran_env, only: output_unit
    
    use stdlib_sorting, only: sort_index
    use stdlib_optval, only: optval
    use stdlib_io_npy, only: save_npy
    use stdlib_linalg, only: lstsq, svd, eigh
    use stdlib_stats, only: median

    !-------------------------------
    !-----     LightKrylov     -----
    !-------------------------------
    use LightKrylov_Constants
    Use LightKrylov_Logger
    use LightKrylov_Utils
    use LightKrylov_AbstractVectors
    use LightKrylov_AbstractLinops
    use LightKrylov_BaseKrylov

    implicit none
    private

    character(len=*), parameter :: this_module      = 'LK_Solvers'
    character(len=*), parameter :: this_module_long = 'LightKrylov_IterativeSolvers'

    #:for kind, type in RC_KINDS_TYPES
    public :: abstract_linear_solver_${type[0]}$${kind}$
    #:endfor
    public :: save_eigenspectrum
    public :: eigs
    public :: eighs
    public :: svds
    public :: gmres
    #:for kind, type in RC_KINDS_TYPES
    public :: gmres_${type[0]}$${kind}$
    #:endfor
    public :: cg
    #:for kind, type in RC_KINDS_TYPES
    public :: cg_${type[0]}$${kind}$
    #:endfor

    interface save_eigenspectrum
        !!  ### Description
        !!
        !!  Utility function to save the eigenspectrum computed from the Arnoldi factorization.
        !!  It outpost a .npy file.
        !!
        !!  ### Syntax
        !!
        !!  ```fortran
        !!      call save_eigenspectrum(eigvals, residuals, fname)
        !!  ```
        !!
        !!  ### Arguments
        !!
        !!  `eigvals` : `complex` rank-1 array containing the eigenvalues.
        !!
        !!  `residuals` : `real` rank-1 array containing the residuals associated to each
        !!                eigenvalues.
        !!
        !!  `fname` : Name of the file to save the eigenspectrum.
        #:for kind in REAL_KINDS
        module procedure save_eigenspectrum_${kind}$
        #:endfor
    end interface

    interface eighs
        !!  ### Description
        !!
        !!  Computes the leading eigenpairs of a symmetric operator \(A\)
        !!  using the Lanczos iterative process. Given a square linear operator \(A\), it finds
        !!  the leading eigvalues and eigvectors such that:
        !!
        !!  \[
        !!      Ax = \lambda x
        !!  \]
        !!
        !!  The subspace \(X\) is constructed via Lanczos factorization, resulting in a symmetric
        !!  tridiagonal matrix \(T\). The eigenvalues of \(A\) are approximated by those of \(T\)
        !!  and the eigenvectors are computed accordingly.
        !!
        !!  **References**
        !!
        !!  - Lanczos, C. (1950). "An Iteration Method for the Solution of the Eigenvalue Problem
        !!  of Linear Differential and Integral Operators". United States Governm. Press Office.
        !!
        !!  ### Syntax
        !!
        !!  ```fortran
        !!      call eighs(A, X, eigvals, residuals, info [, kdim] [,tolerance])
        !!  ```
        !!
        !!  ### Arguments
        !!
        !!  `A` : Linear operator derived from `abstract_sym_linop_rsp`, `abstract_sym_linop_rdp`,
        !!        `abstract_hermitian_linop_csp` or `abstract_hermitian_linop_cdp` whose leading
        !!        eigenpairs need to be computed. It is an `intent(in)` argument.
        !!
        !!  `X` : Array of `abstract_vectors` with the same type and kind as `A`. On exit, it
        !!        contains the leading eigenvectors of `A`. Note that the dimension of `X` fixes
        !!        the number of eigenpairs computed.
        !!
        !!  `eigvals` : Rank-1 array of `real` numbers. On exit, it contains the leading
        !!              eigenvalues of `A`. It is an `intent(out)` argument.
        !!
        !!  `residuals` : Rank-1 array of `real` numbers. On exit, it contains the residuals
        !!                associated with each eigenpairs. It is an `intent(out)` argument.
        !!
        !!  `info` : `integer` Information flag.
        !!
        !!  `kdim` (*optional*) : `integer`, maximum dimension of the Krylov subspace used to
        !!                        approximate the leading eigenpairs. It is an `intent(in)`
        !!                        argument. By default, `kdim = 4*size(X)`.
        !!
        !!  `tolerance` (*optional*) : `real` tolerance below which an eigenpair is considered as
        !!                             being converged. It is an `intent(in)` agument. By default,
        !!                             `tolerance = rtol_sp` or `tolerance = rtol_dp`.
        #:for kind, type in RC_KINDS_TYPES
        module procedure eighs_${type[0]}$${kind}$
        #:endfor
    end interface

    interface eigs
        !!  ### Description
        !!
        !!  Computes the leading eigenpairs of a square linear operator \(A\)
        !!  using the Arnoldi iterative process. Given a square linear operator \(A\), it finds
        !!  the leading eigvalues and eigvectorss such that:
        !!
        !!  \[
        !!      Ax = \lambda x
        !!  \]
        !!
        !!  or
        !!
        !!  \[
        !!      A^H x = \lambda x.
        !!  \]
        !!
        !!  The subspace \(X\) is constructed via Arnoldi factorization, resulting in an upper
        !!  Hessenberg matrix \(H\). The eigenvalues of \(A\) are approximated by those of \(H\)
        !!  and the eigenvectors are computed accordingly.
        !!
        !!  **References**
        !!
        !!  - Arnoldi, W. E. (1951). "The Principle of Minimized Iterations in the Solution of
        !!    the Matrix Eigenvalue Problem." Quarterly of Applied Mathematics, 9(1), 17–29.
        !!
        !!  ### Syntax
        !!
        !!  ```fortran
        !!      call eigs(A, X, eigvals, residuals, info [, kdim] [, select] [,tolerance] [, transpose])
        !!  ```
        !!
        !!  ### Arguments
        !!
        !!  `A` : Linear operator derived from `abstract_sym_linop_rsp`, `abstract_sym_linop_rdp`,
        !!        `abstract_hermitian_linop_csp` or `abstract_hermitian_linop_cdp` whose leading
        !!        eigenpairs need to be computed. It is an `intent(in)` argument.
        !!
        !!  `X` : Array of `abstract_vectors` with the same type and kind as `A`. On exit, it
        !!        contains the leading eigenvectors of `A`. Note that the dimension of `X` fixes
        !!        the number of eigenpairs computed.
        !!
        !!  `eigvals` : Rank-1 array of `real` numbers. On exit, it contains the leading
        !!              eigenvalues of `A`. It is an `intent(out)` argument.
        !!
        !!  `residuals` : Rank-1 array of `real` numbers. On exit, it contains the residuals
        !!                associated with each eigenpairs. It is an `intent(out)` argument.
        !!
        !!  `info` : `integer` Information flag.
        !!
        !!  `kdim` (*optional*) : `integer`, maximum dimension of the Krylov subspace used to
        !!                        approximate the leading eigenpairs. It is an `intent(in)`
        !!                        argument. By default, `kdim = 4*size(X)`.
        !!
        !!  `select` (*optional*) : Function to select which eigenvalues to compute.
        !!
        !!  `tolerance` (*optional*) : `real` tolerance below which an eigenpair is considered as
        !!                             being converged. It is an `intent(in)` agument. By default,
        !!                             `tolerance = rtol_sp` or `tolerance = rtol_dp`.
        !!
        !!  `transpose` (*optional*) : `logical` flag determining whether the eigenvalues of \(A\)
        !!                             or \(A^H\) need to be computed.
        #:for kind, type in RC_KINDS_TYPES
        module procedure eigs_${type[0]}$${kind}$
        #:endfor
    end interface

    interface svds
        !!  ### Description
        !!
        !!  Computes the leading singular triplets of an arbitrary linear operator \(A\)
        !!  using the Lanczos iterative process. Given a linear operator \(A\), it finds
        !!  the leading singular values and singular vectors such that:
        !!
        !!  \[
        !!      \begin{aligned}
        !!      Av & = \sigma u \\
        !!      A^H u & = \sigma v.
        !!      \end{aligned}
        !!  \]
        !!
        !!  The subspaces \(U\) and \(V\) are constructed via Lanczos factorization, resulting in
        !!  a bidiagonal matrix \(B\). The singular values of \(A\) are approximated by those of
        !!  \(B\) and the singular vectors are computed accordingly.
        !!
        !!  **References**
        !!
        !!  - Golub, G. H., & Kahan, W. (1965). "Calculating the Singular Values and
        !!   Pseudo-Inverse of a Matrix."
        !!  - Baglama, J., & Reichel, L. (2005). "Augmented implicitly restarted Lanczos
        !!   bidiagonalization methods."
        !!  - R. M. Larsen. "Lanczos bidiagonalization with partial reorthogonalization."
        !!   Technical Report, 1998.
        !!
        !!  ### Syntax
        !!
        !!  ```fortran
        !!      call svds(A, U, S, V, residuals, info [, kdim] [,tolerance])
        !!  ```
        !!
        !!  ### Arguments
        !!
        !!  `A` : Linear operator derived from `abstract_sym_linop_rsp`, `abstract_sym_linop_rdp`,
        !!        `abstract_hermitian_linop_csp` or `abstract_hermitian_linop_cdp` whose leading
        !!        eigenpairs need to be computed. It is an `intent(in)` argument.
        !!
        !!  `U` : Array of `abstract_vectors` with the same type and kind as `A`. On exit, it
        !!        contains the left singular vectors of `A`. Note that the dimension of `U` fixes
        !!        the number of eigenpairs computed.
        !!
        !!  `S` : Rank-1 array of `real` numbers. On exit, it contains the leading
        !!        singular values of `A`. It is an `intent(out)` argument.
        !!
        !!  `V` : Array of `abstract_vectors` with the same type and kind as `A`. On exit, it
        !!        contains the left singular vectors of `A`. Note that the dimension of `U` fixes
        !!        the number of eigenpairs computed.
        !!
        !!  `residuals` : Rank-1 array of `real` numbers. On exit, it contains the residuals
        !!                associated with each singular triplet. It is an `intent(out)` argument.
        !!
        !!  `info` : `integer` Information flag.
        !!
        !!  `kdim` (*optional*) : `integer`, maximum dimension of the Krylov subspace used to
        !!                        approximate the leading singular triplets. It is an `intent(in)`
        !!                        argument. By default, `kdim = 4*size(X)`.
        !!
        !!  `tolerance` (*optional*) : `real` tolerance below which a triplet is considered as
        !!                             being converged. It is an `intent(in)` agument. By default,
        !!                             `tolerance = rtol_sp` or `tolerance = rtol_dp`.
        #:for kind, type in RC_KINDS_TYPES
        module procedure svds_${type[0]}$${kind}$
        #:endfor
    end interface

    interface gmres
        !!  ### Description
        !!
        !!  Solve a square linear system of equations
        !!
        !!  \[
        !!      Ax = b
        !!  \]
        !!
        !!  using the *Generalized Minimum RESidual* (GMRES) method.
        !!
        !!  **References**
        !!
        !!  - Saad Y. and Schultz M. H. "GMRES: A generalized minimal residual algorithm for
        !!  solving nonsymmetric linear systems." SIAM Journal on Scientific and Statistical
        !!  Computing, 7(3), 1986.
        !!
        !!  ### Syntax
        !!
        !!  ```fortran
        !!      call gmres(A, b, x, info [, rtol] [, atol] [, preconditioner] [, options] [, transpose])
        !!  ```
        !!
        !!  ### Arguments
        !!
        !!  `A` : Linear operator derived from one of the `abstract_linop` provided by the
        !!  `AbstractLinops` module. It is an `intent(in)` argument.
        !!
        !!  `b` : Right-hand side vector derived from one the `abstract_vector` types provided
        !!  by the `AbstractVectors` module. It needs to have the same type and kind as `A`.
        !!  It is an `intent(in)` argument.
        !!
        !!  `x` : On entry, initial guess for the solution. On exit, the solution computed by
        !!  gmres. It is a vector derived from one the `abstract_vector` types provided by the
        !!  `AbstractVectors` module. It needs to have the same type and kind as `A`. It is
        !!  an `intent(inout)` argument.
        !!
        !!  `info` : `integer` information flag.
        !!
        !!  `rtol` (optional) : `real` relative tolerance for the solver.
        !!
        !!  `atol` (optional) : `real` absolute tolerance for the solver.
        !!
        !!  `preconditioner` (optional) : Right preconditioner used to solve the system. It needs
        !!  to be consistent with the `abstract_preconditioner` interface. It is an `intent(in)`
        !!  argument.
        !!
        !!  `options` (optional) : Container for the gmres options given by the `gmres_opts` type.
        !!  It is an `intent(in)` argument.
        !!
        !!  `transpose` (optional) : `logical` flag controlling whether \( Ax = b\) or
        !!  \( A^H x = b \) is being solver.
        #:for kind, type in RC_KINDS_TYPES
        module procedure gmres_${type[0]}$${kind}$
        #:endfor
    end interface

    interface cg
        !!  ### Description
        !!
        !!  Given a symmetric (positive definite) matrix \( A \), solves the linear system
        !!
        !!  \[
        !!      Ax = b
        !!  \]
        !!
        !!  using the *Conjugate Gradient* method.
        !!
        !!  **References**
        !!
        !!  - Hestenes, M. R., and Stiefel, E. (1952). "Methods of Conjugate Gradients for Solving
        !!  Linear Systems," Journal of Research of the National Bureau of Standards,
        !!  49(6), 409–436.
        !!
        !!  ### Syntax
        !!
        !!  ```fortran
        !!      call cg(A, b, x, info [, rtol] [, atol] [, preconditioner] [, options])
        !!  ```
        !!
        !!  ### Arguments
        !!
        !!  `A` : Linear operator derived from one of the `abstract_sym_linop` or
        !!  `abstract_hermitian_linop` types provided by the `AbstractLinops` module. It is an
        !!  `intent(in)` argument.
        !!
        !!  `b` : Right-hand side vector derived from one the `abstract_vector` types provided
        !!  by the `AbstractVectors` module. It needs to have the same type and kind as `A`.
        !!  It is an `intent(in)` argument.
        !!
        !!  `x` : On entry, initial guess for the solution. On exit, the solution computed by
        !!  cg. It is a vector derived from one the `abstract_vector` types provided by the
        !!  `AbstractVectors` module. It needs to have the same type and kind as `A`. It is
        !!  an `intent(inout)` argument.
        !!
        !!  `info` : `integer` information flag.
        !!
        !!  `rtol` (optional) : `real` relative tolerance for the solver.
        !!
        !!  `atol` (optional) : `real` absolute tolerance for the solver.
        !!
        !!  `preconditioner` (optional) : Right preconditioner used to solve the system. It needs
        !!  to be consistent with the `abstract_preconditioner` interface. It is an `intent(in)`
        !!  argument.
        !!
        !!  `options` (optional) : Container for the gmres options given by the `cg_opts` type.
        !!  It is an `intent(in)` argument.
        !!
        !!  @note
        !!  Although the interface to pass a preconditioner is exposed, it is not currently
        !!  implemented.
        !!  @endnote
        #:for kind, type in RC_KINDS_TYPES
        module procedure cg_${type[0]}$${kind}$
        #:endfor
    end interface

    !------------------------------------------------------
    !-----     ABSTRACT PRECONDITIONER DEFINITION     -----
    !------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    type, abstract, public :: abstract_precond_${type[0]}$${kind}$
    contains
        private
        procedure(abstract_apply_${type[0]}$${kind}$), pass(self), public, deferred :: apply
    end type

    abstract interface
        subroutine abstract_apply_${type[0]}$${kind}$(self, vec)
            !! Abstract interface to apply a preconditioner in `LightKrylov`.
            import abstract_precond_${type[0]}$${kind}$, abstract_vector_${type[0]}$${kind}$
            class(abstract_precond_${type[0]}$${kind}$), intent(in) :: self
            !! Preconditioner.
            class(abstract_vector_${type[0]}$${kind}$), intent(inout) :: vec
            !! Input/Output vector.
        end subroutine abstract_apply_${type[0]}$${kind}$
    end interface
    
    #:endfor

    !--------------------------------------------------------
    !-----                                              -----
    !-----     GENERIC INTERFACE FOR LINEAR SOLVERS     -----
    !-----                                              -----
    !--------------------------------------------------------

    abstract interface
    #:for kind, type in RC_KINDS_TYPES
        subroutine abstract_linear_solver_${type[0]}$${kind}$(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta)
            !! Abstract interface to use a user-defined linear solver in `LightKrylov`.
            import abstract_linop_${type[0]}$${kind}$, abstract_vector_${type[0]}$${kind}$, abstract_opts, abstract_metadata, abstract_precond_${type[0]}$${kind}$, ${kind}$
            class(abstract_linop_${type[0]}$${kind}$), intent(in) :: A
            !! Linear operator to invert.
            class(abstract_vector_${type[0]}$${kind}$), intent(in) :: b
            !! Right-hand side vector.
            class(abstract_vector_${type[0]}$${kind}$), intent(inout) :: x
            !! Solution vector.
            integer, intent(out) :: info
            !! Information flag. In case of successful exit, the flag should return the number of iterations required for convergence.
            real(${kind}$), optional, intent(in) :: rtol
            !! Relative solver tolerance
            real(${kind}$), optional, intent(in) :: atol
            !! Absolute solver tolerance
            class(abstract_precond_${type[0]}$${kind}$), optional, intent(in) :: preconditioner
            !! Preconditioner.
            class(abstract_opts), optional, intent(in) :: options
            !! Options passed to the linear solver.
            logical, optional, intent(in) :: transpose
            !! Determine whether \(\mathbf{A}\) (`.false.`) or \(\mathbf{A}^T\) (`.true.`) is being used.
            class(abstract_metadata), optional, intent(out) :: meta
            !! Metadata.
        end subroutine abstract_linear_solver_${type[0]}$${kind}$

    #:endfor
    end interface

contains

    !-------------------------------------
    !-----     UTILITY FUNCTIONS     -----
    !-------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    elemental pure function compute_residual_${type[0]}$${kind}$(beta, x) result(residual)
        !! Computes the residual associated with a Ritz eigenpair.
        ${type}$, intent(in) :: beta
        !! Norm of the residual Krylov vector.
        ${type}$, intent(in) :: x
        !! Last entry of the low-dimensional Ritz eigenvector.
        real(${kind}$) :: residual
        !! Residual associated to the corresponding Ritz eigenpair.
        residual = abs(beta*x)
        return
    end function compute_residual_${type[0]}$${kind}$

    #:endfor

    #:for kind in REAL_KINDS
    subroutine save_eigenspectrum_${kind}$(eigvals, residuals, fname)
        !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format.
        complex(${kind}$), intent(in) :: eigvals(:)
        !! Eigenalues.
        real(${kind}$), intent(in) :: residuals(:)
        !! Residual of the corresponding Ritz eigenpairs.
        character(len=*), intent(in) :: fname
        !! Name of the output file.

        ! Internal variables.
        real(${kind}$) :: data(size(eigvals), 3)

        ! Store data.
        data(:, 1) = eigvals%re ; data(:, 2) = eigvals%im ; data(:, 3) = residuals
        ! Save the eigenspectrum to disk.
        call save_npy(fname, data)

        return
    end subroutine save_eigenspectrum_${kind}$

    function median_eigvals_selector_${kind}$(lambda) result(selected)
        complex(${kind}$), intent(in) :: lambda(:)
        logical :: selected(size(lambda))
        selected = abs(lambda) > median(abs(lambda))
        return
    end function median_eigvals_selector_${kind}$

    #:endfor

    !---------------------------------------------------
    !-----     GENERAL EIGENVALUE COMPUTATIONS     -----
    !---------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine eigs_${type[0]}$${kind}$(A, X, eigvals, residuals, info, kdim, select, tolerance, transpose)
        class(abstract_linop_${type[0]}$${kind}$), intent(in) :: A
        !! Linear operator whose leading eigenpairs need to be computed.
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: X(:)
        !! Leading eigenvectors of \(\mathbf{A}\).
        complex(${kind}$), allocatable, intent(out) :: eigvals(:)
        !! Leading eigenvalues of \(\mathbf{A}\).
        real(${kind}$), allocatable, intent(out) :: residuals(:)
        !! Residuals associated to each Ritz eigenpair.
        integer, intent(out) :: info
        !! Information flag.
        integer, optional, intent(in) :: kdim
        procedure(eigvals_select_${kind}$), optional :: select
        !! Desired number of eigenpairs.
        real(${kind}$), optional, intent(in) :: tolerance
        !! Tolerance.
        logical, optional, intent(in) :: transpose
        !! Determine whether \(\mathbf{A}\) or \(\mathbf{A}^H\) is being used.

        !--------------------------------------
        !-----     Internal variables     -----
        !--------------------------------------

        ! Krylov subspace and Krylov subspace dimension.
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: Xwrk(:)
        integer :: kdim_, kstart
        ! Hessenberg matrix.
        ${type}$, allocatable :: H(:, :)
        ! Working arrays for the eigenvectors and eigenvalues.
        #:if type[0] == "c"
        ${type}$, allocatable :: eigvecs_wrk(:, :)
        #:else
        real(${kind}$), allocatable :: eigvecs_wrk(:, :)
        #:endif
        complex(${kind}$), allocatable :: eigvals_wrk(:)
        real(${kind}$), allocatable :: residuals_wrk(:)
        ! Miscellaneous.
        integer :: nev, conv
        integer :: i, j, k, niter, krst
        real(${kind}$) :: tol
        ${type}$ :: beta
        #:if type[0] == "r"
        ${type}$ :: alpha
        #:endif
        character(len=256) :: msg
        ! Eigenvalue selection.
        procedure(eigvals_select_${kind}$), pointer :: select_

        ! Deals with optional parameters.
        nev = size(X)
        kdim_   = optval(kdim, 4*nev)
        tol     = optval(tolerance, rtol_${kind}$)

        if (present(select)) then
            select_ => select
        else
            select_ => median_eigvals_selector_${kind}$
        endif

        ! Allocate eigenvalues.
        allocate(eigvals(nev)) ; eigvals = 0.0_${kind}$

        ! Allocate working variables.
        allocate(Xwrk(kdim_+1), source=X(1)) ; call zero_basis(Xwrk) ; call Xwrk(1)%rand(.true.)
        allocate(H(kdim_+1, kdim_)) ; H = 0.0_${kind}$
        allocate(eigvecs_wrk(kdim_, kdim_)) ; eigvecs_wrk = 0.0_${kind}$
        allocate(eigvals_wrk(kdim_)) ; eigvals_wrk = 0.0_${kind}$
        allocate(residuals_wrk(kdim_)) ; residuals_wrk = 0.0_${kind}$

        ! Ritz eigenpairs computation.
        H = 0.0_${kind}$

        kstart = 1 ; conv = 0 ; niter = 0 ; krst = 1
        krylovschur: do while (conv < nev)

           arnoldi_factorization: do k = kstart, kdim_
                ! Arnoldi step.
                call arnoldi(A, Xwrk, H, info, kstart=k, kend=k, transpose=transpose)
                call check_info(info, 'arnoldi', module=this_module, procedure='eigs_${type[0]}$${kind}$')

                ! Spectral decomposition of the k x k Hessenberg matrix.
                eigvals_wrk = 0.0_${kind}$ ; eigvecs_wrk = 0.0_${kind}$
                call eig(H(:k, :k), eigvecs_wrk(:k, :k), eigvals_wrk(:k))

                ! Compute residuals.
                beta = H(k+1, k)
                #:if type[0] == "c"
                residuals_wrk(:k) = compute_residual_${type[0]}$${kind}$(beta, eigvecs_wrk(k,:k))
                #:else
                do i = 1, k
                    if (eigvals_wrk(i)%im > 0) then
                        alpha = abs(cmplx(eigvecs_wrk(k, i), eigvecs_wrk(k, i+1), kind=${kind}$))
                    else if (eigvals_wrk(i)%im < 0) then
                        alpha = abs(cmplx(eigvecs_wrk(k, i-1), eigvecs_wrk(k, i), kind=${kind}$))
                    else
                        alpha = abs(eigvecs_wrk(k, i))
                    endif
                    residuals_wrk(i) = compute_residual_${type[0]}$${kind}$(beta, alpha)
                enddo
                #:endif

                ! Check convergence.
                niter = niter + 1
                conv = count(residuals_wrk(:k) < tol)
                write(msg,'(I0,A,I0,A,I0,A)') conv, '/', nev, ' eigenvalues converged after ', niter, &
                            & ' steps of the Arnoldi process.'
                call logger%log_information(msg, module=this_module, procedure='eigs_${type[0]}$${kind}$')
                if (conv >= nev) exit arnoldi_factorization
            enddo arnoldi_factorization

            write(msg,'(I0,A,I0,A,I0,A)') conv, '/', nev, ' eigenvalues converged after ', krst, &
                            & ' Krylov-Schur restarts of the Arnoldi process.'
            call logger%log_information(msg, module=this_module, procedure='eigs_${type[0]}$${kind}$')
            ! Krylov-Schur restarting procedure.
            krst  = krst + 1
            call krylov_schur(kstart, Xwrk, H, select_) ; kstart = kstart + 1
            
        end do krylovschur

        !--------------------------------
        !-----     POST-PROCESS     -----
        !--------------------------------

        block
        integer :: indices(kdim_)
        real(${kind}$) :: abs_eigvals(kdim_)
       
        ! Re-compute eigenvalues and eigenvectors.
        k = min(k, kdim_) ; call eig(H(:k, :k), eigvecs_wrk(:k, :k), eigvals_wrk(:k))
        ! Sort eigenvalues.
        abs_eigvals = abs(eigvals_wrk) ; call sort_index(abs_eigvals, indices, reverse=.true.)
        eigvals_wrk = eigvals_wrk(indices) ; eigvecs_wrk = eigvecs_wrk(:, indices)
        residuals_wrk = residuals_wrk(indices)

        ! Store converged eigenvalues.
        eigvals = eigvals_wrk(:nev) ; residuals = residuals_wrk(:nev)
        end block

        ! Construct eigenvectors.
        do i = 1, nev
            call X(i)%zero()
            do j = 1, k
                call X(i)%axpby(one_${type[0]}$${kind}$, Xwrk(j), eigvecs_wrk(j, i))
            enddo
        enddo

        info = niter

        return
    end subroutine eigs_${type[0]}$${kind}$

    #:endfor

    !-----------------------------------------------------------------------------
    !-----      EIGENVALUE COMPUTATIONS FOR SYMMETRIC/HERMITIAN MATRICES     -----
    !-----------------------------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine eighs_${type[0]}$${kind}$(A, X, eigvals, residuals, info, kdim, tolerance)
        #:if type[0] == "r"
        class(abstract_sym_linop_${type[0]}$${kind}$), intent(in) :: A
        #:else
        class(abstract_hermitian_linop_${type[0]}$${kind}$), intent(in) :: A
        #:endif
        !! Linear operator whose leading eigenpairs need to be computed.
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: X(:)
        !! Leading eigevectors of \( \mathbf{A} \).
        real(${kind}$), allocatable, intent(out) :: eigvals(:)
        !! Leading eigenvalues of \( \mathbf{A} \).
        real(${kind}$), allocatable, intent(out) :: residuals(:)
        !! Residuals associated to each Ritz eigenpairs.
        integer, intent(out) :: info
        !! Information flag.
        integer, optional, intent(in) :: kdim
        !! Desired number of eigenpairs.
        real(${kind}$), optional, intent(in) :: tolerance
        !! Tolerance

        !--------------------------------------
        !-----     Internal variables     -----
        !--------------------------------------

        class(abstract_vector_${type[0]}$${kind}$), allocatable :: Xwrk(:)
        ! Krylov subspace.
        integer :: kdim_
        ! Krylov subspace dimension.
        ${type}$, allocatable :: T(:, :)
        ! Tridiagonal matrix.
        ${type}$, allocatable :: eigvecs_wrk(:, :)
        ! Working array for the Ritz eigenvectors.
        real(${kind}$), allocatable :: eigvals_wrk(:)
        ! Working array for the Ritz eigenvalues.
        real(${kind}$), allocatable :: residuals_wrk(:)
        ! Working array for the Ritz residuals.

        ! Miscellaneous.
        integer :: i, j, k, nev, conv
        real(${kind}$) :: tol
        ${type}$ :: beta
        character(len=256) :: msg

        ! Deaks with the optional args.
        nev = size(X)
        kdim_ = optval(kdim, 4*nev)
        tol = optval(tolerance, rtol_${kind}$)

        ! Allocate working variables.
        allocate(Xwrk(kdim_+1), source=X(1)) ; call zero_basis(Xwrk) ; call Xwrk(1)%rand(.true.)
        allocate(T(kdim_+1, kdim_)) ; T = zero_${type[0]}$${kind}$
        allocate(eigvecs_wrk(kdim_, kdim_)) ; eigvecs_wrk = zero_${type[0]}$${kind}$
        allocate(eigvals_wrk(kdim_)) ; eigvals_wrk = 0.0_${kind}$
        allocate(residuals_wrk(kdim_)) ; residuals_wrk = 0.0_${kind}$

        ! Ritz eigenpairs computation.
        lanczos_iter : do k = 1, kdim_
            ! Symmetric Lanczos step.
            call lanczos(A, Xwrk, T, info, kstart=k, kend=k)
            call check_info(info, 'lanczos', module=this_module, procedure='eighs_${type[0]}$${kind}$')

            ! Spectral decomposition of the k x k tridiagonal matrix.
            eigvals_wrk = 0.0_${kind}$ ; eigvecs_wrk = zero_${type[0]}$${kind}$
            call eigh(T(:k, :k), eigvals_wrk(:k), vectors=eigvecs_wrk(:k, :k))

            ! Compute residuals.
            beta = T(k+1, k)
            residuals_wrk(:k) = compute_residual_${type[0]}$${kind}$(beta, eigvecs_wrk(k, :k))

            ! Check convergence.
            conv = count(residuals_wrk(:k) < tol)
            write(msg,'(I0,A,I0,A,I0,A)') conv, '/', nev, ' eigenvalues converged after ', k, &
                            & ' iterations of the Lanczos process.'
            call logger%log_information(msg, module=this_module, procedure='eighs_${type[0]}$${kind}$')
            if (conv >= nev) exit lanczos_iter
        enddo lanczos_iter

        !--------------------------------
        !-----     POST-PROCESS     -----
        !--------------------------------

        block
            integer :: indices(kdim_)
            call sort_index(eigvals_wrk, indices, reverse=.true.)
            !eigvals_wrk = eigvals_wrk(indices) ; 
            eigvecs_wrk = eigvecs_wrk(:, indices)
            ! Store converged eigenvalues.
            eigvals = eigvals_wrk(:nev) ; residuals = residuals_wrk(:nev)
        end block

        ! Construct eigenvectors.
        k = min(k, kdim_)
        do i = 1, nev
            call X(i)%zero()
            do j = 1, k
                call X(i)%axpby(one_${type[0]}$${kind}$, Xwrk(j), eigvecs_wrk(j, i))
            enddo
        enddo
        
        info = k

        return
    end subroutine eighs_${type[0]}$${kind}$

    #:endfor

    !------------------------------------------------
    !-----     SINGULAR VALUE DECOMPOSITION     -----
    !------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine svds_${type[0]}$${kind}$(A, U, S, V, residuals, info, kdim, tolerance)
        class(abstract_linop_${type[0]}$${kind}$), intent(in) :: A
        !! Linear operator whose leading singular triplets need to be computed.
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: U(:)
        !! Leading left singular vectors.
        real(${kind}$), allocatable, intent(out) :: S(:)
        !! Leading singular values.
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: V(:)
        !! Leading right singular vectors.
        real(${kind}$), allocatable, intent(out) :: residuals(:)
        !! Residuals associated to each Ritz eigenpair.
        integer, intent(out) :: info
        !! Information flag.
        integer, optional, intent(in) :: kdim
        !! Desired number of eigenpairs.
        real(${kind}$), optional, intent(in) :: tolerance
        !! Tolerance.

        !--------------------------------------
        !-----     Internal variables     -----
        !--------------------------------------
        ! Left and right Krylov subspaces.
        integer :: kdim_
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: Uwrk(:), Vwrk(:)
        ! Bidiagonal matrix.
        ${type}$, allocatable :: B(:, :)
        ! Working arrays for the singular vectors and singular values.
        real(${kind}$), allocatable :: svdvals_wrk(:)
        ${type}$, allocatable :: umat(:, :), vmat(:, :)
        real(${kind}$), allocatable :: residuals_wrk(:)
        ! Miscellaneous.
        integer :: nsv, conv
        integer :: i, j, k
        real(${kind}$) :: tol
        character(len=256) :: msg

        ! Deals with the optional arguments.
        nsv = size(U)
        kdim_ = optval(kdim, 4*nsv)
        tol     = optval(tolerance, rtol_${kind}$)

        ! Allocate working variables.
        allocate(Uwrk(kdim_+1), source=U(1)) ; call zero_basis(Uwrk) ; call Uwrk(1)%rand(.true.)
        allocate(Vwrk(kdim_+1), source=V(1)) ; call zero_basis(Vwrk)
        allocate(svdvals_wrk(kdim_)) ; svdvals_wrk = 0.0_${kind}$
        allocate(umat(kdim_, kdim_)) ; umat = 0.0_${kind}$
        allocate(vmat(kdim_, kdim_)) ; vmat = 0.0_${kind}$
        allocate(residuals_wrk(kdim_)) ; residuals_wrk = 0.0_${kind}$
        allocate(B(kdim_+1, kdim_)) ; B = 0.0_${kind}$

        info = 0

        ! Ritz singular triplets computation.
        lanczos_iter : do k = 1, kdim_
            ! Lanczos bidiag. step.
            call bidiagonalization(A, Uwrk, Vwrk, B, info, kstart=k, kend=k, tol=tol)
            call check_info(info, 'bidiagonalization', module=this_module, procedure='svds_${type[0]}$${kind}$')

            ! SVD of the k x k bidiagonal matrix and residual computation.
            svdvals_wrk = 0.0_${kind}$ ; umat = 0.0_${kind}$ ; vmat = 0.0_${kind}$

            call svd(B(:k, :k), svdvals_wrk(:k), umat(:k, :k), vmat(:k, :k))
            #:if type[0] == "r"
            vmat(:k, :k) = transpose(vmat(:k, :k))
            #:else
            vmat(:k, :k) = conjg(transpose(vmat(:k, :k)))
            #:endif

            residuals_wrk(:k) = compute_residual_${type[0]}$${kind}$(B(k+1, k), vmat(k, :k))

            ! Check for convergence.
            conv = count(residuals_wrk(:k) < tol)
            write(msg,'(I0,A,I0,A,I0,A)') conv, '/', nsv, ' singular values converged after ', k, &
                            & ' iterations of the Lanczos process.'
            call logger%log_information(msg, module=this_module, procedure='svds_${type[0]}$${kind}$')
            if (conv >= nsv) exit lanczos_iter
        enddo lanczos_iter

        !--------------------------------
        !-----     POST-PROCESS     -----
        !--------------------------------

        ! Singular values.
        S = svdvals_wrk(:nsv) ; residuals = residuals_wrk(:nsv)

        ! Singular vectors.
        k = min(k, kdim_) ; info = k
        do i = 1, nsv
            call U(i)%zero() ; call V(i)%zero()
            do j = 1, k
                call U(i)%axpby(one_${type[0]}$${kind}$, Uwrk(j), umat(j, i))
                call V(i)%axpby(one_${type[0]}$${kind}$, Vwrk(j), vmat(j, i))
            enddo
        enddo

        return
    end subroutine svds_${type[0]}$${kind}$

    #:endfor

    !-------------------------------------------------------
    !-----     GENERALIZED MINIMUM RESIDUAL METHOD     -----
    !-------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine gmres_${type[0]}$${kind}$(A, b, x, info, rtol, atol, preconditioner, options, transpose, meta)
        class(abstract_linop_${type[0]}$${kind}$), intent(in) :: A
        !! Linear operator to be inverted.
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: b
        !! Right-hand side vector.
        class(abstract_vector_${type[0]}$${kind}$), intent(inout) :: x
        !! Solution vector.
        integer, intent(out) :: info
        !! Information flag.
        real(${kind}$), optional, intent(in) :: rtol
        !! Relative solver tolerance
        real(${kind}$), optional, intent(in) :: atol
        !! Absolute solver tolerance
        class(abstract_precond_${type[0]}$${kind}$), optional, intent(in) :: preconditioner
        !! Preconditioner (optional).
        class(abstract_opts), optional, intent(in) :: options
        !! GMRES options.   
        logical, optional, intent(in) :: transpose
        !! Whether \(\mathbf{A}\) or \(\mathbf{A}^H\) is being used.
        class(abstract_metadata), optional, intent(out) :: meta
        !! Metadata.

        !--------------------------------------
        !-----     Internal variables     -----
        !--------------------------------------

        ! Options.
        integer :: kdim, maxiter
        real(${kind}$) :: tol, rtol_, atol_
        logical :: trans
        type(gmres_${kind}$_opts)     :: opts
        type(gmres_${kind}$_metadata) :: gmres_meta

        ! Krylov subspace
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: V(:)
        ! Hessenberg matrix.
        ${type}$, allocatable :: H(:, :)
        ! Least-squares variables.
        ${type}$, allocatable :: y(:), e(:)
        ${type}$ :: beta

        ! Preconditioner
        logical :: has_precond
        class(abstract_precond_${type[0]}$${kind}$), allocatable :: precond

        ! Miscellaneous.
        integer :: i, k, niter
        ${type}$, allocatable :: alpha(:)
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: dx, wrk
        character(len=256) :: msg

        ! Deals with the optional args.
        rtol_ = optval(rtol, rtol_${kind}$)
        atol_ = optval(atol, atol_${kind}$)
        if (present(options)) then
            select type (options)
            type is (gmres_${kind}$_opts)
                opts = options
            end select
        else
            opts = gmres_${kind}$_opts()
        endif

        kdim = opts%kdim ; maxiter = opts%maxiter
        tol = atol_ + rtol_ * b%norm()
        trans = optval(transpose, .false.)

        ! Deals with the preconditioner.
        if (present(preconditioner)) then
            has_precond = .true.
            allocate(precond, source=preconditioner)
        else
            has_precond = .false.
        endif

        ! Initialize working variables.
        allocate(wrk, source=b) ; call wrk%zero()
        allocate(V(kdim+1), source=b) ; call zero_basis(V)
        allocate(H(kdim+1, kdim)) ; H = 0.0_${kind}$
        allocate(y(kdim)) ; y = 0.0_${kind}$
        allocate(alpha(kdim)) ; alpha = 0.0_${kind}$
        allocate(e(kdim+1)) ; e = 0.0_${kind}$

        ! Initialize meta
        gmres_meta = gmres_${kind}$_metadata()
        allocate(gmres_meta%res(opts%maxiter*kdim+1)); gmres_meta%res = 0.0_${kind}$

        info = 0

        ! Initial Krylov vector.
        if (x%norm() > 0) then
            if (trans) then
                call A%rmatvec(x, V(1)); gmres_meta%n_Ax = gmres_meta%n_Ax + 1
            else
                call A%matvec(x, V(1)); gmres_meta%n_Ax = gmres_meta%n_Ax + 1
            endif
        endif

        call V(1)%sub(b) ; call V(1)%chsgn()
        beta = V(1)%norm() ; call V(1)%scal(one_${type[0]}$${kind}$/beta)
        gmres_meta%res(1) = beta

        ! Iterative solver.
        gmres_iter : do i = 1, maxiter
            ! Zero-out variables.
            H = 0.0_${kind}$ ; y = 0.0_${kind}$ ; e = 0.0_${kind}$ ; e(1) = beta
            call zero_basis(V(2:))

            ! Arnoldi factorization.
            arnoldi_fact: do k = 1, kdim
                ! Preconditioner.
                wrk = V(k) ; if (has_precond) call precond%apply(wrk)

                ! Matrix-vector product.
                if (trans) then
                    call A%rmatvec(wrk, V(k+1)); gmres_meta%n_Ax = gmres_meta%n_Ax + 1
                else
                    call A%matvec(wrk, V(k+1)); gmres_meta%n_Ax = gmres_meta%n_Ax + 1
                endif

                ! Double Gram-Schmid orthogonalization
                call double_gram_schmidt_step(V(k+1), V(:k), info, if_chk_orthonormal=.false., beta=H(:k, k))
                call check_info(info, 'double_gram_schmidt_step', module=this_module, procedure='gmres_${type[0]}$${kind}$')

                ! Update Hessenberg matrix and normalize residual Krylov vector.
                H(k+1, k) = V(k+1)%norm()
                if (abs(H(k+1, k)) > tol) then
                    call V(k+1)%scal(one_${type[0]}$${kind}$ / H(k+1, k))
                endif

                ! Least-squares problem.
                y(:k) = lstsq(H(:k+1, :k), e(:k+1))

                ! Compute residual.
                beta = norm2(abs(e(:k+1) - matmul(H(:k+1, :k), y(:k))))

                ! Save metadata.
                gmres_meta%n_iter  = gmres_meta%n_iter + 1
                gmres_meta%n_inner = gmres_meta%n_inner + 1
                gmres_meta%res(gmres_meta%n_iter+1) = beta

                ! Check convergence.
                write(msg,'(A,I3,2(A,E9.2))') 'GMRES(k)   inner step ', k, ': |res|= ', &
                            & abs(beta), ', tol= ', tol
                call logger%log_information(msg, module=this_module, procedure='gmres_${type[0]}$${kind}$')
                if (abs(beta) <= tol) then
                    gmres_meta%converged = .true.
                    exit arnoldi_fact
                endif
            enddo arnoldi_fact

            ! Update solution.
            k = min(k, kdim) ; call linear_combination(dx, V(:k), y(:k))
            if (has_precond) call precond%apply(dx) ; call x%add(dx)

            ! Recompute residual for sanity check.
            if (trans) then
                call A%rmatvec(x, v(1)); gmres_meta%n_Ax = gmres_meta%n_Ax + 1
            else
                call A%matvec(x, v(1)); gmres_meta%n_Ax = gmres_meta%n_Ax + 1
            endif
            call v(1)%sub(b) ; call v(1)%chsgn()

            ! Initialize new starting Krylov vector if needed.
            beta = v(1)%norm() ; call v(1)%scal(one_${type[0]}$${kind}$ / beta)

            ! Save metadata.
            gmres_meta%n_iter  = gmres_meta%n_iter + 1
            gmres_meta%n_outer = gmres_meta%n_outer + 1
            gmres_meta%res(gmres_meta%n_iter) = beta

            write(msg,'(A,I3,2(A,E9.2))') 'GMRES(k) outer step   ', i, ': |res|= ', &
                            & abs(beta), ', tol= ', tol
            call logger%log_information(msg, module=this_module, procedure='gmres_${type[0]}$${kind}$')

            ! Exit gmres if desired accuracy is reached.
            if (abs(beta) <= tol) then
               gmres_meta%converged = .true.
               exit gmres_iter
            end if
        enddo gmres_iter

        ! Returns the number of iterations.
        info = gmres_meta%n_iter
        gmres_meta%info = info

        ! Set metadata output
        if (present(meta)) then
           select type(meta)
                 type is (gmres_${kind}$_metadata)
                    meta = gmres_meta
           end select
        end if

        return
    end subroutine gmres_${type[0]}$${kind}$

    #:endfor




    !---------------------------------------------
    !-----     CONJUGATE GRADIENT METHOD     -----
    !---------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine cg_${type[0]}$${kind}$(A, b, x, info, rtol, atol, preconditioner, options, meta)
        #:if type[0] == "r"
        class(abstract_sym_linop_${type[0]}$${kind}$), intent(in) :: A
        #:else
        class(abstract_hermitian_linop_${type[0]}$${kind}$), intent(in) :: A
        #:endif
        !! Linear operator to be inverted.
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: b
        !! Right-hand side vector.
        class(abstract_vector_${type[0]}$${kind}$), intent(inout) :: x
        !! Solution vector.
        integer, intent(out) :: info
        !! Information flag.
        real(${kind}$), optional, intent(in) :: rtol
        !! Relative solver tolerance
        real(${kind}$), optional, intent(in) :: atol
        !! Absolute solver tolerance
        class(abstract_precond_${type[0]}$${kind}$), optional, intent(in) :: preconditioner
        !! Preconditioner (not yet supported).
        type(cg_${kind}$_opts), optional, intent(in) :: options
        !! Options for the conjugate gradient solver.
        class(abstract_metadata), optional, intent(out) :: meta
        !! Metadata.

        !----------------------------------------
        !-----     Internal variables      ------
        !----------------------------------------

        ! Options.
        integer :: maxiter
        real(${kind}$) :: tol, rtol_, atol_
        type(cg_${kind}$_opts)     :: opts
        type(cg_${kind}$_metadata) :: cg_meta

        ! Working variables.
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: r, p, Ap
        ${type}$ :: alpha, beta, r_dot_r_old, r_dot_r_new
        real(${kind}$) :: residual

        ! Miscellaneous.
        integer :: i
        character(len=256) :: msg

        ! Deals with the optional args.
        rtol_ = optval(rtol, rtol_${kind}$)
        atol_ = optval(atol, atol_${kind}$)
        if (present(options)) then
            opts = options
        else
            opts = cg_${kind}$_opts()
        endif
        tol = atol_ + rtol_ * b%norm() ; maxiter = opts%maxiter

        ! Initialize vectors.
        allocate(r, source=b)  ; call r%zero()
        allocate(p, source=b)  ; call p%zero()
        allocate(Ap, source=b) ; call Ap%zero()

         ! Initialize meta
        cg_meta = cg_${kind}$_metadata()
        allocate(cg_meta%res(opts%maxiter+1)); cg_meta%res = 0.0_${kind}$

        info = 0

        ! Compute initial residual r = b - Ax.
        if (x%norm() > 0) call A%matvec(x, r); cg_meta%n_Ax = cg_meta%n_Ax + 1
        call r%sub(b) ; call r%chsgn()

        ! Initialize direction vector.
        p = r

        ! Initialize dot product of residual r_dot_r_old = r' * r
        r_dot_r_old = r%dot(r)
        cg_meta%res(1) = sqrt(abs(r_dot_r_old))

        ! Conjugate gradient iteration.
        cg_loop: do i = 1, maxiter
            ! Compute A @ p
            call A%matvec(p, Ap); cg_meta%n_Ax = cg_meta%n_Ax + 1
            ! Compute step size.
            alpha = r_dot_r_old / p%dot(Ap)
            ! Update solution x = x + alpha*p
            call x%axpby(one_${type[0]}$${kind}$, p, alpha)
            ! Update residual r = r - alpha*Ap
            call r%axpby(one_${type[0]}$${kind}$, Ap, -alpha)
            ! Compute new dot product of residual r_dot_r_new = r' * r.
            r_dot_r_new = r%dot(r)
            ! Check for convergence.
            #:if type[0] == "c"
            residual = sqrt(abs(r_dot_r_new))
            #:else
            residual = sqrt(r_dot_r_new)
            #:endif

            ! Save metadata.
            cg_meta%n_iter = cg_meta%n_iter + 1
            cg_meta%res(cg_meta%n_iter+1) = residual

            if (residual < tol) then
               cg_meta%converged = .true.
               exit cg_loop
            end if

            ! Compute new direction beta = r_dot_r_new / r_dot_r_old.
            beta = r_dot_r_new / r_dot_r_old
            ! Update direction p = beta*p + r
            call p%axpby(beta, r, one_${type[0]}$${kind}$)
            ! Update r_dot_r_old for next iteration.
            r_dot_r_old = r_dot_r_new

            write(msg,'(A,I3,2(A,E9.2))') 'CG step ', i, ': res= ', residual, ', tol= ', tol
            call logger%log_information(msg, module=this_module, procedure='cg_${type[0]}$${kind}$')
        enddo cg_loop

        ! Set and copy info flag for completeness
        info = cg_meta%n_iter
        cg_meta%info = info

        ! Set metadata output
        if (present(meta)) then
           select type(meta)
               type is (cg_${kind}$_metadata)
                   meta = cg_meta
           end select
        end if
        
        return
    end subroutine cg_${type[0]}$${kind}$

    #:endfor

end module lightkrylov_IterativeSolvers
