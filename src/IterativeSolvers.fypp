#:include "../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module lightkrylov_IterativeSolvers

    use iso_fortran_env, only: output_unit
    
    use stdlib_sorting, only: sort_index
    use stdlib_optval, only: optval
    use stdlib_io_npy, only: save_npy
    use stdlib_linalg, only: lstsq, svd
    use stdlib_stats, only: median

    use LightKrylov_Constants
    Use LightKrylov_Logger
    use LightKrylov_Utils
    use LightKrylov_AbstractVectors
    use LightKrylov_AbstractLinops
    use LightKrylov_BaseKrylov

    implicit none
    private

    character*128, parameter :: this_module = 'LightKrylov_IterativeSolvers'

    #:for kind, type in RC_KINDS_TYPES
    public :: abstract_linear_solver_${type[0]}$${kind}$
    #:endfor
    public :: save_eigenspectrum
    public :: eigs
    public :: eighs
    public :: svds
    public :: gmres
    #:for kind, type in RC_KINDS_TYPES
    public :: gmres_${type[0]}$${kind}$
    #:endfor
    public :: cg
    #:for kind, type in RC_KINDS_TYPES
    public :: cg_${type[0]}$${kind}$
    #:endfor

    interface save_eigenspectrum
        #:for kind in REAL_KINDS
        module procedure save_eigenspectrum_${kind}$
        #:endfor
    end interface

    interface eighs
        #:for kind, type in RC_KINDS_TYPES
        module procedure eighs_${type[0]}$${kind}$
        #:endfor
    end interface

    interface eigs
        #:for kind, type in RC_KINDS_TYPES
        module procedure eigs_${type[0]}$${kind}$
        #:endfor
    end interface

    interface svds
        #:for kind, type in RC_KINDS_TYPES
        module procedure svds_${type[0]}$${kind}$
        #:endfor
    end interface

    interface gmres
        #:for kind, type in RC_KINDS_TYPES
        module procedure gmres_${type[0]}$${kind}$
        #:endfor
    end interface

    interface cg
        #:for kind, type in RC_KINDS_TYPES
        module procedure cg_${type[0]}$${kind}$
        #:endfor
    end interface

    !------------------------------------------------------
    !-----     ABSTRACT PRECONDITIONER DEFINITION     -----
    !------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    type, abstract, public :: abstract_precond_${type[0]}$${kind}$
    contains
        private
        procedure(abstract_apply_${type[0]}$${kind}$), pass(self), public, deferred :: apply
    end type

    abstract interface
        subroutine abstract_apply_${type[0]}$${kind}$(self, vec)
            !! Abstract interface to apply a preconditioner in `LightKrylov`.
            import abstract_precond_${type[0]}$${kind}$, abstract_vector_${type[0]}$${kind}$
            class(abstract_precond_${type[0]}$${kind}$), intent(in) :: self
            !! Preconditioner.
            class(abstract_vector_${type[0]}$${kind}$), intent(inout) :: vec
            !! Input/Output vector.
        end subroutine abstract_apply_${type[0]}$${kind}$
    end interface
    
    #:endfor

    !--------------------------------------------------------
    !-----                                              -----
    !-----     GENERIC INTERFACE FOR LINEAR SOLVERS     -----
    !-----                                              -----
    !--------------------------------------------------------

    abstract interface
    #:for kind, type in RC_KINDS_TYPES
        subroutine abstract_linear_solver_${type[0]}$${kind}$(A, b, x, info, rtol, atol, preconditioner, options, transpose)
            !! Abstract interface to use a user-defined linear solver in `LightKrylov`.
            import abstract_linop_${type[0]}$${kind}$, abstract_vector_${type[0]}$${kind}$, abstract_opts, abstract_precond_${type[0]}$${kind}$, ${kind}$
            class(abstract_linop_${type[0]}$${kind}$), intent(in) :: A
            !! Linear operator to invert.
            class(abstract_vector_${type[0]}$${kind}$), intent(in) :: b
            !! Right-hand side vector.
            class(abstract_vector_${type[0]}$${kind}$), intent(inout) :: x
            !! Solution vector.
            integer, intent(out) :: info
            !! Information flag. In case of successful exit, the flag should return the number of iterations required for convergence.
            real(${kind}$), optional, intent(in) :: rtol
            !! Relative solver tolerance
            real(${kind}$), optional, intent(in) :: atol
            !! Absolute solver tolerance
            class(abstract_opts), optional, intent(in) :: options
            !! Options passed to the linear solver.
            class(abstract_precond_${type[0]}$${kind}$), optional, intent(in) :: preconditioner
            !! Preconditioner.
            logical, optional, intent(in) :: transpose
            !! Determine whether \(\mathbf{A}\) (`.false.`) or \(\mathbf{A}^T\) (`.true.`) is being used.
        end subroutine abstract_linear_solver_${type[0]}$${kind}$

    #:endfor
    end interface

contains

    !-------------------------------------
    !-----     UTILITY FUNCTIONS     -----
    !-------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    elemental pure function compute_residual_${type[0]}$${kind}$(beta, x) result(residual)
        !! Computes the residual associated with a Ritz eigenpair.
        ${type}$, intent(in) :: beta
        !! Norm of the residual Krylov vector.
        ${type}$, intent(in) :: x
        !! Last entry of the low-dimensional Ritz eigenvector.
        real(${kind}$) :: residual
        !! Residual associated to the corresponding Ritz eigenpair.
        residual = abs(beta*x)
        return
    end function compute_residual_${type[0]}$${kind}$

    #:endfor

    #:for kind in REAL_KINDS
    subroutine save_eigenspectrum_${kind}$(eigvals, residuals, fname)
        !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format.
        complex(${kind}$), intent(in) :: eigvals(:)
        !! Eigenalues.
        real(${kind}$), intent(in) :: residuals(:)
        !! Residual of the corresponding Ritz eigenpairs.
        character(len=*), intent(in) :: fname
        !! Name of the output file.

        ! Internal variables.
        real(${kind}$) :: data(size(eigvals), 3)

        ! Store data.
        data(:, 1) = eigvals%re ; data(:, 2) = eigvals%im ; data(:, 3) = residuals
        ! Save the eigenspectrum to disk.
        call save_npy(fname, data)

        return
    end subroutine save_eigenspectrum_${kind}$

    function median_eigvals_selector_${kind}$(lambda) result(selected)
        complex(${kind}$), intent(in) :: lambda(:)
        logical :: selected(size(lambda))
        selected = abs(lambda) > median(abs(lambda))
        return
    end function median_eigvals_selector_${kind}$

    #:endfor

    !---------------------------------------------------
    !-----     GENERAL EIGENVALUE COMPUTATIONS     -----
    !---------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine eigs_${type[0]}$${kind}$(A, X, eigvals, residuals, info, kdim, select, tolerance, transpose)
        class(abstract_linop_${type[0]}$${kind}$), intent(in) :: A
        !! Linear operator whose leading eigenpairs need to be computed.
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: X(:)
        !! Leading eigenvectors of \(\mathbf{A}\).
        complex(${kind}$), allocatable, intent(out) :: eigvals(:)
        !! Leading eigenvalues of \(\mathbf{A}\).
        real(${kind}$), allocatable, intent(out) :: residuals(:)
        !! Residuals associated to each Ritz eigenpair.
        integer, intent(out) :: info
        !! Information flag.
        integer, optional, intent(in) :: kdim
        procedure(eigvals_select_${kind}$), optional :: select
        !! Desired number of eigenpairs.
        real(${kind}$), optional, intent(in) :: tolerance
        !! Tolerance.
        logical, optional, intent(in) :: transpose
        !! Determine whether \(\mathbf{A}\) or \(\mathbf{A}^H\) is being used.

        !--------------------------------------
        !-----     Internal variables     -----
        !--------------------------------------

        ! Krylov subspace and Krylov subspace dimension.
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: Xwrk(:)
        integer :: kdim_, kstart
        ! Hessenberg matrix.
        ${type}$, allocatable :: H(:, :)
        ! Working arrays for the eigenvectors and eigenvalues.
        #:if type[0] == "c"
        ${type}$, allocatable :: eigvecs_wrk(:, :)
        #:else
        real(${kind}$), allocatable :: eigvecs_wrk(:, :)
        #:endif
        complex(${kind}$), allocatable :: eigvals_wrk(:)
        real(${kind}$), allocatable :: residuals_wrk(:)
        ! Miscellaneous.
        integer :: nev, conv
        integer :: i, j, k, niter, krst
        real(${kind}$) :: tol
        ${type}$ :: beta
        #:if type[0] == "r"
        ${type}$ :: alpha
        #:endif
        character(len=256) :: msg
        ! Eigenvalue selection.
        procedure(eigvals_select_${kind}$), pointer :: select_

        ! Deals with optional parameters.
        nev = size(X)
        kdim_   = optval(kdim, 4*nev)
        tol     = optval(tolerance, rtol_${kind}$)

        if (present(select)) then
            select_ => select
        else
            select_ => median_eigvals_selector_${kind}$
        endif

        ! Allocate eigenvalues.
        allocate(eigvals(nev)) ; eigvals = 0.0_${kind}$

        ! Allocate working variables.
        allocate(Xwrk(kdim_+1), source=X(1)) ; call zero_basis(Xwrk) ; call Xwrk(1)%rand(.true.)
        allocate(H(kdim_+1, kdim_)) ; H = 0.0_${kind}$
        allocate(eigvecs_wrk(kdim_, kdim_)) ; eigvecs_wrk = 0.0_${kind}$
        allocate(eigvals_wrk(kdim_)) ; eigvals_wrk = 0.0_${kind}$
        allocate(residuals_wrk(kdim_)) ; residuals_wrk = 0.0_${kind}$

        ! Ritz eigenpairs computation.
        H = 0.0_${kind}$

        kstart = 1 ; conv = 0 ; niter = 0 ; krst = 1
        krylovschur: do while (conv < nev)

           arnoldi_factorization: do k = kstart, kdim_
                ! Arnoldi step.
                call arnoldi(A, Xwrk, H, info, kstart=k, kend=k, transpose=transpose)
                call check_info(info, 'arnoldi', module=this_module, procedure='eigs_${type[0]}$${kind}$')

                ! Spectral decomposition of the k x k Hessenberg matrix.
                eigvals_wrk = 0.0_${kind}$ ; eigvecs_wrk = 0.0_${kind}$
                call eig(H(:k, :k), eigvecs_wrk(:k, :k), eigvals_wrk(:k))

                ! Compute residuals.
                beta = H(k+1, k)
                #:if type[0] == "c"
                residuals_wrk(:k) = compute_residual_${type[0]}$${kind}$(beta, eigvecs_wrk(k,:k))
                #:else
                do i = 1, k
                    if (eigvals_wrk(i)%im > 0) then
                        alpha = abs(cmplx(eigvecs_wrk(k, i), eigvecs_wrk(k, i+1), kind=${kind}$))
                    else if (eigvals_wrk(i)%im < 0) then
                        alpha = abs(cmplx(eigvecs_wrk(k, i-1), eigvecs_wrk(k, i), kind=${kind}$))
                    else
                        alpha = abs(eigvecs_wrk(k, i))
                    endif
                    residuals_wrk(i) = compute_residual_${type[0]}$${kind}$(beta, alpha)
                enddo
                #:endif

                ! Check convergence.
                niter = niter + 1
                conv = count(residuals_wrk(:k) < tol)
                write(msg,'(I0,A,I0,A,I0,A)') conv, '/', nev, ' eigenvalues converged after ', niter, &
                            & ' steps of the Arnoldi process.'
                call logger%log_information(msg, module=this_module, procedure='eigs_${type[0]}$${kind}$')
                if (conv >= nev) exit arnoldi_factorization
            enddo arnoldi_factorization

            write(msg,'(I0,A,I0,A,I0,A)') conv, '/', nev, ' eigenvalues converged after ', krst, &
                            & ' Krylov-Schur restarts of the Arnoldi process.'
            call logger%log_information(msg, module=this_module, procedure='eigs_${type[0]}$${kind}$')
            ! Krylov-Schur restarting procedure.
            krst  = krst + 1
            call krylov_schur(kstart, Xwrk, H, select_) ; kstart = kstart + 1
            
        end do krylovschur

        !--------------------------------
        !-----     POST-PROCESS     -----
        !--------------------------------

        block
        integer :: indices(kdim_)
        real(${kind}$) :: abs_eigvals(kdim_)
       
        ! Re-compute eigenvalues and eigenvectors.
        k = min(k, kdim_) ; call eig(H(:k, :k), eigvecs_wrk(:k, :k), eigvals_wrk(:k))
        ! Sort eigenvalues.
        abs_eigvals = abs(eigvals_wrk) ; call sort_index(abs_eigvals, indices, reverse=.true.)
        eigvals_wrk = eigvals_wrk(indices) ; eigvecs_wrk = eigvecs_wrk(:, indices)
        residuals_wrk = residuals_wrk(indices)

        ! Store converged eigenvalues.
        eigvals = eigvals_wrk(:nev) ; residuals = residuals_wrk(:nev)
        end block

        ! Construct eigenvectors.
        do i = 1, nev
            call X(i)%zero()
            do j = 1, k
                call X(i)%axpby(one_${type[0]}$${kind}$, Xwrk(j), eigvecs_wrk(j, i))
            enddo
        enddo

        info = niter

        return
    end subroutine eigs_${type[0]}$${kind}$

    #:endfor

    !-----------------------------------------------------------------------------
    !-----      EIGENVALUE COMPUTATIONS FOR SYMMETRIC/HERMITIAN MATRICES     -----
    !-----------------------------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine eighs_${type[0]}$${kind}$(A, X, eigvals, residuals, info, kdim, tolerance)
        #:if type[0] == "r"
        class(abstract_sym_linop_${type[0]}$${kind}$), intent(in) :: A
        #:else
        class(abstract_hermitian_linop_${type[0]}$${kind}$), intent(in) :: A
        #:endif
        !! Linear operator whose leading eigenpairs need to be computed.
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: X(:)
        !! Leading eigevectors of \( \mathbf{A} \).
        real(${kind}$), allocatable, intent(out) :: eigvals(:)
        !! Leading eigenvalues of \( \mathbf{A} \).
        real(${kind}$), allocatable, intent(out) :: residuals(:)
        !! Residuals associated to each Ritz eigenpairs.
        integer, intent(out) :: info
        !! Information flag.
        integer, optional, intent(in) :: kdim
        !! Desired number of eigenpairs.
        real(${kind}$), optional, intent(in) :: tolerance
        !! Tolerance

        !--------------------------------------
        !-----     Internal variables     -----
        !--------------------------------------

        class(abstract_vector_${type[0]}$${kind}$), allocatable :: Xwrk(:)
        ! Krylov subspace.
        integer :: kdim_
        ! Krylov subspace dimension.
        ${type}$, allocatable :: T(:, :)
        ! Tridiagonal matrix.
        ${type}$, allocatable :: eigvecs_wrk(:, :)
        ! Working array for the Ritz eigenvectors.
        real(${kind}$), allocatable :: eigvals_wrk(:)
        ! Working array for the Ritz eigenvalues.
        real(${kind}$), allocatable :: residuals_wrk(:)
        ! Working array for the Ritz residuals.

        ! Miscellaneous.
        integer :: i, j, k, nev, conv
        real(${kind}$) :: tol
        ${type}$ :: beta
        character(len=256) :: msg

        ! Deaks with the optional args.
        nev = size(X)
        kdim_ = optval(kdim, 4*nev)
        tol = optval(tolerance, rtol_${kind}$)

        ! Allocate working variables.
        allocate(Xwrk(kdim_+1), source=X(1)) ; call zero_basis(Xwrk) ; call Xwrk(1)%rand(.true.)
        allocate(T(kdim_+1, kdim_)) ; T = zero_${type[0]}$${kind}$
        allocate(eigvecs_wrk(kdim_, kdim_)) ; eigvecs_wrk = zero_${type[0]}$${kind}$
        allocate(eigvals_wrk(kdim_)) ; eigvals_wrk = 0.0_${kind}$
        allocate(residuals_wrk(kdim_)) ; residuals_wrk = 0.0_${kind}$

        ! Ritz eigenpairs computation.
        lanczos : do k = 1, kdim_
            ! Symmetric Lanczos step.
            call lanczos_tridiagonalization(A, Xwrk, T, info, kstart=k, kend=k)
            call check_info(info, 'lanczos_tridiagonalization', module=this_module, procedure='eighs_${type[0]}$${kind}$')

            ! Spectral decomposition of the k x k tridiagonal matrix.
            eigvals_wrk = 0.0_${kind}$ ; eigvecs_wrk = zero_${type[0]}$${kind}$
            call eigh(T(:k, :k), eigvecs_wrk(:k, :k), eigvals_wrk(:k))

            ! Compute residuals.
            beta = T(k+1, k)
            residuals_wrk(:k) = compute_residual_${type[0]}$${kind}$(beta, eigvecs_wrk(k, :k))

            ! Check convergence.
            conv = count(residuals_wrk(:k) < tol)
            write(msg,'(I0,A,I0,A,I0,A)') conv, '/', nev, ' eigenvalues converged after ', k, &
                            & ' iterations of the Lanczos process.'
            call logger%log_information(msg, module=this_module, procedure='eighs_${type[0]}$${kind}$')
            if (conv >= nev) exit lanczos
        enddo lanczos

        !--------------------------------
        !-----     POST-PROCESS     -----
        !--------------------------------

        block
            integer :: indices(kdim_)
            call sort_index(eigvals_wrk, indices, reverse=.true.)
            !eigvals_wrk = eigvals_wrk(indices) ; 
            eigvecs_wrk = eigvecs_wrk(:, indices)
            ! Store converged eigenvalues.
            eigvals = eigvals_wrk(1:nev) ; residuals = residuals_wrk(:nev)
        end block

        ! Construct eigenvectors.
        k = min(k, kdim_)
        do i = 1, nev
            call X(i)%zero()
            do j = 1, k
                call X(i)%axpby(one_${type[0]}$${kind}$, Xwrk(j), eigvecs_wrk(j, i))
            enddo
        enddo
        
        info = k

        return
    end subroutine eighs_${type[0]}$${kind}$

    #:endfor

    !------------------------------------------------
    !-----     SINGULAR VALUE DECOMPOSITION     -----
    !------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine svds_${type[0]}$${kind}$(A, U, S, V, residuals, info, kdim, tolerance)
        class(abstract_linop_${type[0]}$${kind}$), intent(in) :: A
        !! Linear operator whose leading singular triplets need to be computed.
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: U(:)
        !! Leading left singular vectors.
        real(${kind}$), allocatable, intent(out) :: S(:)
        !! Leading singular values.
        class(abstract_vector_${type[0]}$${kind}$), intent(out) :: V(:)
        !! Leading right singular vectors.
        real(${kind}$), allocatable, intent(out) :: residuals(:)
        !! Residuals associated to each Ritz eigenpair.
        integer, intent(out) :: info
        !! Information flag.
        integer, optional, intent(in) :: kdim
        !! Desired number of eigenpairs.
        real(${kind}$), optional, intent(in) :: tolerance
        !! Tolerance.

        !--------------------------------------
        !-----     Internal variables     -----
        !--------------------------------------
        ! Left and right Krylov subspaces.
        integer :: kdim_
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: Uwrk(:), Vwrk(:)
        ! Bidiagonal matrix.
        ${type}$, allocatable :: B(:, :)
        ! Working arrays for the singular vectors and singular values.
        real(${kind}$), allocatable :: svdvals_wrk(:)
        ${type}$, allocatable :: umat(:, :), vmat(:, :)
        real(${kind}$), allocatable :: residuals_wrk(:)
        ! Miscellaneous.
        integer :: nsv, conv
        integer :: i, j, k
        real(${kind}$) :: tol
        character(len=256) :: msg

        ! Deals with the optional arguments.
        nsv = size(U)
        kdim_ = optval(kdim, 4*nsv)
        tol     = optval(tolerance, rtol_${kind}$)

        ! Allocate working variables.
        allocate(Uwrk(kdim_+1), source=U(1)) ; call zero_basis(Uwrk) ; call Uwrk(1)%rand(.true.)
        allocate(Vwrk(kdim_+1), source=V(1)) ; call zero_basis(Vwrk)
        allocate(svdvals_wrk(kdim_)) ; svdvals_wrk = 0.0_${kind}$
        allocate(umat(kdim_, kdim_)) ; umat = 0.0_${kind}$
        allocate(vmat(kdim_, kdim_)) ; vmat = 0.0_${kind}$
        allocate(residuals_wrk(kdim_)) ; residuals_wrk = 0.0_${kind}$
        allocate(B(kdim_+1, kdim_)) ; B = 0.0_${kind}$

        info = 0

        ! Ritz singular triplets computation.
        lanczos : do k = 1, kdim_
            ! Lanczos bidiag. step.
            call lanczos_bidiagonalization(A, Uwrk, Vwrk, B, info, kstart=k, kend=k, tol=tol)
            call check_info(info, 'lanczos_bidiagonalization', module=this_module, procedure='svds_${type[0]}$${kind}$')

            ! SVD of the k x k bidiagonal matrix and residual computation.
            svdvals_wrk = 0.0_${kind}$ ; umat = 0.0_${kind}$ ; vmat = 0.0_${kind}$

            call svd(B(:k, :k), svdvals_wrk(:k), umat(:k, :k), vmat(:k, :k))
            #:if type[0] == "r"
            vmat(:k, :k) = transpose(vmat(:k, :k))
            #:else
            vmat(:k, :k) = conjg(transpose(vmat(:k, :k)))
            #:endif

            residuals_wrk(:k) = compute_residual_${type[0]}$${kind}$(B(k+1, k), vmat(k, :k))

            ! Check for convergence.
            conv = count(residuals_wrk(:k) < tol)
            write(msg,'(I0,A,I0,A,I0,A)') conv, '/', nsv, ' singular values converged after ', k, &
                            & ' iterations of the Lanczos process.'
            call logger%log_information(msg, module=this_module, procedure='svds_${type[0]}$${kind}$')
            if (conv >= nsv) exit lanczos
        enddo lanczos

        !--------------------------------
        !-----     POST-PROCESS     -----
        !--------------------------------

        ! Singular values.
        S = svdvals_wrk(:nsv) ; residuals = residuals_wrk(:nsv)

        ! Singular vectors.
        k = min(k, kdim_) ; info = k
        do i = 1, nsv
            call U(i)%zero() ; call V(i)%zero()
            do j = 1, k
                call U(i)%axpby(one_${type[0]}$${kind}$, Uwrk(j), umat(j, i))
                call V(i)%axpby(one_${type[0]}$${kind}$, Vwrk(j), vmat(j, i))
            enddo
        enddo

        return
    end subroutine svds_${type[0]}$${kind}$

    #:endfor

    !-------------------------------------------------------
    !-----     GENERALIZED MINIMUM RESIDUAL METHOD     -----
    !-------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine gmres_${type[0]}$${kind}$(A, b, x, info, rtol, atol, preconditioner, options, transpose)
        class(abstract_linop_${type[0]}$${kind}$), intent(in) :: A
        !! Linear operator to be inverted.
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: b
        !! Right-hand side vector.
        class(abstract_vector_${type[0]}$${kind}$), intent(inout) :: x
        !! Solution vector.
        integer, intent(out) :: info
        !! Information flag.
        real(${kind}$), optional, intent(in) :: rtol
        !! Relative solver tolerance
        real(${kind}$), optional, intent(in) :: atol
        !! Absolute solver tolerance
        class(abstract_precond_${type[0]}$${kind}$), optional, intent(in) :: preconditioner
        !! Preconditioner (optional).
        !type(gmres_${kind}$_opts), optional, intent(in) :: options
        class(abstract_opts), optional, intent(in) :: options
        !! GMRES options.   
        logical, optional, intent(in) :: transpose
        !! Whether \(\mathbf{A}\) or \(\mathbf{A}^H\) is being used.

        !--------------------------------------
        !-----     Internal variables     -----
        !--------------------------------------

        ! Options.
        integer :: kdim, maxiter
        real(${kind}$) :: tol, rtol_, atol_
        logical :: trans
        type(gmres_${kind}$_opts) :: opts

        ! Krylov subspace
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: V(:)
        ! Hessenberg matrix.
        ${type}$, allocatable :: H(:, :)
        ! Least-squares variables.
        ${type}$, allocatable :: y(:), e(:)
        ${type}$ :: beta

        ! Preconditioner
        logical :: has_precond
        class(abstract_precond_${type[0]}$${kind}$), allocatable :: precond

        ! Miscellaneous.
        integer :: i, k, niter
        ${type}$, allocatable :: alpha(:)
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: dx, wrk
        character(len=256) :: msg

        ! Deals with the optional args.
        if (present(rtol)) then
            rtol_ = rtol
        else
            rtol_ = rtol_${kind}$
        end if
        if (present(atol)) then
            atol_ = atol
        else
            atol_ = atol_${kind}$
        end if
        if (present(options)) then
            select type (options)
            type is (gmres_${kind}$_opts)
                opts = options
            end select
        else
            opts = gmres_${kind}$_opts()
        endif

        kdim = opts%kdim ; maxiter = opts%maxiter
        tol = atol_ + rtol_ * b%norm()
        trans = optval(transpose, .false.)

        ! Deals with the preconditioner.
        if (present(preconditioner)) then
            has_precond = .true.
            allocate(precond, source=preconditioner)
        else
            has_precond = .false.
        endif

        ! Initialize working variables.
        allocate(wrk, source=b) ; call wrk%zero()
        allocate(V(kdim+1), source=b) ; call zero_basis(V)
        allocate(H(kdim+1, kdim)) ; H = 0.0_${kind}$
        allocate(y(kdim)) ; y = 0.0_${kind}$
        allocate(alpha(kdim)) ; alpha = 0.0_${kind}$
        allocate(e(kdim+1)) ; e = 0.0_${kind}$

        info = 0 ; niter = 0

        ! Initial Krylov vector.
        if (x%norm() > 0) then
            if (trans) then
                call A%rmatvec(x, V(1))
            else
                call A%matvec(x, V(1))
            endif
        endif

        call V(1)%sub(b) ; call V(1)%chsgn()
        beta = V(1)%norm() ; call V(1)%scal(one_${type[0]}$${kind}$/beta)

        ! Iterative solver.
        gmres_iter : do i = 1, maxiter
            ! Zero-out variables.
            H = 0.0_${kind}$ ; y = 0.0_${kind}$ ; e = 0.0_${kind}$ ; e(1) = beta
            call zero_basis(V(2:))

            ! Arnoldi factorization.
            arnoldi_fact: do k = 1, kdim
                ! Preconditioner.
                wrk = V(k) ; if (has_precond) call precond%apply(wrk)

                ! Matrix-vector product.
                if (trans) then
                    call A%rmatvec(wrk, V(k+1))
                else
                    call A%matvec(wrk, V(k+1))
                endif

                ! Double Gram-Schmid orthogonalization
                call double_gram_schmidt_step(V(k+1), V(:k), info, if_chk_orthonormal=.false., beta=H(1:k, k))
                call check_info(info, 'double_gram_schmidt_step', module=this_module, procedure='gmres_${type[0]}$${kind}$')

                ! Update Hessenberg matrix and normalize residual Krylov vector.
                H(k+1, k) = V(k+1)%norm()
                if (abs(H(k+1, k)) > tol) then
                    call V(k+1)%scal(one_${type[0]}$${kind}$ / H(k+1, k))
                endif

                ! Least-squares problem.
                y(:k) = lstsq(H(:k+1, :k), e(:k+1))

                ! Compute residual.
                beta = norm2(abs(e(:k+1) - matmul(H(:k+1, :k), y(:k))))

                ! Current number of iterations performed.
                niter = niter + 1

                ! Check convergence.
                write(msg,'(A,I3,2(A,E9.2))') 'GMRES(k)   inner step ', k, ': |res|= ', &
                            & abs(beta)', tol= ', tol
                call logger%log_information(msg, module=this_module, procedure='gmres_${type[0]}$${kind}$')
                if (abs(beta) <= tol) then
                    exit arnoldi_fact
                endif
            enddo arnoldi_fact

            ! Update solution.
            k = min(k, kdim) ; call linear_combination(dx, V(:k), y(:k))
            if (has_precond) call precond%apply(dx) ; call x%add(dx)

            ! Recompute residual for sanity check.
            if (trans) then
                call A%rmatvec(x, v(1))
            else
                call A%matvec(x, v(1))
            endif
            call v(1)%sub(b) ; call v(1)%chsgn()

            ! Initialize new starting Krylov vector if needed.
            beta = v(1)%norm() ; call v(1)%scal(one_${type[0]}$${kind}$ / beta)

            write(msg,'(A,I3,2(A,E9.2))') 'GMRES(k) outer step   ', i, ': |res|= ', &
                            & abs(beta), ', tol= ', tol
            call logger%log_information(msg, module=this_module, procedure='gmres_${type[0]}$${kind}$')

            ! Exit gmres if desired accuracy is reached.
            if (abs(beta) <= tol) exit gmres_iter

        enddo gmres_iter

        ! Returns the number of iterations.
        info = niter

        return
    end subroutine gmres_${type[0]}$${kind}$

    #:endfor




    !---------------------------------------------
    !-----     CONJUGATE GRADIENT METHOD     -----
    !---------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine cg_${type[0]}$${kind}$(A, b, x, info, rtol, atol, preconditioner, options)
        #:if type[0] == "r"
        class(abstract_sym_linop_${type[0]}$${kind}$), intent(in) :: A
        #:else
        class(abstract_hermitian_linop_${type[0]}$${kind}$), intent(in) :: A
        #:endif
        !! Linear operator to be inverted.
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: b
        !! Right-hand side vector.
        class(abstract_vector_${type[0]}$${kind}$), intent(inout) :: x
        !! Solution vector.
        integer, intent(out) :: info
        !! Information flag.
        real(${kind}$), optional, intent(in) :: rtol
        !! Relative solver tolerance
        real(${kind}$), optional, intent(in) :: atol
        !! Absolute solver tolerance
        class(abstract_precond_${type[0]}$${kind}$), optional, intent(in) :: preconditioner
        !! Preconditioner (not yet supported).
        type(cg_${kind}$_opts), optional, intent(in) :: options
        !! Options for the conjugate gradient solver.

        !----------------------------------------
        !-----     Internal variables      ------
        !----------------------------------------

        ! Options.
        integer :: maxiter
        real(${kind}$) :: tol, rtol_, atol_
        type(cg_${kind}$_opts) :: opts

        ! Working variables.
        class(abstract_vector_${type[0]}$${kind}$), allocatable :: r, p, Ap
        ${type}$ :: alpha, beta, r_dot_r_old, r_dot_r_new
        real(${kind}$) :: residual

        ! Miscellaneous.
        integer :: i
        character(len=256) :: msg

        ! Deals with the optional args.
        if (present(rtol)) then
            rtol_ = rtol
        else
            rtol_ = rtol_${kind}$
        end if
        if (present(atol)) then
            atol_ = atol
        else
            atol_ = atol_${kind}$
        end if
        if (present(options)) then
            opts = options
        else
            opts = cg_${kind}$_opts()
        endif
        tol = atol_ + rtol_ * b%norm() ; maxiter = opts%maxiter

        ! Initialize vectors.
        allocate(r, source=b)  ; call r%zero()
        allocate(p, source=b)  ; call p%zero()
        allocate(Ap, source=b) ; call Ap%zero()

        info = 0

        ! Compute initial residual r = b - Ax.
        if (x%norm() > 0) call A%matvec(x, r)
        call r%sub(b) ; call r%chsgn()

        ! Initialize direction vector.
        p = r

        ! Initialize dot product of residual r_dot_r_old = r' * r
        r_dot_r_old = r%dot(r)

        ! Conjugate gradient iteration.
        cg_loop: do i = 1, maxiter
            ! Compute A @ p
            call A%matvec(p, Ap)
            ! Compute step size.
            alpha = r_dot_r_old / p%dot(Ap)
            ! Update solution x = x + alpha*p
            call x%axpby(one_${type[0]}$${kind}$, p, alpha)
            ! Update residual r = r - alpha*Ap
            call r%axpby(one_${type[0]}$${kind}$, Ap, -alpha)
            ! Compute new dot product of residual r_dot_r_new = r' * r.
            r_dot_r_new = r%dot(r)
            ! Check for convergence.
            #:if type[0] == "c"
            residual = sqrt(abs(r_dot_r_new))
            #:else
            residual = sqrt(r_dot_r_new)
            #:endif
            ! Current number of iterations performed.
            info = info + 1

            if (residual < tol) exit cg_loop

            ! Compute new direction beta = r_dot_r_new / r_dot_r_old.
            beta = r_dot_r_new / r_dot_r_old
            ! Update direction p = beta*p + r
            call p%axpby(beta, r, one_${type[0]}$${kind}$)
            ! Update r_dot_r_old for next iteration.
            r_dot_r_old = r_dot_r_new

            write(msg,'(A,I3,2(A,E9.2))') 'CG step ', i, ': res= ', residual, ', tol= ', tol
            call logger%log_information(msg, module=this_module, procedure='cg_${type[0]}$${kind}$')
        enddo cg_loop
        
        return
    end subroutine cg_${type[0]}$${kind}$

    #:endfor

end module lightkrylov_IterativeSolvers
