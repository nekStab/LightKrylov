#:include "../../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
submodule (lightkrylov_basekrylov) gram_schmidt_process
    implicit none(type, external)
contains

    !--------------------------------------------
    !-----     DOUBLE GRAM-SCHMIDT STEP     -----
    !--------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    module procedure DGS_vector_against_basis_${type[0]}$${kind}$
        character(len=*), parameter :: this_procedure = 'DGS_vector_against_basis_${type[0]}$${kind}$'
        ${type}$, dimension(size(X)) :: proj_coefficients, wrk
        ! internal
        logical :: chk_X_orthonormality
        logical :: is_ortho

        ! optional input argument
        chk_X_orthonormality = optval(if_chk_orthonormal, .true.) ! default to true!

        if (time_lightkrylov()) call timer%start(this_procedure)
        info = 0

        ! optional orthonormality check
        if (chk_X_orthonormality) then
            is_ortho = is_orthonormal_${type[0]}$${kind}$(X)
            if (is_ortho) then
                call log_information("Input basis orthonormal. Remove this check unless necessary for better performance", &
                & this_module, this_procedure)
            else 
                call stop_error("Input basis not orthonormal.", this_module, this_procedure)
            end if
        end if

        proj_coefficients = zero_${type[0]}$${kind}$; wrk = zero_${type[0]}$${kind}$

        ! Orthogonalize vector y w.r.t. to Krylov basis X in two passes of GS.
        ! first pass
        call orthogonalize_against_basis(y, X, info, if_chk_orthonormal=.false., beta=proj_coefficients)
        call check_info(info, 'orthogonalize_against_basis_p1', this_module, this_procedure//', pass 1')
        ! second pass
        call orthogonalize_against_basis(y, X, info, if_chk_orthonormal=.false., beta=wrk)
        call check_info(info, 'orthogonalize_against_basis_p2', this_module, this_procedure//', pass 2')
        ! combine passes
        proj_coefficients = proj_coefficients + wrk

        if (present(beta)) then
            ! check size
            call assert_shape(beta, shape(proj_coefficients), 'beta', this_module, this_procedure)
            beta = proj_coefficients
        end if
        if (time_lightkrylov()) call timer%stop(this_procedure)
    end procedure DGS_vector_against_basis_${type[0]}$${kind}$

    module procedure DGS_basis_against_basis_${type[0]}$${kind}$
        character(len=*), parameter :: this_procedure = 'DGS_basis_against_basis_${type[0]}$${kind}$'
        ${type}$, dimension(size(X),size(Y)) :: proj_coefficients, wrk
        ! internal
        logical :: chk_X_orthonormality
        logical :: is_ortho

        ! optional input argument
        chk_X_orthonormality = optval(if_chk_orthonormal, .true.) ! default to true!

        if (time_lightkrylov()) call timer%start(this_procedure)
        info = 0

        ! optional orthonormality check
        if (chk_X_orthonormality) then
            is_ortho = is_orthonormal_${type[0]}$${kind}$(X)
            if (is_ortho) then
                call log_information("Input basis orthonormal. Remove this check unless necessary for better performance", &
                & this_module, this_procedure)
            else 
                call stop_error("Input basis not orthonormal.", this_module, this_procedure)
            end if
        end if

        proj_coefficients = zero_${type[0]}$${kind}$; wrk = zero_${type[0]}$${kind}$

        ! Orthogonalize Krylov basis Y w.r.t. to Krylov basis X in two passes of GS.
        ! first pass
        call orthogonalize_against_basis(Y, X, info, if_chk_orthonormal=.false., beta=proj_coefficients)
        call check_info(info, 'orthogonalize_against_basis_p1', this_module, this_procedure//', first pass')
        ! second pass
        call orthogonalize_against_basis(Y, X, info, if_chk_orthonormal=.false., beta=wrk)
        call check_info(info, 'orthogonalize_against_basis_p2', this_module, this_procedure//', second pass')
        ! combine passes
        proj_coefficients = proj_coefficients + wrk

        if (present(beta)) then
            ! check size
            call assert_shape(beta, shape(proj_coefficients), 'beta', this_module, this_procedure)
            beta = proj_coefficients
        end if
        if (time_lightkrylov()) call timer%stop(this_procedure)
    end procedure DGS_basis_against_basis_${type[0]}$${kind}$

    #:endfor
    !-------------------------------------------------------------------------------
    !-----     ORTHOGONALIZE VECTOR/BASIS AGAINST ALREADY ORTHOGONAL BASIS     -----
    !-------------------------------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    module procedure orthogonalize_vector_against_basis_${type[0]}$${kind}$
        character(len=*), parameter :: this_procedure = 'orthogonalize_vector_against_basis_${type[0]}$${kind}$'
        ${type}$ :: proj_coefficients(size(X))
        ! internal
        logical :: chk_X_orthonormality
        logical :: is_ortho

        if (time_lightkrylov()) call timer%start(this_procedure)
        info = 0

        ! optional input argument
        chk_X_orthonormality = optval(if_chk_orthonormal, .true.) ! default to true!

        ! check for zero vector
        if (y%norm() < atol_${kind}$) info = 1

        ! optional orthonormality check
        if (chk_X_orthonormality) then
            is_ortho = is_orthonormal_${type[0]}$${kind}$(X)
            if (is_ortho) then
                call log_information("Input basis orthonormal. Remove this check unless necessary for better performance", &
                & this_module, this_procedure)
            else 
                call stop_error("Input basis not orthonormal.", this_module, this_procedure)
            end if
        end if

        ! orthogonalize
        proj_coefficients = innerprod(X, y)
        block
            class(abstract_vector_${type[0]}$${kind}$), allocatable :: proj
            call linear_combination(proj, X, proj_coefficients)
            call y%sub(proj)
        end block

        if (present(beta)) then
            ! check size
            call assert_shape(beta, shape(proj_coefficients), 'beta', this_module, this_procedure)
            beta = proj_coefficients
        end if
        if (time_lightkrylov()) call timer%stop(this_procedure)
    end procedure orthogonalize_vector_against_basis_${type[0]}$${kind}$

    module procedure orthogonalize_basis_against_basis_${type[0]}$${kind}$
        character(len=*), parameter :: this_procedure = 'orthogonalize_basis_against_basis_${type[0]}$${kind}$'
        ${type}$ :: proj_coefficients(size(X), size(Y))
        ! internal
        integer :: i
        logical :: chk_X_orthonormality
        logical :: is_ortho

        if (time_lightkrylov()) call timer%start(this_procedure)
        info = 0

        ! optional input argument
        chk_X_orthonormality = optval(if_chk_orthonormal, .true.) ! default to true!

        ! check for zero vector
        do i = 1, size(Y)
            if (Y(i)%norm() < atol_${kind}$) info = i
        end do

        ! optional orthonormality check
        if (chk_X_orthonormality) then
            is_ortho = is_orthonormal_${type[0]}$${kind}$(X)
            if (is_ortho) then
                call log_information("Input basis orthonormal. Remove this check unless necessary for better performance", &
                & this_module, this_procedure)
            else 
                call stop_error("Input basis not orthonormal.", this_module, this_procedure)
            end if
        end if

        ! orthogonalize
        proj_coefficients = innerprod(X, Y)
        block
            class(abstract_vector_${type[0]}$${kind}$), allocatable :: proj(:)
            call linear_combination(proj, X, proj_coefficients)
            call axpby_basis(-one_${type[0]}$${kind}$, proj, one_${type[0]}$${kind}$, Y)
        end block

        if (present(beta)) then
            ! check size
            call assert_shape(beta, shape(proj_coefficients), 'beta', this_module, this_procedure)
            beta = proj_coefficients
        end if
        if (time_lightkrylov()) call timer%stop(this_procedure)
    end procedure orthogonalize_basis_against_basis_${type[0]}$${kind}$

    #:endfor
end submodule gram_schmidt_process
