#:include "../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module lightkrylov_expmlib

    ! Iso Fortran.
    use iso_fortran_env, only: output_unit

    ! Fortran standard library.
    use stdlib_optval, only: optval
    use stdlib_linalg, only: eye

    ! LightKrylov.
    use lightkrylov_constants
    use lightkrylov_utils
    use lightkrylov_AbstractVectors
    use lightkrylov_AbstractLinops
    use lightkrylov_BaseKrylov

    implicit none
    private

    #:for kind, type in RC_KINDS_TYPES
    public :: abstract_exptA_${type[0]}$${kind}$
    #:endfor
    public :: expm

    abstract interface
        #:for kind, type in RC_KINDS_TYPES
        subroutine abstract_exptA_${type[0]}$${kind}$(vec_out, A, vec_in, tau, info, trans)
            import ${kind}$
            import abstract_vector_${type[0]}$${kind}$
            import abstract_linop_${type[0]}$${kind}$
            !! Abstract interface to define the matrix exponential-vector product.
            class(abstract_vector_${type[0]}$${kind}$), intent(out) :: vec_out
            !! Solution vector.
            class(abstract_linop_${type[0]}$${kind}$), intent(in) :: A
            !! Linear operator to be exponentiated.
            class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec_in
            !! Input vector.
            real(${kind}$), intent(in) :: tau
            !! Time horizon for integration.
            integer, intent(out) :: info
            !! Information flag.
            logical, optional, intent(in) :: trans
            !! Use transpose ?
        end subroutine abstract_exptA_${type[0]}$${kind}$

        #:endfor
    end interface

    interface expm
    #:for kind, type in RC_KINDS_TYPES
        module procedure expm_${type[0]}$${kind}$
    #:endfor
    end interface

contains

    !--------------------------------------------
    !-----     DENSE MATRIX EXPONENTIAL     -----
    !--------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine expm_${type[0]}$${kind}$(E, A, order)
        ${type}$, intent(in) :: A(:, :)
        !! Matrix to be exponentiated.
        ${type}$, intent(out) :: E(:, :)
        !! Output matrix E = exp(tA).
        integer, optional :: order
        !! Order of the Pade approximation.

        !----- Internal variables -----
        ${type}$, allocatable :: A2(:, :), Q(:, :), X(:, :), invQ(:, :), wrk(:)
        real(${kind}$) :: a_norm, c
        integer :: n, ee, k, s
        logical :: p
        integer :: p_order

        ! Deal with optional args.
        p_order = optval(order, 10)

        n = size(A, 1)

        ! Allocate arrays.
        allocate(A2(n, n)) ; allocate(X(n, n))
        allocate(Q(n, n)) ; allocate(invQ(n, n))
        allocate(wrk(n))

        ! Compute the L-infinity norm.
        a_norm = norml_${type[0]}$${kind}$(A)

        ! Determine scaling factor for the matrix.
        ee = int(log2_r${kind}$(a_norm)) + 1
        s = max(0, ee+1)

        ! Scale the input matrix & initialize polynomial.
        A2 = A / 2.0_${kind}$**s
        X = A2

        ! Initialize P & Q and add first step.
        c = 0.5_${kind}$
        E = eye(n) ; E = E + c*A2

        Q = eye(n) ; Q = Q - c*A2

        ! Iteratively compute the Pade approximation.
        p = .true.
        do k = 2, p_order
            c = c*(p_order - k + 1) / (k * (2*p_order - k + 1))
            X = matmul(A2, X)
            E = E + c*X
            if (p) then
                Q = Q + c*X
            else
                Q = Q - c*X
            endif
            p = .not. p
        enddo

        invQ = Q ; call inv(invQ)
        E = matmul(invQ, E)

        do k = 1, s
            E = matmul(E, E)
        enddo

        return
    end subroutine expm_${type[0]}$${kind}$
    #:endfor

end module lightkrylov_expmlib


