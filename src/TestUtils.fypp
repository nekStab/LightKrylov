#:include "../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module LightKrylov_TestUtils
    ! Fortran Standard Library
    use stdlib_stats_distribution_normal, only: normal => rvs_normal
    use stdlib_optval, only: optval
    use stdlib_linalg, only: eye
    ! LightKrylov
    use LightKrylov
    use LightKrylov_Constants
    
    implicit none
    
    private

    character(len=128), parameter, private :: this_module = 'LightKrylov_TestUtils'

    integer, parameter, public :: test_size = 128

    public :: get_data
    public :: put_data
    public :: init_rand
    public :: get_err_str

    !-----------------------------------------------
    !-----     TEST VECTOR TYPE DEFINITION     -----
    !-----------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    type, extends(abstract_vector_${type[0]}$${kind}$), public :: vector_${type[0]}$${kind}$
        ${type}$, dimension(test_size) :: data = 0.0_${kind}$
    contains
        private
        procedure, pass(self), public :: zero => init_zero_${type[0]}$${kind}$
        procedure, pass(self), public :: dot => dot_${type[0]}$${kind}$
        procedure, pass(self), public :: scal => scal_${type[0]}$${kind}$
        procedure, pass(self), public :: axpby => axpby_${type[0]}$${kind}$
        procedure, pass(self), public :: rand => rand_${type[0]}$${kind}$
        procedure, pass(self), public :: get_size => get_size_${type[0]}$${kind}$
    end type vector_${type[0]}$${kind}$

    #:endfor

    !----------------------------------------------
    !-----     TEST LINOP TYPE DEFINITION     -----
    !----------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    #:if type[0] == "r"
    type, extends(abstract_linop_${type[0]}$${kind}$), public :: linop_${type[0]}$${kind}$
        ${type}$, dimension(test_size, test_size) :: data = 0.0_${kind}$
    contains
        private
        procedure, pass(self), public :: matvec  => matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => rmatvec_${type[0]}$${kind}$
    end type

    type, extends(abstract_sym_linop_${type[0]}$${kind}$), public :: spd_linop_${type[0]}$${kind}$
        ${type}$, dimension(test_size, test_size) :: data = 0.0_${kind}$
    contains
        private
        procedure, pass(self), public :: matvec => sdp_matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => sdp_matvec_${type[0]}$${kind}$
    end type
    #:else
    type, extends(abstract_linop_${type[0]}$${kind}$), public :: linop_${type[0]}$${kind}$
        ${type}$, dimension(test_size, test_size) :: data = cmplx(0.0_${kind}$, 0.0_${kind}$, kind=${kind}$)
    contains
        private
        procedure, pass(self), public :: matvec  => matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => rmatvec_${type[0]}$${kind}$
    end type

    type, extends(abstract_hermitian_linop_${type[0]}$${kind}$), public :: hermitian_linop_${type[0]}$${kind}$
        ${type}$, dimension(test_size, test_size) :: data = cmplx(0.0_${kind}$, 0.0_${kind}$, kind=${kind}$)
    contains
        private
        procedure, pass(self), public :: matvec => hermitian_matvec_${type[0]}$${kind}$
        procedure, pass(self), public :: rmatvec => hermitian_matvec_${type[0]}$${kind}$
    end type
    #:endif

    #:endfor

    ! ROESSLER SYSTEM

    ! Mesh related parameters.
    real(dp), parameter :: a = 0.2
    real(dp), parameter :: b = 0.2
    real(dp), parameter :: c = 5.7

    type, extends(abstract_vector_rdp), public :: state_vector
       real(dp) :: x = 0.0_dp
       real(dp) :: y = 0.0_dp
       real(dp) :: z = 0.0_dp
    contains
       private
       procedure, pass(self), public :: zero
       procedure, pass(self), public :: dot
       procedure, pass(self), public :: scal
       procedure, pass(self), public :: axpby
       procedure, pass(self), public :: rand
       procedure, pass(self), public :: get_size
    end type state_vector

    type, extends(abstract_system_rdp), public :: roessler
    contains
       private
       procedure, pass(self), public :: eval => eval_roessler
    end type roessler

    type, extends(abstract_jacobian_linop_rdp), public :: jacobian
    contains
       private
       procedure, pass(self), public :: matvec => lin_roessler
       procedure, pass(self), public :: rmatvec => adj_lin_roessler
    end type jacobian

    interface get_data
        #:for kind, type in RC_KINDS_TYPES
        module procedure get_data_vec_${type[0]}$${kind}$
        module procedure get_data_vec_basis_${type[0]}$${kind}$
        module procedure get_data_linop_${type[0]}$${kind}$
        #:endfor
    end interface

    interface put_data
        #:for kind, type in RC_KINDS_TYPES
        module procedure put_data_vec_${type[0]}$${kind}$
        module procedure put_data_vec_basis_${type[0]}$${kind}$
        module procedure put_data_linop_${type[0]}$${kind}$
        #:endfor
    end interface

    interface init_rand
        #:for kind, type in RC_KINDS_TYPES
        module procedure init_rand_vec_${type[0]}$${kind}$
        module procedure init_rand_basis_${type[0]}$${kind}$
        module procedure init_rand_linop_${type[0]}$${kind}$
        #:if type[0] == "r"
        module procedure init_rand_spd_linop_${type[0]}$${kind}$
        #:else
        module procedure init_rand_hermitian_linop_${type[0]}$${kind}$
        #:endif
        #:endfor
    end interface

    interface get_err_str
        #:for kind, type in REAL_KINDS_TYPES
        module procedure get_err_str_${kind}$
        #:endfor
    end interface

contains
    
    !----------------------------------------------------------
    !-----     TYPE-BOUND PROCEDURES FOR TEST VECTORS     -----
    !----------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine init_zero_${type[0]}$${kind}$(self)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        self%data = 0.0_${kind}$
        return
    end subroutine init_zero_${type[0]}$${kind}$

    function dot_${type[0]}$${kind}$(self, vec) result(alpha)
        class(vector_${type[0]}$${kind}$), intent(in) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec
        ${type}$ :: alpha

        select type(vec)
        type is(vector_${type[0]}$${kind}$)
            alpha = dot_product(self%data, vec%data)
        end select
    end function dot_${type[0]}$${kind}$

    integer function get_size_${type[0]}$${kind}$(self) result(N)
        class(vector_${type[0]}$${kind}$), intent(in) :: self
        N = test_size
        return
    end function get_size_${type[0]}$${kind}$

    subroutine scal_${type[0]}$${kind}$(self, alpha)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        ${type}$, intent(in) :: alpha
        self%data = alpha * self%data
        return
    end subroutine scal_${type[0]}$${kind}$

    subroutine axpby_${type[0]}$${kind}$(self, alpha, vec, beta)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec
        ${type}$, intent(in) :: alpha, beta

        select type(vec)
        type is(vector_${type[0]}$${kind}$)
            self%data = alpha*self%data + beta*vec%data
        end select
        return
    end subroutine

    subroutine rand_${type[0]}$${kind}$(self, ifnorm)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        logical, optional, intent(in) :: ifnorm
        logical :: normalized
        ${type}$ :: mu(test_size), var(test_size)
        ${type}$ :: alpha
 
        mu = 0.0_${kind}$
        #:if type[0] == "r"
        var = 1.0_${kind}$
        #:else
        var = cmplx(1.0_${kind}$, 1.0_${kind}$, kind=${kind}$)
        #:endif
        self%data = normal(mu, var)
 
        normalized = optval(ifnorm, .false.)
        if (normalized) then
            alpha = self%norm()
            call self%scal(1.0_${kind}$/alpha)
        endif
    end subroutine rand_${type[0]}$${kind}$

    #:endfor

    !---------------------------------------------------------
    !-----     TYPE-BOUND PROCEDURES FOR TEST LINOPS     -----
    !---------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine matvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(linop_${type[0]}$${kind}$), intent(in)  :: self
        class(abstract_vector_${type[0]}$${kind}$)       , intent(in)  :: vec_in
        class(abstract_vector_${type[0]}$${kind}$)       , intent(out) :: vec_out

        select type(vec_in)
        type is(vector_${type[0]}$${kind}$)
            select type(vec_out)
            type is(vector_${type[0]}$${kind}$)

            vec_out%data = matmul(self%data, vec_in%data)

            end select
        end select

        return
    end subroutine matvec_${type[0]}$${kind}$

    subroutine rmatvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(linop_${type[0]}$${kind}$), intent(in)  :: self
        class(abstract_vector_${type[0]}$${kind}$)       , intent(in)  :: vec_in
        class(abstract_vector_${type[0]}$${kind}$)       , intent(out) :: vec_out

        select type(vec_in)
        type is(vector_${type[0]}$${kind}$)
            select type(vec_out)
            type is(vector_${type[0]}$${kind}$)

            #:if type[0] == "c"
            vec_out%data = matmul(transpose(conjg(self%data)), vec_in%data)
            #:else
            vec_out%data = matmul(transpose(self%data), vec_in%data)
            #:endif

            end select
        end select

        return
    end subroutine rmatvec_${type[0]}$${kind}$

    #:if type[0] == "r"
    subroutine sdp_matvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(spd_linop_${type[0]}$${kind}$), intent(in)  :: self
        class(abstract_vector_${type[0]}$${kind}$)       , intent(in)  :: vec_in
        class(abstract_vector_${type[0]}$${kind}$)       , intent(out) :: vec_out

        select type(vec_in)
        type is(vector_${type[0]}$${kind}$)
            select type(vec_out)
            type is(vector_${type[0]}$${kind}$)

            vec_out%data = matmul(self%data, vec_in%data)

            end select
        end select

        return
    end subroutine sdp_matvec_${type[0]}$${kind}$
    #:else
    subroutine hermitian_matvec_${type[0]}$${kind}$(self, vec_in, vec_out)
        class(hermitian_linop_${type[0]}$${kind}$), intent(in)  :: self
        class(abstract_vector_${type[0]}$${kind}$)       , intent(in)  :: vec_in
        class(abstract_vector_${type[0]}$${kind}$)       , intent(out) :: vec_out

        select type(vec_in)
        type is(vector_${type[0]}$${kind}$)
            select type(vec_out)
            type is(vector_${type[0]}$${kind}$)

            vec_out%data = matmul(self%data, vec_in%data)

            end select
        end select

        return
    end subroutine hermitian_matvec_${type[0]}$${kind}$
   #:endif

    #:endfor

    !----------------------------------------------------
    !-----     EXTRACT DATA FROM ABSTRACT TYPES     -----
    !----------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine get_data_vec_${type[0]}$${kind}$(vec_out, vec_in)
        ${type}$, intent(out) :: vec_out(:)
        type(vector_${type[0]}$${kind}$), intent(in) :: vec_in
        vec_out = vec_in%data
        return
    end subroutine get_data_vec_${type[0]}$${kind}$

    subroutine get_data_vec_basis_${type[0]}$${kind}$(basis_out, basis_in)
        ${type}$, intent(out) :: basis_out(:, :)
        type(vector_${type[0]}$${kind}$), intent(in) :: basis_in(:)
        ! Internal variables.
        integer :: k
        do k = 1, size(basis_in)
            basis_out(:, k) = basis_in(k)%data
        enddo
        return
    end subroutine get_data_vec_basis_${type[0]}$${kind}$

    subroutine get_data_linop_${type[0]}$${kind}$(mat_out, linop_in)
        ${type}$, intent(out) :: mat_out(:, :)
        type(linop_${type[0]}$${kind}$), intent(in) :: linop_in
        mat_out = linop_in%data
        return
    end subroutine get_data_linop_${type[0]}$${kind}$

    #:endfor

    !----------------------------------------------
    !-----     PUT DATA TO ABSTRACT TYPES     -----
    !----------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine put_data_vec_${type[0]}$${kind}$(vec_out, vec_in)
        type(vector_${type[0]}$${kind}$), intent(out) :: vec_out
        ${type}$, intent(in) :: vec_in
        vec_out%data = vec_in
        return
    end subroutine put_data_vec_${type[0]}$${kind}$

    subroutine put_data_vec_basis_${type[0]}$${kind}$(basis_out, basis_in)
        type(vector_${type[0]}$${kind}$), intent(out) :: basis_out(:)
        ${type}$, intent(in) :: basis_in(:, :)
        ! Internal variables.
        integer :: k
        do k = 1, size(basis_out)
            basis_out(k)%data = basis_in(:, k)
        enddo
        return
    end subroutine put_data_vec_basis_${type[0]}$${kind}$

    subroutine put_data_linop_${type[0]}$${kind}$(linop_out, mat_in)
        type(linop_${type[0]}$${kind}$), intent(out) :: linop_out
        ${type}$, intent(in) :: mat_in(:, :)
        ! Internal variables.
        linop_out%data = mat_in
        return
    end subroutine put_data_linop_${type[0]}$${kind}$

    #:endfor

    !--------------------------------------------------------------
    !-----     INITIALIZE ABSTRACT TYPES WITH RANDOM DATA     -----
    !--------------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine init_rand_vec_${type[0]}$${kind}$(x)
        type(vector_${type[0]}$${kind}$), intent(inout) :: x
        call x%rand()
        return
    end subroutine init_rand_vec_${type[0]}$${kind}$

    subroutine init_rand_basis_${type[0]}$${kind}$(X)
        type(vector_${type[0]}$${kind}$), intent(inout) :: X(:)
        integer :: i
        do i = 1, size(X)
            call X(i)%rand()
        enddo
        return
    end subroutine init_rand_basis_${type[0]}$${kind}$

    subroutine init_rand_linop_${type[0]}$${kind}$(linop)
        type(linop_${type[0]}$${kind}$), intent(inout) :: linop
        ${type}$, allocatable :: mu(:, :), var(:, :)
        allocate(mu(test_size, test_size)) ; mu = 0.0_${kind}$
        allocate(var(test_size, test_size))
        #:if type[0] == "r"
        var = 1.0_${kind}$
        #:else
        var = cmplx(1.0_${kind}$, 1.0_${kind}$, kind=${kind}$)
        #:endif
        linop%data = normal(mu, var)
        return
    end subroutine init_rand_linop_${type[0]}$${kind}$

    #:if type[0] == "r"
    subroutine init_rand_spd_linop_${type[0]}$${kind}$(linop)
        type(spd_linop_${type[0]}$${kind}$), intent(inout) :: linop
        ${type}$, allocatable :: mu(:, :), var(:, :)
        ${type}$, allocatable :: data(:, :)
        allocate(mu(test_size, test_size)) ; mu = zero_${type[0]}$${kind}$
        allocate(var(test_size, test_size)) ; var = one_${type[0]}$${kind}$

        data = normal(mu, var)
        linop%data = matmul(data, transpose(data))/test_size + 0.01*eye(test_size)

        return
    end subroutine init_rand_spd_linop_${type[0]}$${kind}$
    #:else
    subroutine init_rand_hermitian_linop_${type[0]}$${kind}$(linop)
        type(hermitian_linop_${type[0]}$${kind}$), intent(inout) :: linop
        ${type}$, allocatable :: data(:, :)
        ${type}$, allocatable :: mu(:, :), var(:, :)

        allocate(mu(test_size, test_size)) ; mu = 0.0_${kind}$
        allocate(var(test_size, test_size)) ; var = cmplx(1.0_${kind}$, 1.0_${kind}$, kind=${kind}$)

        data = normal(mu, var)
        data = matmul(data, transpose(conjg(data)))/test_size + 0.01*eye(test_size)
        linop%data = data

        return
    end subroutine init_rand_hermitian_linop_${type[0]}$${kind}$
    #:endif

    #:endfor

    #:for kind, type in REAL_KINDS_TYPES
    subroutine get_err_str_${kind}$(msg, info, err)
      character(len=*), intent(inout) :: msg
      character(len=*), intent(in)    :: info
      real(${kind}$) :: err

      ! internals
      character*8 :: value_str
      character(len=*), parameter :: indent = repeat(" ", 4)

      write(value_str, '(E8.2)') err
      msg = indent // info // value_str // achar(10)
       
    end subroutine get_err_str_${kind}$
    #:endfor

    !-----------------------------------------------
    !-----     ROESSLER SYSTEM TYPE DEFINITION     -----
    !-----------------------------------------------
 
    subroutine zero(self)
      class(state_vector), intent(inout) :: self
      self%x = 0.0_dp
      self%y = 0.0_dp
      self%z = 0.0_dp
      return
    end subroutine zero
  
    real(dp) function dot(self, vec) result(alpha)
      class(state_vector)       , intent(in) :: self
      class(abstract_vector_rdp), intent(in) :: vec
      select type(vec)
      type is(state_vector)
         alpha = self%x*vec%x + self%y*vec%y + self%z*vec%z
      end select
      return
    end function dot
  
    subroutine scal(self, alpha)
      class(state_vector), intent(inout) :: self
      real(dp)           , intent(in)    :: alpha
      self%x = self%x * alpha
      self%y = self%y * alpha
      self%z = self%z * alpha
      return
    end subroutine scal
  
    subroutine axpby(self, alpha, vec, beta)
      class(state_vector)       , intent(inout) :: self
      class(abstract_vector_rdp), intent(in)    :: vec
      real(dp)                  , intent(in)    :: alpha, beta
      select type(vec)
      type is(state_vector)
         self%x = alpha*self%x + beta*vec%x
         self%y = alpha*self%y + beta*vec%y
         self%z = alpha*self%z + beta*vec%z
      end select
      return
    end subroutine axpby
  
    integer function get_size(self) result(N)
      class(state_vector), intent(in) :: self
      N = 3
      return
    end function get_size
  
    subroutine rand(self, ifnorm)
      class(state_vector), intent(inout) :: self
      logical, optional,   intent(in)    :: ifnorm
      logical :: normalized
      real(dp) :: mu, var
      real(dp) :: alpha
  
      mu = 0.0_dp
      var = 1.0_dp
      self%x = normal(mu, var)
      self%y = normal(mu, var)
      self%z = normal(mu, var)
  
      normalized = optval(ifnorm, .false.)
      if (normalized) then
         alpha = self%norm()
         call self%scal(1.0_dp/alpha)
      endif
      return
    end subroutine rand

    subroutine eval_roessler(self, vec_in, vec_out)
      class(roessler),            intent(in)  :: self
      class(abstract_vector_rdp), intent(in)  :: vec_in
      class(abstract_vector_rdp), intent(out) :: vec_out

      select type(vec_in)
        type is(state_vector)
            select type(vec_out)
            type is(state_vector)

            vec_out%x = -vec_in%y - vec_in%z
            vec_out%y = vec_in%x + a * vec_in%y
            vec_out%z = b + vec_in%z * (vec_in%x - c)

            end select
        end select

      return
    end subroutine eval_roessler

    subroutine lin_roessler(self, vec_in, vec_out)
      class(jacobian),            intent(in)  :: self
      class(abstract_vector_rdp), intent(in)  :: vec_in
      class(abstract_vector_rdp), intent(out) :: vec_out

      select type(vec_in)
      type is(state_vector)
         select type(vec_out)
         type is(state_vector)

            vec_out%x = -vec_in%y - vec_in%z
            vec_out%y =  vec_in%x + a*vec_in%y
            vec_out%z =  vec_in%x*self%X%z + vec_in%z*(self%X%x - c)

         end select
      end select

      return
    end subroutine lin_roessler

    subroutine adj_lin_roessler(self, vec_in, vec_out)
      class(jacobian),            intent(in)  :: self
      class(abstract_vector_rdp), intent(in)  :: vec_in
      class(abstract_vector_rdp), intent(out) :: vec_out

      select type(vec_in)
      type is(state_vector)
         select type(vec_out)
         type is(state_vector)

            vec_out%x =  vec_in%y + vec_in%z*self%X%z
            vec_out%y = -vec_in%x + a*vec_in%y
            vec_out%z = -vec_in%x + vec_in%z*(self%X%x - c)

         end select
      end select

      return
    end subroutine adj_lin_roessler
    
end module LightKrylov_TestUtils
