#:include "../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module lightkrylov_utils
    !--------------------------------------------
    !-----     Standard Fortran Library     -----
    !--------------------------------------------
    use iso_fortran_env, only: output_unit
    use stdlib_linalg, only: is_hermitian, is_symmetric, diag, svd
    ! Matrix inversion.
    use stdlib_linalg_lapack, only: getrf, getri
    ! Eigenvalue problem (general + symmetric).
    use stdlib_linalg_lapack, only: geev, syev, heev
    ! Schur factorization.
    use stdlib_linalg_lapack, only: gees, trsen

    !-------------------------------
    !-----     LightKrylov     -----
    !-------------------------------
    ! Various constants.
    use LightKrylov_Logger
    use LightKrylov_Constants

    implicit none
    private

    character(len=128), parameter :: this_module = 'LightKrylov_Utils'

    public :: assert_shape, norml, log2
    ! Compute B = inv(A) in-place for dense matrices.
    public :: inv
    ! Compute AX = XD for general dense matrices.
    public :: eig
    ! Compute AX = XD for symmetric/hermitian matrices.
    public :: eigh
    ! Compute matrix sqrt of input symmetric/hermitian positive definite matrix A
    public :: sqrtm
    public :: sqrtm_eig
    ! Compute AX = XS where S is in Schur form.
    public :: schur
    ! Re-orders the Schur factorization of A.
    public :: ordschur

    interface assert_shape
        #:for kind, type in RC_KINDS_TYPES
        module procedure assert_shape_vector_${type[0]}$${kind}$
        module procedure assert_shape_matrix_${type[0]}$${kind}$
        #:endfor
    end interface

    interface norml
        #:for kind, type in RC_KINDS_TYPES
        module procedure norml_${type[0]}$${kind}$
        #:endfor
    end interface

    interface log2
        #:for kind, type in REAL_KINDS_TYPES
        module procedure log2_${type[0]}$${kind}$
        #:endfor
    end interface

    interface inv
        #:for kind, type in RC_KINDS_TYPES
        module procedure inv_${type[0]}$${kind}$
        #:endfor
    end interface

    interface eig
        #:for kind, type in RC_KINDS_TYPES
        module procedure eig_${type[0]}$${kind}$
        #:endfor
    end interface

   interface eigh
        #:for kind, type in RC_KINDS_TYPES
        module procedure eigh_${type[0]}$${kind}$
        #:endfor
    end interface

    interface schur
        #:for kind, type in RC_KINDS_TYPES
        module procedure schur_${type[0]}$${kind}$
        #:endfor
    end interface

    interface ordschur
        #:for kind, type in RC_KINDS_TYPES
        module procedure ordschur_${type[0]}$${kind}$
        #:endfor
    end interface

    interface sqrtm
        #:for kind, type in RC_KINDS_TYPES
        module procedure sqrtm_${type[0]}$${kind}$
        #:endfor
    end interface

    interface sqrtm_eig
        #:for kind, type in RC_KINDS_TYPES
        module procedure sqrtm_eig_${type[0]}$${kind}$
        #:endfor
    end interface

    !------------------------------------------------
    !-----     OPTS TYPE FOR LINEAR SOLVERS     -----
    !------------------------------------------------

    type, abstract, public :: abstract_opts
        !! Abstract type container for options from which all other are being extended.
    end type

    #:for kind in REAL_KINDS
    type, extends(abstract_opts), public :: gmres_${kind}$_opts
        !! GMRES options.
        integer :: kdim = 30
        !! Dimension of the Krylov subspace (default: 30).
        integer :: maxiter = 10
        !! Maximum number of `gmres` restarts (default: 10).
        real(${kind}$) :: atol = atol_${kind}$
        !! Absolute tolerance.
        real(${kind}$) :: rtol = rtol_${kind}$
        !! Relative tolerance.
        logical :: verbose = .false.
        !! Verbosity control (default: `.false.`)
    end type

    type, extends(abstract_opts), public :: cg_${kind}$_opts
        !! Conjugate gradient options.
        integer :: maxiter = 100
        !! Maximum number of `cg` iterations (default: 100).
        real(${kind}$) :: atol = atol_${kind}$
        !! Absolute tolerance.
        real(${kind}$) :: rtol = rtol_${kind}$
        !! Relative tolerance.
        logical :: verbose = .false.
        !! Verbosity control (default: `.false.`)
    end type

    #:endfor

contains

    !-------------------------------------
    !-----     VARIOUS UTILITIES     -----
    !-------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine assert_shape_vector_${type[0]}$${kind}$(v, size, routine, matname)
        !! Utility function to assert the shape of a vector.
        ${type}$, intent(in) :: v(:)
        !! Vector whose dimension need to be asserted.
        integer, intent(in) :: size(:)
        !! Expected dimensions of v.
        character(len=*), intent(in) :: routine
        !! Name of the routine where assertion is done.
        character(len=*), intent(in) :: matname
        !! Name of the asserted vector.
        
        ! internals
        character(len=256) :: msg

        if(any(shape(v) /= size)) then
            write(msg, *) "In routine "//routine//" vector "//matname//" has illegal length ", shape(v), &
                           & ". Expected length is ", size, ". Aborting due to illegal vector length."
            call stop_error(msg, module=this_module, procedure='assert_shape_vector_${type[0]}$${kind}$')
        endif
        return
    end subroutine assert_shape_vector_${type[0]}$${kind}$

    subroutine assert_shape_matrix_${type[0]}$${kind}$(A, size, routine, matname)
        !! Utility function to assert the shape of a matrix.
        ${type}$, intent(in) :: A(:, :)
        !! Matrix whose dimension need to be asserted.
        integer, intent(in) :: size(:)
        !! Expected dimensions of A.
        character(len=*), intent(in) :: routine
        !! Name of the routine where assertion is done.
        character(len=*), intent(in) :: matname
        !! Name of the asserted matrix.

        ! internals
        character(len=256) :: msg

        if(any(shape(A) /= size)) then
            write(msg, *) "In routine "//routine//" matrix "//matname//" has illegal shape ", shape(A), &
                        & ". Expected shape is ", size, ". Aborting due to illegal vector length."
            call stop_error(msg, module=this_module, procedure='assert_shape_vector_${type[0]}$${kind}$')
        endif
        return
    end subroutine assert_shape_matrix_${type[0]}$${kind}$
    #:endfor

    !-------------------------------------------
    !-----     LAPACK MATRIX INVERSION     -----
    !-------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine inv_${type[0]}$${kind}$(A)
        !! In-place inversion of A using LAPACK.
        ${type}$, intent(inout) :: A(:, :)
        !! Matrix to be inverted (in-place).

        ! Internal variables.
        integer :: n, info
        ${type}$ :: work(size(A, 1))
        integer  :: ipiv(size(A, 1))

        ! Compute A = LU (in-place).
        n = size(A, 1) ; call assert_shape(A, [n, n], "inv", "A")
        call getrf(n, n, A, n, ipiv, info)
        call check_info(info, 'GETREF', module=this_module, procedure='inv_${type[0]}$${kind}$')

        ! Compute inv(A) (in-place).
        call getri(n, A, n, ipiv, work, n, info)
        call check_info(info, 'GETRI', module=this_module, procedure='inv_${type[0]}$${kind}$')

        return
    end subroutine inv_${type[0]}$${kind}$

    subroutine eig_${type[0]}$${kind}$(A, vecs, vals)
        !! Eigenvalue decomposition of a dense matrix using LAPACK.
        ${type}$, intent(in) :: A(:, :)
        !! Matrix to be factorized.
        #:if type[0] == "c"
        ${type}$, intent(out) :: vecs(:, :)
        #:else
        real(${kind}$), intent(out) :: vecs(:, :)
        #:endif
        !! Eigenvectors.
        complex(${kind}$), intent(out) :: vals(:)

        ! Internal variables
        character :: jobvl = "n", jobvr = "v"
        integer :: n, lwork, info, lda, ldvl, ldvr
        #:if type[0] == "c"
        ${type}$ :: A_tilde(size(A, 1), size(A, 2)), vl(1, size(A, 1))
        ${type}$ :: work(2*size(A, 1))
        real(${kind}$) :: rwork(2*size(A, 1))
        #:else
        ${type}$ :: A_tilde(size(A, 1), size(A, 2)), vl(1, size(A, 2))
        ${type}$ :: work(4*size(A, 1)), wr(size(A, 1)), wi(size(A, 1))
        #:endif

        ! Setup variables.
        n = size(A, 1) ; lda = n ; ldvl = 1 ; ldvr = n ; a_tilde = a
        #:if type[0] == "c"
        lwork = 2*n
        #:else
        lwork = 4*n
        #:endif

        ! Eigendecomposition.
        #:if type[0] == "c"
        call geev(jobvl, jobvr, n, a_tilde, lda, vals, vl, ldvl, vecs, ldvr, work, lwork, rwork, info)
        #:else
        call geev(jobvl, jobvr, n, a_tilde, lda, wr, wi, vl, ldvl, vecs, ldvr, work, lwork, info)
        #:endif
        call check_info(info, 'GEEV', module=this_module, procedure='eig_${type[0]}$${kind}$')

        #:if type[0] == "r"
        ! Reconstruct eigenvalues
        vals = one_c${kind}$*wr + one_im_c${kind}$*wi
        #:endif

        return
    end subroutine eig_${type[0]}$${kind}$

    subroutine eigh_${type[0]}$${kind}$(A, vecs, vals)
        !! Eigenvalue decomposition of a dense symmetric/hermitian matrix using LAPACK.
        ${type}$, intent(in) :: A(:, :)
        !! Matrix to be factorized.
        ${type}$, intent(out) :: vecs(:, :)
        !! Eigenvectors.
        real(${kind}$), intent(out) :: vals(:)
        !! Eigenvalues.

        ! Internal variables.
        character :: jobz = "v", uplo = "u"
        integer :: n, lwork, info, lda
        ${type}$ :: A_tilde(size(A, 1), size(A, 2))
        ${type}$, allocatable :: work(:)
        #:if type[0] == "c"
        real(${kind}$), allocatable :: rwork(:)
        #:endif

        ! Setup variables.
        n = size(A, 1) ; lda = n ; a_tilde = a
        #:if type[0] == "c"
        lwork = max(1, 2*n-1)
        allocate(rwork(max(1, 3*n-2)))
        #:else
        lwork = max(1, 3*n-1)
        #:endif
        allocate(work(lwork))

        ! Eigendecomposition.
        #:if type[0] == "r"
        call syev(jobz, uplo, n, a_tilde, lda, vals, work, lwork, info)
        call check_info(info, 'SYEV', module=this_module, procedure='eigh_${type[0]}$${kind}$')
        #:else
        call heev(jobz, uplo, n, a_tilde, lda, vals, work, lwork, rwork, info)
        call check_info(info, 'HEEV', module=this_module, procedure='eigh_${type[0]}$${kind}$')
        #:endif

        ! Extract eigenvectors
        vecs = a_tilde

        return
    end subroutine eigh_${type[0]}$${kind}$

    subroutine schur_${type[0]}$${kind}$(A, Z, eigvals)
        !! Compute the Schur form (in-place) and Schur vectors of the matrix `A`.
        ${type}$, intent(inout) :: A(:, :)
        !! Matrix to be factorized.
        ${type}$, intent(out) :: Z(:, :)
        !! Schur basis.
        complex(${kind}$), intent(out) :: eigvals(:)
        !! Eigenvalues.

        ! Internal variables.
        character :: jobvs = "v", sort = "n"
        integer :: n, lda, sdim, ldvs, lwork, info
        logical, allocatable :: bwork(:)
        ${type}$, allocatable :: work(:)
        #:if type[0] == "r"
        ${type}$, allocatable :: wr(:), wi(:)
        #:else
        real(${kind}$), allocatable :: rwork(:)
        #:endif

        ! Allocate variables.
        n = size(A, 1) ; lda = n ; ldvs = n ; lwork = #{if type[0] == "r"}# 3*n #{else}# 2*n #{endif}#
        allocate(bwork(n)) ; allocate(work(lwork)) ; #{if type[0] == "c"}# allocate(rwork(n)) #{endif}#

        #:if type[0] == "r"
        allocate(wr(size(eigvals)), wi(size(eigvals)))
        call gees(jobvs, sort, dummy_select, n, A, lda, sdim, wr, wi, Z, ldvs, work, lwork, bwork, info)
        #:else
        call gees(jobvs, sort, dummy_select, n, A, lda, sdim, eigvals, Z, ldvs, work, lwork, rwork, bwork, info)
        #:endif
        call check_info(info, 'GEES', module=this_module, procedure='schur_${type[0]}$${kind}$')

        #:if type[0] == "r"
        ! Reconstruct eigenvalues
        eigvals = cmplx(wr, wi, kind=${kind}$)
        #:endif

        return
    contains
        #:if type[0] == "r"
        pure function dummy_select(wr, wi) result(out)
            ${type}$, intent(in) :: wr
            ${type}$, intent(in) :: wi
            logical :: out
            out = .false.
            return
        end function
        #:else
        pure function dummy_select(w) result(out)
            ${type}$, intent(in) :: w
            logical :: out
            out = .false.
            return
        end function
        #:endif
    end subroutine schur_${type[0]}$${kind}$

    subroutine ordschur_${type[0]}$${kind}$(T, Q, selected)
        !! Re-order the Schur factorization from `schur` such that the selected eigenvalues
        !! are in the upper-left block.
        ${type}$, intent(inout) :: T(:, :)
        !! Schur matrix to be re-ordered.
        ${type}$, intent(inout) :: Q(:, :)
        !! Schur vectors to be re-ordered.
        logical, intent(in) :: selected(:)
        !! Boolean array defining the selected eigenvalues.

        ! Internal variables
        character :: job="n", compq="v"
        integer info, ldq, ldt, lwork, m, n
        real(${kind}$) :: s, sep
        #:if type[0] == "r"
        integer :: iwork(size(T, 1)), liwork
        ${type}$ :: wi(size(T, 1)), wr(size(T, 1)), work(size(T, 1))
        #:else
        ${type}$ :: w(size(T, 1)), work(size(T, 1))
        #:endif

        ! Setup variables.
        n = size(T, 2) ; ldt = n ; ldq = n ; lwork = max(1, n)

        #:if type[0] == "r"
        liwork = 1
        call trsen(job, compq, selected, n, T, ldt, Q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork, info)
        #:else
        call trsen(job, compq, selected, n, T, ldt, Q, ldq, w, m, s, sep, work, lwork, info)
        #:endif
        call check_info(info, 'TRSEN', module=this_module, procedure='ordschur_${type[0]}$${kind}$')

        return
    end subroutine ordschur_${type[0]}$${kind}$

    subroutine sqrtm_${type[0]}$${kind}$(X, sqrtmX, info)
      !! Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices
      ${type}$, intent(inout) :: X(:,:)
      !! Matrix of which to compute the sqrt
      ${type}$, intent(out)   :: sqrtmX(size(X,1),size(X,1))
      !! Return matrix
      integer, intent(out) :: info
      !! Information flag

      ! internal
      real(${kind}$) :: S(size(X,1))
      ${type}$ :: U(size(X,1), size(X,1)), VT(size(X,1), size(X,1))
      integer :: i
      real(${kind}$) :: symmetry_error
      character(len=128) :: msg

      info = 0

      #:if type[0] == "r"
      ! Check if the matrix is symmetric
      symmetry_error = 0.5*maxval(X - transpose(X))
      if (symmetry_error > rtol_${kind}$) then
        write(msg,*) "Input matrix is not symmetric. 0.5*max(X-X.T) = ", &
            & symmetry_error, ", tol = ", rtol_${kind}$
        call stop_error(msg, module=this_module, procedure='sqrtm_${type[0]}$${kind}$')
      else if (symmetry_error > 10*atol_${kind}$) then
        write(msg,*) "Input matrix is not exactly symmetric. 0.5*max(X-X.T) = ", symmetry_error
        call logger%log_warning(trim(msg), module=this_module, procedure='sqrtm_${type[0]}$${kind}$')
      end if
      #:else
      ! Check if the matrix is hermitian
      symmetry_error = 0.5*maxval(abs(X - conjg(transpose(X))))
      if (symmetry_error > rtol_${kind}$) then
        write(msg,*) "Input matrix is not hermitian. 0.5*max(abs(X-X.H)) = ", &
            & symmetry_error, ", tol = ", rtol_${kind}$
        call stop_error(msg, module=this_module, procedure='sqrtm_${type[0]}$${kind}$')
      else if (symmetry_error > 10*atol_${kind}$) then
        write(msg,*) "Input matrix is not exactly hermitian. 0.5*max(X-X.T) = ", symmetry_error
        call logger%log_warning(trim(msg), module=this_module, procedure='sqrtm_${type[0]}$${kind}$')
      end if
      #:endif

      ! Perform svd
      call svd(X, S, U, VT)

      ! Check if the matrix is positive definite (up to tol)
      do i = 1, size(S)
         if (S(i) .gt. 10*atol_${kind}$ ) then
            S(i) = sqrt(S(i))
         else
            S(i) = zero_r${kind}$
            info = 1
         end if
      end do

      ! Reconstruct the square root matrix
      sqrtmX = matmul(U, matmul(diag(S), VT))

      return
    end subroutine

    subroutine sqrtm_eig_${type[0]}$${kind}$(X, sqrtmX, info)
      !! Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices
      ${type}$, intent(in)  :: X(:,:)
      !! Matrix of which to compute the sqrt
      ${type}$, intent(out) :: sqrtmX(size(X,1),size(X,1))
      !! Return matrix
      integer, intent(out) :: info
      !! Information flag

      ! internals
      real(${kind}$) :: lambda(size(X,1))
      ${type}$ :: V(size(X,1), size(X,1))
      integer :: i
      character(len=128) :: msg

      info = 0

      #:if type[0] == "r"
      ! Check if the matrix is symmetric
      if (.not. is_symmetric(X)) then
        write(msg,*) "Input matrix is not symmetric."
        call stop_error(msg, module=this_module, procedure='sqrtm_${type[0]}$${kind}$')
      end if
      #:else
      ! Check if the matrix is hermitian
      if (.not. is_hermitian(X)) then
        write(msg,*) "Input matrix is not hermitian"
        call stop_error(msg, module=this_module, procedure='sqrtm_${type[0]}$${kind}$')
      end if
      #:endif

      ! Perform eigenvalue decomposition
      call eigh(X, V, lambda)

      ! Check if the matrix is positive definite (up to tol)
      do i = 1, size(lambda)
         if (abs(lambda(i)) .gt. 10*atol_${kind}$ ) then
            if (lambda(i) .gt. zero_r${kind}$) then
               lambda(i) = sqrt(lambda(i))
            else
               lambda(i) = zero_r${kind}$
               info = -1
            end if
         else
            lambda(i) = zero_r${kind}$
            info = 1
         end if
      end do

      ! Reconstruct the square root matrix
      #:if type[0] == "r"
      sqrtmX = matmul(V, matmul(diag(lambda), transpose(V)))
      #:else
      sqrtmX = matmul(V, matmul(diag(lambda), conjg(transpose(V))))
      #:endif

      return
    end subroutine
    #:endfor

    !---------------------------------
    !-----     MISCELLANEOUS     -----
    !---------------------------------

    #:for kind, type in RC_KINDS_TYPES
    #:if type[0] == "r"
    real(${kind}$) function log2_${type[0]}$${kind}$(x) result(y)
        ${type}$, intent(in) :: x
        y = log(x) / log(2.0_${kind}$)
    end function
    #:endif

    real(${kind}$) function norml_${type[0]}$${kind}$(A) result(norm)
        ${type}$, intent(in) :: A(:, :)
        integer :: i, n
        real(${kind}$) :: row_sum

        norm = zero_r${kind}$
        n = size(A, 1)
        do i = 1, n
            row_sum = sum(abs(A(i, :)))
            norm = max(norm, row_sum)
        enddo
    end function

    #:endfor

end module lightkrylov_utils
