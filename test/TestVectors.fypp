#:include "../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module TestVectors
    use LightKrylov
    use LightKrylov_Logger
    use testdrive, only: new_unittest, unittest_type, error_type, check
    use stdlib_math, only: is_close, all_close
    use stdlib_optval, only: optval
    
    implicit none
    
    private

    character*128, parameter, private :: this_module = 'LightKrylov_TestVectors'

    integer, parameter, public :: test_size = 128

    #:for kind, type in RC_KINDS_TYPES
    public :: collect_vector_${type[0]}$${kind}$_testsuite
    #:endfor

    #:for kind, type in RC_KINDS_TYPES
    type, extends(abstract_vector_${type[0]}$${kind}$), public :: vector_${type[0]}$${kind}$
        ${type}$, dimension(test_size) :: data = 0.0_${kind}$
    contains
        private
        procedure, pass(self), public :: zero => zero_${type[0]}$${kind}$
        procedure, pass(self), public :: dot => dot_${type[0]}$${kind}$
        procedure, pass(self), public :: scal => scal_${type[0]}$${kind}$
        procedure, pass(self), public :: axpby => axpby_${type[0]}$${kind}$
        procedure, pass(self), public :: rand => rand_${type[0]}$${kind}$
    end type vector_${type[0]}$${kind}$

    #:endfor
contains
    
    !--------------------------------------------------------------------
    !-----     DEFINITIONS OF THE VARIOUS TYPE-BOUND PROCEDURES     -----
    !--------------------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine zero_${type[0]}$${kind}$(self)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        self%data = 0.0_${kind}$
        return
    end subroutine zero_${type[0]}$${kind}$

    function dot_${type[0]}$${kind}$(self, vec) result(alpha)
        class(vector_${type[0]}$${kind}$), intent(in) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec
        ${type}$ :: alpha

        select type(vec)
        type is(vector_${type[0]}$${kind}$)
            alpha = dot_product(self%data, vec%data)
        end select
    end function dot_${type[0]}$${kind}$

    subroutine scal_${type[0]}$${kind}$(self, alpha)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        ${type}$, intent(in) :: alpha
        self%data = alpha * self%data
        return
    end subroutine scal_${type[0]}$${kind}$

    subroutine axpby_${type[0]}$${kind}$(self, alpha, vec, beta)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        class(abstract_vector_${type[0]}$${kind}$), intent(in) :: vec
        ${type}$, intent(in) :: alpha, beta

        select type(vec)
        type is(vector_${type[0]}$${kind}$)
            self%data = alpha*self%data + beta*vec%data
        end select
        return
    end subroutine

    subroutine rand_${type[0]}$${kind}$(self, ifnorm)
        class(vector_${type[0]}$${kind}$), intent(inout) :: self
        logical, optional, intent(in) :: ifnorm
        logical :: normalized
        ${type}$ :: alpha
        #:if type[0] == "c"
        real(${kind}$), dimension(test_size, 2) :: data

        call random_number(data)
        self%data%re = data(:, 1)
        self%data%im = data(:, 2)
        #:else
        call random_number(self%data)
        #:endif

        normalized = optval(ifnorm, .false.)
        if (normalized) then
            alpha = self%norm()
            call self%scal(1.0_${kind}$/alpha)
        endif
    end subroutine rand_${type[0]}$${kind}$

    #:endfor
    
    !---------------------------------------------------------
    !-----     DEFINITIONS OF THE VARIOUS UNIT TESTS     -----
    !---------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine collect_vector_${type[0]}$${kind}$_testsuite(testsuite)
        type(unittest_type), allocatable, intent(out) :: testsuite(:)

        testsuite = [ &
                    new_unittest("Vector norm", test_vector_${type[0]}$${kind}$_norm)      , &
                    new_unittest("Vector scale", test_vector_${type[0]}$${kind}$_scal)     , &
                    new_unittest("Vector addition", test_vector_${type[0]}$${kind}$_add)   , &
                    new_unittest("Vector subtraction", test_vector_${type[0]}$${kind}$_sub), &
                    new_unittest("Vector dot product", test_vector_${type[0]}$${kind}$_dot)  &
                    ]
        return
    end subroutine collect_vector_${type[0]}$${kind}$_testsuite

    subroutine test_vector_${type[0]}$${kind}$_norm(error)
        ! Error type to be returned.
        type(error_type), allocatable, intent(out) :: error
        ! Test vector.
        type(vector_${type[0]}$${kind}$), allocatable :: x
        real(${kind}$) :: alpha

        ! Initialize vector.
        x = vector_${type[0]}$${kind}$() ; call x%rand()
        
        ! Compute its norm.
        alpha = x%norm()

        ! Check result.
        #:if type[0] == "c"
        call check(error, is_close(alpha, sqrt(sum(x%data%re**2 + x%data%im**2))))
        #:else
        call check(error, is_close(alpha, norm2(x%data)))
        #:endif
        call check_test(error, 'test_vector_${type[0]}$${kind}$_norm', 'is_close(alpha, norm2(x%data))')
        
        return
    end subroutine test_vector_${type[0]}$${kind}$_norm

    subroutine test_vector_${type[0]}$${kind}$_add(error)
        ! Error type to be returned.
        type(error_type), allocatable, intent(out) :: error

        ! Test vectors.
        type(vector_${type[0]}$${kind}$), allocatable :: x, y, z

        ! Initialize vectors.
        x = vector_${type[0]}$${kind}$() ; call x%rand()
        y = vector_${type[0]}$${kind}$() ; call y%rand()
        z = x

        ! Vector addition.
        call z%add(y)

        ! Check correctness.
        #:if type[0] == "c"
        call check(error, sqrt(sum((z%data%re - x%data%re - y%data%re)**2 + (z%data%im - x%data%im - y%data%im)**2)) < rtol_${kind}$)
        #:else
        call check(error, norm2(z%data - x%data - y%data) < rtol_${kind}$)
        #:endif
        call check_test(error, 'test_vector_${type[0]}$${kind}$_add', 'norm2(z%data - x%data - y%data) < rtol')

        return
    end subroutine test_vector_${type[0]}$${kind}$_add
 
    subroutine test_vector_${type[0]}$${kind}$_sub(error)
        ! Error type to be returned.
        type(error_type), allocatable, intent(out) :: error

        ! Test vectors.
        type(vector_${type[0]}$${kind}$), allocatable :: x, y, z

        ! Initialize vectors.
        x = vector_${type[0]}$${kind}$() ; call x%rand()
        y = vector_${type[0]}$${kind}$() ; call y%rand()
        z = x

        ! Vector addition.
        call z%sub(y)

        ! Check correctness.
        #:if type[0] == "c"
        call check(error, sqrt(sum((z%data%re - x%data%re + y%data%re)**2 + (z%data%im - x%data%im + y%data%im)**2)) < rtol_${kind}$)
        #:else
        call check(error, norm2(z%data - x%data + y%data) < rtol_${kind}$)
        #:endif
        call check_test(error, 'test_vector_${type[0]}$${kind}$_sub', 'norm2(z%data - x%data + y%data) < rtol')

        return
    end subroutine test_vector_${type[0]}$${kind}$_sub

    subroutine test_vector_${type[0]}$${kind}$_dot(error)
        ! Error type to be returned.
        type(error_type), allocatable, intent(out) :: error

        ! Test vectors.
        type(vector_${type[0]}$${kind}$), allocatable :: x, y
        ${type}$ :: alpha

        ! Initialize vectors.
        x = vector_${type[0]}$${kind}$() ; call x%rand()
        y = vector_${type[0]}$${kind}$() ; call y%rand()

        ! Compute inner-product.
        alpha = x%dot(y)

        ! Check correctness.
        call check(error, abs(alpha - dot_product(x%data, y%data)) < rtol_${kind}$)
        call check_test(error, 'test_vector_${type[0]}$${kind}$_dot', 'abs(alpha - dot_product(x%data, y%data)) < rtol')

        return
    end subroutine test_vector_${type[0]}$${kind}$_dot

    subroutine test_vector_${type[0]}$${kind}$_scal(error)
        ! Error type to be returned.
        type(error_type), allocatable, intent(out) :: error

        ! Test vector.
        type(vector_${type[0]}$${kind}$), allocatable :: x, y
        ${type}$ :: alpha
        #:if type[0] == "c"
        ${type}$ :: tmp(test_size)
        #:endif

        ! Initialize vector.
        x = vector_${type[0]}$${kind}$() ; call x%rand()
        y = x
        #:if type[0] == "c"
        call random_number(alpha%re) ; call random_number(alpha%im)
        #:else
        call random_number(alpha)
        #:endif
        
        ! Scale the vector.
        call x%scal(alpha)

        ! Check correctness.
        #:if type[0] == "c"
        tmp = x%data - alpha*y%data
        call check(error, sqrt(sum(tmp%re**2 + tmp%im**2)) < rtol_${kind}$)
        #:else
        call check(error, norm2(x%data - alpha*y%data) < rtol_${kind}$)
        #:endif
        call check_test(error, 'test_vector_${type[0]}$${kind}$_scal', 'norm2(x%data - alpha*y%data) < rtol')

        return
    end subroutine test_vector_${type[0]}$${kind}$_scal

    #:endfor

end module TestVectors
