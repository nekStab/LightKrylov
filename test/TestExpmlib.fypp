#:include "../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module TestExpmlib
    ! Fortran Standard Library.
    use iso_fortran_env
    use stdlib_math, only: is_close, all_close
    use stdlib_linalg, only: eye, diag
    use stdlib_io_npy, only: save_npy

    ! LightKrylov
    use LightKrylov
    use LightKrylov_Constants
    use LightKrylov_Logger
    use LightKrylov_Utils, only : eig, sqrtm

    ! Testdrive
    use testdrive, only: new_unittest, unittest_type, error_type, check
    use TestVectors
    use TestLinops
    use TestUtils
    use TestKrylov

    implicit none

    private

    character*128, parameter, private :: this_module = 'LightKrylov_TestExpmLib'

    #:for kind, type in RC_KINDS_TYPES
    public :: collect_expm_${type[0]}$${kind}$_testsuite
    #:endfor

    #:for kind, type in RC_KINDS_TYPES
    public :: collect_sqrtm_${type[0]}$${kind}$_testsuite
    #:endfor

contains

    !--------------------------------------------------------------
    !-----     UNIT TESTS FOR DENSE MATRIX EXPONENTIATION     -----
    !--------------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine collect_expm_${type[0]}$${kind}$_testsuite(testsuite)
        type(unittest_type), allocatable, intent(out) :: testsuite(:)

        testsuite = [ &
                        new_unittest("Dense expm.", test_dense_expm_${type[0]}$${kind}$), &
                        new_unittest("Krylov expm.", test_kexptA_${type[0]}$${kind}$) &
                    ]

        return
    end subroutine collect_expm_${type[0]}$${kind}$_testsuite

    subroutine test_dense_expm_${type[0]}$${kind}$(error)
        ! Error type to be returned.
        type(error_type), allocatable, intent(out) :: error
        ! Problem dimension.
        integer, parameter :: n = 5, m = 6
        ! Test matrix.
        ${type}$ :: A(n, n), E(n, n), Eref(n, n)
        integer :: i, j

        ! Initialize matrix.
        A = 0.0_${kind}$
        do i = 1, n-1
            A(i, i+1) = m*1.0_${kind}$
        enddo

        ! Reference with analytical exponential.
        Eref = eye(n)
        do i = 1, n-1
            do j = 1, n-i
                Eref(i, i+j) = Eref(i, i+j-1)*m/j
            enddo
        enddo

        ! Compute matrix exponential.
        call expm(E, A)

        ! Check result.
        call check(error, maxval(abs(E-Eref)) < rtol_${kind}$)
        call check_test(error, 'test_dense_expm_${type[0]}$${kind}$', 'maxval(abs(E-Eref)) < rtol')

        return
    end subroutine test_dense_expm_${type[0]}$${kind}$

    subroutine test_kexptA_${type[0]}$${kind}$(error)
        ! Error type to be returned.
        type(error_type), allocatable, intent(out) :: error
        ! Test matrix.
        class(linop_${type[0]}$${kind}$), allocatable :: A
        ! Basis vectors.
        class(vector_${type[0]}$${kind}$), allocatable :: Q, Xref, Xkryl
        ! Krylov subspace dimension.
        integer, parameter :: kdim = test_size
    
        ! ----- Internal variables -----
        ${type}$ :: E(kdim, kdim)
        real(${kind}$), parameter :: tau = 0.1_${kind}$
        logical, parameter :: verb = .true.
        integer, parameter :: nkmax = 64
        real(${kind}$) :: err
        integer :: info
        
        ! Initialize data.
        A = linop_${type[0]}$${kind}$() ; call init_rand(A)
        allocate(Q) ; call init_rand(Q)
        allocate(Xref) ; call Xref%zero()
        allocate(XKryl) ; call Xkryl%zero()

        ! Dense computation.
        call expm(E, tau*A%data)
        Xref%data = matmul(E, Q%data)

        ! Krylov exponential.
        call kexpm(Xkryl, A, Q, tau, rtol_${kind}$, info, verbosity=verb, kdim=nkmax)
        call check_info(info, 'kexpm', module=this_module, procedure='test_kexptA_${type[0]}$${kind}$')

        ! Check result.
        call Xkryl%sub(Xref) ; err = Xkryl%norm()
        if (verb) write(output_unit, *) "     True error: ||error||_2 =", err

        call check(error, err < rtol_${kind}$)
        call check_test(error, 'test_kexptA_${type[0]}$${kind}$', 'norm2(x - x_true) < rol')

        return
    end subroutine test_kexptA_${type[0]}$${kind}$

    subroutine test_block_kexptA_${type[0]}$${kind}$(error)
        !! This function tests the Krylov based approximation of the action of the exponential
        !! propagator against the dense computation for a random operator, a random RHS and a 
        !! typical value of tau.

        ! Error type to be returned.
        type(error_type), allocatable, intent(out) :: error
        class(linop_${type[0]}$${kind}$), allocatable :: A
        ! Basis vectors.
        class(vector_${type[0]}$${kind}$), allocatable :: B(:)
        class(vector_${type[0]}$${kind}$), allocatable :: Cref(:)
        class(vector_${type[0]}$${kind}$), allocatable :: C(:), Cblk(:)
        ! Krylov subspace dimension.
        integer, parameter :: kdim = test_size
        ! Test matrix.
        ${type}$ :: Adata(kdim, kdim)
        ${type}$ :: Edata(kdim, kdim)
        ! GS factors.
        ${type}$ :: R(kdim, kdim)
        ${type}$ :: Id(kdim, kdim)
        ! Information flag.
        integer :: info
        ! Test parameters
        integer       , parameter :: nkmax = 15
        integer       , parameter :: p = 3
        real(${kind}$), parameter :: tau = 0.1_${kind}$
        real(${kind}$), parameter :: tol = rtol_${kind}$
        logical       , parameter :: verb = .true.
        ! Misc.
        integer  :: i, j, k
        ${type}$ :: Xdata(test_size,p), Qdata(test_size,p)
        real(${kind}$) :: alpha
        ${type}$ :: err(p, p)

        Adata = 0.0_${kind}$ ; Edata = 0.0_${kind}$ ; Xdata = 0.0_${kind}$

        allocate(Cref(p)) ; call initialize_krylov_subspace(Cref)
        allocate(C(p))    ; call initialize_krylov_subspace(C)
        allocate(Cblk(p)) ; call initialize_krylov_subspace(Cblk)

        ! --> Initialize operator.
        A = linop_${type[0]}$${kind}$() ; call init_rand(A) ; call get_data(Adata, A)
       
        ! --> Initialize rhs.
        allocate(B(1:p)) ; call init_rand(B) ; call get_data(Qdata, B)

        ! Comparison is dense computation (10th order Pade approximation)
        call expm(Edata, tau*Adata) ; Xdata = matmul(Edata,Qdata) ; call put_data(Cref, Xdata)

        ! Compute Krylov matrix exponential using sequential arnoldi method for each input column
        if (verb) write(*,*) 'SEQUENTIAL ARNOLDI'
        do i = 1,p
            if (verb) write(*,*) '    column',i
            call kexpm(C(i), A, B(i), tau, tol, info, verbosity=verb, kdim=nkmax)
            call check_info(info, 'kexpm', module=this_module, procedure='test_block_kexptA_${type[0]}$${kind}$, 1')
        end do
        
        ! Compute Krylov matrix exponential using block-arnoldi method
        if (verb) write(*,*) 'BLOCK-ARNOLDI'
        call kexpm(Cblk, A, B, tau, tol, info, verbosity=verb, kdim=nkmax)
        call check_info(info, 'kexpm', module=this_module, procedure='test_block_kexptA_${type[0]}$${kind}$, 2')
    
        do i = 1, p
            write(output_unit, *) C(i)%norm(), Cblk(i)%norm()
            call C(i)%sub(Cref(i)) ; call Cblk(i)%sub(Cref(i))
        end do

        ! Compute 2-norm of the error
        if (verb) then
            do i = 1, size(C)
                do j = 1, size(C)
                    err(i, j) = C(i)%dot(C(j))
                enddo
            enddo
            alpha = norm2(abs(err))
            write(*,*) '--------------------------------------------------------------------'
            write(*, *) '    true error (seq.):   ||error||_2 = ', alpha
        endif
 
        do i = 1, size(Cblk)
            do j = 1, size(Cblk)
                err(i, j) = Cblk(i)%dot(Cblk(j))
            enddo
        enddo
        
        alpha = norm2(abs(err))
        if (verb) write(*, *) '    true error (block):  ||error||_2 = ', alpha

        call check(error, alpha < rtol_${kind}$)
        call check_test(error, 'test_block_kexptA_${type[0]}$${kind}$', 'norm2(x - x_true) < rol')

        return
    end subroutine test_block_kexptA_${type[0]}$${kind}$

    #:endfor
    !-----------------------------------------------------------
    !-----     UNIT TESTS FOR DENSE MATRIX SQUARE ROOT     -----
    !-----------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine collect_sqrtm_${type[0]}$${kind}$_testsuite(testsuite)
        type(unittest_type), allocatable, intent(out) :: testsuite(:)

        testsuite = [ &
                        new_unittest("Dense sqrtm for positive definite matrices.", test_dense_sqrtm_pos_def_${type[0]}$${kind}$), &
                        new_unittest("Dense sqrtm for positive semi-definite matrices.", test_dense_sqrtm_pos_semi_def_${type[0]}$${kind}$) &
                    ]

        return
    end subroutine collect_sqrtm_${type[0]}$${kind}$_testsuite

    subroutine test_dense_sqrtm_pos_def_${type[0]}$${kind}$(error)
       !> This function tests the matrix version of the sqrt function for the case of
       ! a symmetric/hermitian positive definite matrix
    
       !> Error type to be returned.
       type(error_type), allocatable, intent(out) :: error
       !> Problem dimension.
       integer, parameter :: n = 5
       !> Test matrix.
       ${type}$ :: A(n, n)
       ${type}$ :: sqrtmA(n, n)
       complex(${kind}$) :: lambda(n)
       integer :: i, info
    
       ! --> Initialize matrix.
       #:if type[0] == "r"
       call random_number(A)
       #:else
       call random_number(A%re)
       call random_number(A%im)
       #:endif
       ! make symmetric/hermitian positive definite
       #:if type[0] == "r"
       A = 0.5_${kind}$*(A + transpose(A))
       #:else
       A = 0.5_${kind}$*(A + conjg(transpose(A)))
       #:endif
       call eig(A, sqrtmA, lambda)
       do i = 1,n
          lambda(i) = abs(lambda(i)) + 0.1_${kind}$
       end do
       ! reconstruct matrix
       #:if type[0] == "r"
       A = matmul(sqrtmA, matmul(diag(lambda), transpose(sqrtmA)))
       ! ensure it is exactly symmetric/hermitian
       A = 0.5_${kind}$*(A + transpose(A))
       #:else
       A = matmul(sqrtmA, matmul(diag(lambda), conjg(transpose(sqrtmA))))
       ! ensure it is exactly symmetric/hermitian
       A = 0.5_${kind}$*(A + conjg(transpose(A)))
       #:endif
     
       ! compute matrix square root
       call sqrtm(A, sqrtmA, info)
       call check_info(info, 'sqrtm', module=this_module, procedure='test_dense_sqrtm_pos_def_${type[0]}$${kind}$')
    
       #:if type[0] == "r"
       write(*,*) 'max err: ', maxval(matmul(sqrtmA, sqrtmA) - A)
       call check(error, maxval(matmul(sqrtmA, sqrtmA) - A) < rtol_${kind}$)
       #:else
       write(*,*) 'max err: ', maxval(abs(matmul(sqrtmA, sqrtmA) - A))
       call check(error, maxval(abs(matmul(sqrtmA, sqrtmA) - A)) < rtol_${kind}$)
       #:endif
       call check_test(error, 'test_dense_sqrtm_pos_def_${type[0]}$${kind}$', 'sqrt(A)**2 /= A')
    
       return
    end subroutine test_dense_sqrtm_pos_def_${type[0]}$${kind}$
    
    subroutine test_dense_sqrtm_pos_semi_def_${type[0]}$${kind}$(error)
       !> This function tests the matrix version of the sqrt function for the case 
       ! of a symmetric semi-definite matrix
    
       !> Error type to be returned.
       type(error_type), allocatable, intent(out) :: error
       !> Problem dimension.
       integer, parameter :: n = 5
       !> Test matrix.
       ${type}$ :: A(n, n)
       ${type}$ :: sqrtmA(n, n)
       complex(${kind}$) :: lambda(n)
       integer :: i, info
    
       ! --> Initialize matrix.
       #:if type[0] == "r"
       call random_number(A)
       #:else
       call random_number(A%re)
       call random_number(A%im)
       #:endif
       ! make symmetric/hermitian positive semi-definite
       #:if type[0] == "r"
       A = 0.5_${kind}$*(A + transpose(A))
       #:else
       A = 0.5_${kind}$*(A + conjg(transpose(A)))
       #:endif
       call eig(A, sqrtmA, lambda)
       do i = 1,n-1
          lambda(i) = abs(lambda(i)) + 0.1_${kind}$
       end do
       lambda(n) = zero_r${kind}$
       ! reconstruct matrix
       #:if type[0] == "r"
       A = matmul(sqrtmA, matmul(diag(lambda), transpose(sqrtmA)))
       ! ensure it is exactly symmetric/hermitian
       A = 0.5_${kind}$*(A + transpose(A))
       #:else
       A = matmul(sqrtmA, matmul(diag(lambda), conjg(transpose(sqrtmA))))
       ! ensure it is exactly symmetric/hermitian
       A = 0.5_${kind}$*(A + conjg(transpose(A)))
       #:endif
    
       ! compute matrix square root
       call sqrtm(A, sqrtmA, info)
       call check_info(info, 'sqrtm', module=this_module, procedure='test_dense_sqrtm_pos_semi_def_${type[0]}$${kind}$')
    
       #:if type[0] == "r"
       write(*,*) 'max err: ', maxval(matmul(sqrtmA, sqrtmA) - A)
       call check(error, maxval(matmul(sqrtmA, sqrtmA) - A) < rtol_${kind}$)
       #:else
       write(*,*) 'max err: ', maxval(abs(matmul(sqrtmA, sqrtmA) - A))
       call check(error, maxval(abs(matmul(sqrtmA, sqrtmA) - A)) < rtol_${kind}$)
       #:endif
       call check_test(error, 'test_dense_sqrtm_pos_semi_def_${type[0]}$${kind}$', 'sqrt(A)**2 /= A')
    
       return
    end subroutine test_dense_sqrtm_pos_semi_def_${type[0]}$${kind}$

    #:endfor

end module

