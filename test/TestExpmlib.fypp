#:include "../include/common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module TestExpmlib
    ! Fortran Standard Library.
    use iso_fortran_env
    use stdlib_math, only: is_close, all_close
    use stdlib_linalg, only: eye
    use stdlib_io_npy, only: save_npy

    ! LightKrylov
    use LightKrylov

    ! Testdrive
    use testdrive, only: new_unittest, unittest_type, error_type, check
    use TestVectors
    use TestLinops
    use TestUtils
    use TestKrylov

    #:for kind, type in RC_KINDS_TYPES
    public :: collect_expm_${type[0]}$${kind}$_testsuite
    #:endfor

contains

    !--------------------------------------------------------------
    !-----     UNIT TESTS FOR DENSE MATRIX EXPONENTIATION     -----
    !--------------------------------------------------------------

    #:for kind, type in RC_KINDS_TYPES
    subroutine collect_expm_${type[0]}$${kind}$_testsuite(testsuite)
        type(unittest_type), allocatable, intent(out) :: testsuite(:)

        testsuite = [ &
                        new_unittest("Dense expm.", test_dense_expm_${type[0]}$${kind}$), &
                        new_unittest("Krylov expm.", test_kexptA_${type[0]}$${kind}$) &
                    ]

        return
    end subroutine collect_expm_${type[0]}$${kind}$_testsuite

    subroutine test_dense_expm_${type[0]}$${kind}$(error)
        !> Error type to be returned.
        type(error_type), allocatable, intent(out) :: error
        !> Problem dimension.
        integer, parameter :: n = 5, m = 6
        !> Test matrix.
        ${type}$ :: A(n, n), E(n, n), Eref(n, n)
        integer :: i, j

        ! Initialize matrix.
        A = 0.0_${kind}$
        do i = 1, n-1
            A(i, i+1) = m*1.0_${kind}$
        enddo

        ! Reference with analytical exponential.
        Eref = eye(n)
        do i = 1, n-1
            do j = 1, n-i
                Eref(i, i+j) = Eref(i, i+j-1)*m/j
            enddo
        enddo

        ! Compute matrix exponential.
        call expm(E, A)

        ! Check result.
        call check(error, maxval(abs(E-Eref)) < rtol_${kind}$)

        return
    end subroutine test_dense_expm_${type[0]}$${kind}$

    subroutine test_kexptA_${type[0]}$${kind}$(error)
        !> Error type to be returned.
        type(error_type), allocatable, intent(out) :: error
        !> Test matrix.
        class(linop_${type[0]}$${kind}$), allocatable :: A
        !> Basis vectors.
        class(vector_${type[0]}$${kind}$), allocatable :: Q, Xref, Xkryl
        !> Krylov subspace dimension.
        integer, parameter :: kdim = test_size
    
        ! ----- Internal variables -----
        ${type}$ :: E(kdim, kdim)
        real(${kind}$), parameter :: tau = 0.1_${kind}$
        logical, parameter :: verb = .true.
        integer, parameter :: nkmax = 64
        real(${kind}$) :: err
        integer :: info
        
        ! Initialize data.
        A = linop_${type[0]}$${kind}$() ; call init_rand(A)
        allocate(Q) ; call init_rand(Q)
        allocate(Xref) ; call Xref%zero()
        allocate(XKryl) ; call Xkryl%zero()

        ! Dense computation.
        call expm(E, tau*A%data)
        Xref%data = matmul(E, Q%data)

        ! Krylov exponential.
        call kexpm(Xkryl, A, Q, tau, atol_${kind}$, info, verbosity=verb, kdim=nkmax)

        call save_npy("test_krylov_expm_operator.npy", A%data)
        call save_npy("test_krylov_expm_rhs.npy", Q%data)
        call save_npy("test_krylov_expm_ref.npy", Xref%data)
        call save_npy("test_krylov_expm_kexpm.npy", Xkryl%data)
 
        ! Check result.
        call Xkryl%sub(Xref) ; err = Xkryl%norm()
        if (verb) write(output_unit, *) "     True error: ||error||_2 =", err

       call check(error, err < rtol_${kind}$)

        return
    end subroutine test_kexptA_${type[0]}$${kind}$

    #:endfor

end module

